{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hello~ This is Jasper Yang's Notes Set. Welcome! This set contains my study notes and excerpts from books. Though I've never concerned that there will be someone notice and read these notes. But if you are, wish my notes would help you. Please don't hesitate to inform me if anything goes wrong. Have a good day!","title":"Home"},{"location":"LeetCode/1687._Delivering_Boxes_from_Storage_to_Ports/","tags":["LeetCode","Algorithms"],"text":"Analyse As the dynamic programming solution's max time complexity is $\\text O(n^2)$. We could simply get the first solution:\\ This Code comes from linshan077 . And it is almost the best implement of DP. Where the trip assist to decline the cost of repeatedly judging boxes[j][0] == boxes[j-1][0] and dp is the common implement of dynamic programming. class Solution1 { public : int boxDelivering ( vector < vector < int >>& boxes , int portsCount , int maxBoxes , int maxWeight ) { vector < int > trips ( boxes . size ()); trips [ 0 ] = 0 ; for ( int i = 1 ; i < boxes . size (); ++ i ) { if ( boxes [ i ][ 0 ] == boxes [ i -1 ][ 0 ]) { trips [ i ] = trips [ i -1 ]; } else { trips [ i ] = trips [ i -1 ] + 1 ; } } // dp[i+1] is minimum trips assuming i is the last box to deliver and will return to port afterwards. vector < int > dp ( boxes . size () + 1 ); dp [ 0 ] = 0 ; for ( int i = 0 ; i < boxes . size (); ++ i ) { dp [ i + 1 ] = INT_MAX ; int sum_weights = 0 ; for ( int j = i ; j >= 0 && i - j + 1 <= maxBoxes ; -- j ) { sum_weights += boxes [ j ][ 1 ]; if ( sum_weights > maxWeight ) break ; dp [ i + 1 ] = std :: min ( dp [ i + 1 ], dp [ j ] + 2 + trips [ i ] - trips [ j ]); } } return dp . back (); } }; However, it got a TLE. And we translate min(dp[j]+2+trips[i]-trips[j]) into 2+trips[i]+min(dp[j]-trips[j]) . It turns to a question: find the minimum in a Slide window(Which we can easily solve by a deque with total time complexity $\\text O(n)$). class Solution2 { public : int boxDelivering ( vector < vector < int >>& boxes , int portsCount , int maxBoxes , int maxWeight ) { vector < int > trips ( boxes . size ()); trips [ 0 ] = 0 ; for ( int i = 1 ; i < boxes . size (); ++ i ) { if ( boxes [ i ][ 0 ] == boxes [ i -1 ][ 0 ]) { trips [ i ] = trips [ i -1 ]; } else { trips [ i ] = trips [ i -1 ] + 1 ; } } vector < long int > weights ( boxes . size () + 1 ); weights [ 0 ] = 0 ; for ( int i = 0 ; i < boxes . size (); ++ i ) { weights [ i + 1 ] = weights [ i ] + boxes [ i ][ 1 ]; } vector < int > dp ( boxes . size () + 1 ); dp [ 0 ] = 0 ; vector < long > weight ( boxes . size () + 1 ); weight [ 0 ] = 0 ; for ( int i = 1 ; i != boxes . size () + 1 ; ++ i ) weight [ i ] = weight [ i -1 ] + boxes [ i -1 ][ 1 ]; deque < pair < int , int >> dq ; int temp , totalWeight , totalBoxes ; int j = 0 ; dq . push_back ({ 0 , dp [ 0 ] - trips [ 0 ]}); dp [ 1 ] = 2 + trips [ 0 ] + dq . front (). second ; for ( int i = 1 ; i < boxes . size (); ++ i ) { temp = dp [ i ] - trips [ i ]; while ( ! dq . empty () && dq . back (). second > temp ) dq . pop_back (); dq . push_back ({ i , temp }); totalWeight = weight [ i + 1 ] - weight [ j ]; totalBoxes = i - j + 1 ; while ( totalWeight > maxWeight || totalBoxes > maxBoxes ){ dq . pop_front (); j = dq . front (). first ; totalWeight = weight [ i + 1 ] - weight [ j ]; totalBoxes = i - j + 1 ; } dp [ i + 1 ] = 2 + trips [ i ] + dq . front (). second ; } return dp . back (); } }; The above code deducts the cost of repetitive calculation of dp[i+1] = std::min(dp[i+1], dp[j]+2+trips[i]-trips[j]) And turns $\\text O(mn)$(where m is the maxBoxes) into $\\text O(n) + \\text O(n) = \\text O(n)$. Reference C++ DP solution with thinking process: brute force -> priority queue -> mono queue Java | From O(N^2) to O(N) | MonoQueue w/ DP","title":"LeetCode 1687. Delivering Boxes from Storage to Ports"},{"location":"LeetCode/1687._Delivering_Boxes_from_Storage_to_Ports/#analyse","text":"As the dynamic programming solution's max time complexity is $\\text O(n^2)$. We could simply get the first solution:\\ This Code comes from linshan077 . And it is almost the best implement of DP. Where the trip assist to decline the cost of repeatedly judging boxes[j][0] == boxes[j-1][0] and dp is the common implement of dynamic programming. class Solution1 { public : int boxDelivering ( vector < vector < int >>& boxes , int portsCount , int maxBoxes , int maxWeight ) { vector < int > trips ( boxes . size ()); trips [ 0 ] = 0 ; for ( int i = 1 ; i < boxes . size (); ++ i ) { if ( boxes [ i ][ 0 ] == boxes [ i -1 ][ 0 ]) { trips [ i ] = trips [ i -1 ]; } else { trips [ i ] = trips [ i -1 ] + 1 ; } } // dp[i+1] is minimum trips assuming i is the last box to deliver and will return to port afterwards. vector < int > dp ( boxes . size () + 1 ); dp [ 0 ] = 0 ; for ( int i = 0 ; i < boxes . size (); ++ i ) { dp [ i + 1 ] = INT_MAX ; int sum_weights = 0 ; for ( int j = i ; j >= 0 && i - j + 1 <= maxBoxes ; -- j ) { sum_weights += boxes [ j ][ 1 ]; if ( sum_weights > maxWeight ) break ; dp [ i + 1 ] = std :: min ( dp [ i + 1 ], dp [ j ] + 2 + trips [ i ] - trips [ j ]); } } return dp . back (); } }; However, it got a TLE. And we translate min(dp[j]+2+trips[i]-trips[j]) into 2+trips[i]+min(dp[j]-trips[j]) . It turns to a question: find the minimum in a Slide window(Which we can easily solve by a deque with total time complexity $\\text O(n)$). class Solution2 { public : int boxDelivering ( vector < vector < int >>& boxes , int portsCount , int maxBoxes , int maxWeight ) { vector < int > trips ( boxes . size ()); trips [ 0 ] = 0 ; for ( int i = 1 ; i < boxes . size (); ++ i ) { if ( boxes [ i ][ 0 ] == boxes [ i -1 ][ 0 ]) { trips [ i ] = trips [ i -1 ]; } else { trips [ i ] = trips [ i -1 ] + 1 ; } } vector < long int > weights ( boxes . size () + 1 ); weights [ 0 ] = 0 ; for ( int i = 0 ; i < boxes . size (); ++ i ) { weights [ i + 1 ] = weights [ i ] + boxes [ i ][ 1 ]; } vector < int > dp ( boxes . size () + 1 ); dp [ 0 ] = 0 ; vector < long > weight ( boxes . size () + 1 ); weight [ 0 ] = 0 ; for ( int i = 1 ; i != boxes . size () + 1 ; ++ i ) weight [ i ] = weight [ i -1 ] + boxes [ i -1 ][ 1 ]; deque < pair < int , int >> dq ; int temp , totalWeight , totalBoxes ; int j = 0 ; dq . push_back ({ 0 , dp [ 0 ] - trips [ 0 ]}); dp [ 1 ] = 2 + trips [ 0 ] + dq . front (). second ; for ( int i = 1 ; i < boxes . size (); ++ i ) { temp = dp [ i ] - trips [ i ]; while ( ! dq . empty () && dq . back (). second > temp ) dq . pop_back (); dq . push_back ({ i , temp }); totalWeight = weight [ i + 1 ] - weight [ j ]; totalBoxes = i - j + 1 ; while ( totalWeight > maxWeight || totalBoxes > maxBoxes ){ dq . pop_front (); j = dq . front (). first ; totalWeight = weight [ i + 1 ] - weight [ j ]; totalBoxes = i - j + 1 ; } dp [ i + 1 ] = 2 + trips [ i ] + dq . front (). second ; } return dp . back (); } }; The above code deducts the cost of repetitive calculation of dp[i+1] = std::min(dp[i+1], dp[j]+2+trips[i]-trips[j]) And turns $\\text O(mn)$(where m is the maxBoxes) into $\\text O(n) + \\text O(n) = \\text O(n)$.","title":"Analyse"},{"location":"LeetCode/1687._Delivering_Boxes_from_Storage_to_Ports/#reference","text":"C++ DP solution with thinking process: brute force -> priority queue -> mono queue Java | From O(N^2) to O(N) | MonoQueue w/ DP","title":"Reference"},{"location":"LeetCode/188._Best_Time_to_Buy_and_Sell_Stock_IV/","tags":["LeetCode","Algorithms"],"text":"Analyse This is another dynamic programming problem similar to 1687. Delivering Boxes from Storage to Ports . And however, with a limitation of purchase times. We can just use two iteration on this question. One is the iteration of vector prices(obviously), and another is the iteration of purchase times k. What's more, we need to purchase a good before selling it. Thus we need to record the purchases. And the code is as below class Solution { public : int maxProfit ( int k , vector < int >& price ) { vector < int > profit ( 2 * k + 1 , INT_MIN ); //if we do nothing, the profit is 0 without doubt profit [ 0 ] = 0 ; //the iteration of prices vector for ( int j = 0 ; j < price . size (); j ++ ) { //the iteration of transaction times /*for each i, profit[i+1] is the profit with a good in stock, *and profit[i+2] is the profit after selling goods. */ for ( int i = 0 ; i + 2 <= 2 * k ; i += 2 ){ profit [ i + 1 ] = max ( profit [ i + 1 ], profit [ i ] - price [ j ]); profit [ i + 2 ] = max ( profit [ i + 2 ], profit [ i + 1 ] + price [ j ]); } } return * max_element ( profit . begin (), profit . end ()); } }; Reference 1687. Delivering Boxes from Storage to Ports \u2705Easy solution Explained || Beginner Friendly \ud83d\udd25||\u2714\ufe0f Best Method","title":"LeetCode 188. Best Time to Buy and Sell Stock IV"},{"location":"LeetCode/188._Best_Time_to_Buy_and_Sell_Stock_IV/#analyse","text":"This is another dynamic programming problem similar to 1687. Delivering Boxes from Storage to Ports . And however, with a limitation of purchase times. We can just use two iteration on this question. One is the iteration of vector prices(obviously), and another is the iteration of purchase times k. What's more, we need to purchase a good before selling it. Thus we need to record the purchases. And the code is as below class Solution { public : int maxProfit ( int k , vector < int >& price ) { vector < int > profit ( 2 * k + 1 , INT_MIN ); //if we do nothing, the profit is 0 without doubt profit [ 0 ] = 0 ; //the iteration of prices vector for ( int j = 0 ; j < price . size (); j ++ ) { //the iteration of transaction times /*for each i, profit[i+1] is the profit with a good in stock, *and profit[i+2] is the profit after selling goods. */ for ( int i = 0 ; i + 2 <= 2 * k ; i += 2 ){ profit [ i + 1 ] = max ( profit [ i + 1 ], profit [ i ] - price [ j ]); profit [ i + 2 ] = max ( profit [ i + 2 ], profit [ i + 1 ] + price [ j ]); } } return * max_element ( profit . begin (), profit . end ()); } };","title":"Analyse"},{"location":"LeetCode/188._Best_Time_to_Buy_and_Sell_Stock_IV/#reference","text":"1687. Delivering Boxes from Storage to Ports \u2705Easy solution Explained || Beginner Friendly \ud83d\udd25||\u2714\ufe0f Best Method","title":"Reference"},{"location":"LeetCode/1932._Merge_BSTs_to_Create_Single_BST/","tags":["LeetCode","Algorithms"],"text":"Analyse {% note danger simple %} This question should be a medium question \ud83d\ude02 {% endnote %} This question doesn't request any profound algorithms but does need to notice many details. Let's build this tree step by step. First, we need to find the tree's root. And we can guarantee that the root node must exists only once. And it must be the only node exists only one time. map < int , TreeNode *> val2Tree ; map < int , int > val2count ; for ( auto & t : trees ){ val2Tree [ t -> val ] = t ; ++ val2count [ t -> val ]; //to avoid dereferencing nullptr ++ val2count [ t -> left ? t -> left -> val : 0 ]; ++ val2count [ t -> right ? t -> right -> val : 0 ]; } Then, we could build the Tree from the root node for ( auto & t : trees ){ if ( val2count [ t -> val ] == 1 ){ //details } } //If there is no valid root node, we can't build a BST return nullptr ; Now, we just need to link each node from top to bottom. bool TreeLink ( TreeNode * Tree , map < int , TreeNode *> & val2Tree , int minLeft = INT_MIN , int maxRight = INT_MAX ) { // If this node has no child node, it is obviously valid if ( Tree == nullptr ) return true ; // We need to judge if this node satisfies the value scope of BST if ( Tree -> val <= minLeft || Tree -> val >= maxRight ) return false ; // If Tree has no child(where Tree->left == nullptr == Tree->right), // find the node with the same value and link them. if ( Tree -> left == Tree -> right ) { auto temp = val2Tree . find ( Tree -> val ); // If the node exists and be different from Tree if ( temp != val2Tree . end () && Tree != temp -> second ) { Tree -> left = temp -> second -> left ; Tree -> right = temp -> second -> right ; // after linking, we needn't to notice this node anymore val2Tree . erase ( temp ); } } // iteration from top to bottom. /** * we need to adjust the child node's scope, where its left child's * max value shouldn't be more than its value. And vice versa */ return TreeLink ( Tree -> left , val2Tree , minLeft , Tree -> val ) && TreeLink ( Tree -> right , val2Tree , Tree -> val , maxRight ); } Whole Solution class Solution { public : bool TreeLink ( TreeNode * Tree , map < int , TreeNode *> & val2Tree , int minLeft = INT_MIN , int maxRight = INT_MAX ) { // If this node has no child node, it is obviously valid if ( Tree == nullptr ) return true ; // We need to judge if this node satisfies the value scope of BST if ( Tree -> val <= minLeft || Tree -> val >= maxRight ) return false ; // If Tree has no child(where Tree->left == nullptr == Tree->right), // find the node with the same value and link them. if ( Tree -> left == Tree -> right ) { auto temp = val2Tree . find ( Tree -> val ); // If the node exists and be different from Tree if ( temp != val2Tree . end () && Tree != temp -> second ) { Tree -> left = temp -> second -> left ; Tree -> right = temp -> second -> right ; // after linking, we needn't to notice this node anymore val2Tree . erase ( temp ); } } // iteration from top to bottom. /** * we need to adjust the child node's scope, where its left child's * max value shouldn't be more than its value. And vice versa */ return TreeLink ( Tree -> left , val2Tree , minLeft , Tree -> val ) && TreeLink ( Tree -> right , val2Tree , Tree -> val , maxRight ); } TreeNode * canMerge ( vector < TreeNode *> & trees ) { map < int , TreeNode *> val2Tree ; map < int , int > val2count ; for ( auto & t : trees ) { val2Tree [ t -> val ] = t ; ++ val2count [ t -> val ]; //to avoid dereferencing nullptr ++ val2count [ t -> left ? t -> left -> val : 0 ]; ++ val2count [ t -> right ? t -> right -> val : 0 ]; } for ( auto & t : trees ) { if ( val2count [ t -> val ] == 1 ) { /* * If val2Tree's size dosen't equal to 1, there must be some * danling node which exists only once too. */ return TreeLink ( t , val2Tree ) && val2Tree . size () == 1 ? t : nullptr ; } } //If there is no valid root node, we can't build a BST return nullptr ; } }; Reference 1932. Merge BSTs to Create Single BST","title":"LeetCode 1932. Merge BSTs to Create Single BST"},{"location":"LeetCode/1932._Merge_BSTs_to_Create_Single_BST/#analyse","text":"{% note danger simple %} This question should be a medium question \ud83d\ude02 {% endnote %} This question doesn't request any profound algorithms but does need to notice many details. Let's build this tree step by step. First, we need to find the tree's root. And we can guarantee that the root node must exists only once. And it must be the only node exists only one time. map < int , TreeNode *> val2Tree ; map < int , int > val2count ; for ( auto & t : trees ){ val2Tree [ t -> val ] = t ; ++ val2count [ t -> val ]; //to avoid dereferencing nullptr ++ val2count [ t -> left ? t -> left -> val : 0 ]; ++ val2count [ t -> right ? t -> right -> val : 0 ]; } Then, we could build the Tree from the root node for ( auto & t : trees ){ if ( val2count [ t -> val ] == 1 ){ //details } } //If there is no valid root node, we can't build a BST return nullptr ; Now, we just need to link each node from top to bottom. bool TreeLink ( TreeNode * Tree , map < int , TreeNode *> & val2Tree , int minLeft = INT_MIN , int maxRight = INT_MAX ) { // If this node has no child node, it is obviously valid if ( Tree == nullptr ) return true ; // We need to judge if this node satisfies the value scope of BST if ( Tree -> val <= minLeft || Tree -> val >= maxRight ) return false ; // If Tree has no child(where Tree->left == nullptr == Tree->right), // find the node with the same value and link them. if ( Tree -> left == Tree -> right ) { auto temp = val2Tree . find ( Tree -> val ); // If the node exists and be different from Tree if ( temp != val2Tree . end () && Tree != temp -> second ) { Tree -> left = temp -> second -> left ; Tree -> right = temp -> second -> right ; // after linking, we needn't to notice this node anymore val2Tree . erase ( temp ); } } // iteration from top to bottom. /** * we need to adjust the child node's scope, where its left child's * max value shouldn't be more than its value. And vice versa */ return TreeLink ( Tree -> left , val2Tree , minLeft , Tree -> val ) && TreeLink ( Tree -> right , val2Tree , Tree -> val , maxRight ); }","title":"Analyse"},{"location":"LeetCode/1932._Merge_BSTs_to_Create_Single_BST/#whole-solution","text":"class Solution { public : bool TreeLink ( TreeNode * Tree , map < int , TreeNode *> & val2Tree , int minLeft = INT_MIN , int maxRight = INT_MAX ) { // If this node has no child node, it is obviously valid if ( Tree == nullptr ) return true ; // We need to judge if this node satisfies the value scope of BST if ( Tree -> val <= minLeft || Tree -> val >= maxRight ) return false ; // If Tree has no child(where Tree->left == nullptr == Tree->right), // find the node with the same value and link them. if ( Tree -> left == Tree -> right ) { auto temp = val2Tree . find ( Tree -> val ); // If the node exists and be different from Tree if ( temp != val2Tree . end () && Tree != temp -> second ) { Tree -> left = temp -> second -> left ; Tree -> right = temp -> second -> right ; // after linking, we needn't to notice this node anymore val2Tree . erase ( temp ); } } // iteration from top to bottom. /** * we need to adjust the child node's scope, where its left child's * max value shouldn't be more than its value. And vice versa */ return TreeLink ( Tree -> left , val2Tree , minLeft , Tree -> val ) && TreeLink ( Tree -> right , val2Tree , Tree -> val , maxRight ); } TreeNode * canMerge ( vector < TreeNode *> & trees ) { map < int , TreeNode *> val2Tree ; map < int , int > val2count ; for ( auto & t : trees ) { val2Tree [ t -> val ] = t ; ++ val2count [ t -> val ]; //to avoid dereferencing nullptr ++ val2count [ t -> left ? t -> left -> val : 0 ]; ++ val2count [ t -> right ? t -> right -> val : 0 ]; } for ( auto & t : trees ) { if ( val2count [ t -> val ] == 1 ) { /* * If val2Tree's size dosen't equal to 1, there must be some * danling node which exists only once too. */ return TreeLink ( t , val2Tree ) && val2Tree . size () == 1 ? t : nullptr ; } } //If there is no valid root node, we can't build a BST return nullptr ; } };","title":"Whole Solution"},{"location":"LeetCode/1932._Merge_BSTs_to_Create_Single_BST/#reference","text":"1932. Merge BSTs to Create Single BST","title":"Reference"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/","tags":["C++","Notes"],"text":"C++ learning notes Generic algorithm lambda [capture list] (parameter list) -> return type {function body} we can ignore the parameter list and return type , but the capture list and the function body must be reserved eg: []( const string & a , const string & b ) { return a . size () < b . size ();} dynamic memory shared_ptr <> use function make_shared<>() unique_ptr <> must be initialized once the pointer is created weak_ptr <> can be assigned allocator allocator < string > alloc ; auto const p = alloc . allocate ( n ); weak_ptr < string [] > q = p ; for ( int i = 0 ; i != n ; ++ i ){ alloc . construct ( q ++ , \"hello world!\" ); } for ( int i = 0 ; i != n ; ++ i ) { cout << * ( p + i ) << endl ; } alloc . deallocate ( p , n ); delete p ; //provided p points to an object or be nullptr delete [] p ; //provided p points to an array or be nullptr Copy, Assign and Destroy specific member function to control above three operations copy constructor copy-assignment operator move constructor move-assignment operator destructor copy constructor class Foo { public : /* *default defination in class body is inline *if we don't hope so, we need to define \"= default\" out of the class body *generally, function defined in class body is inline */ Foo () = default ; //default constructor Foo ( const Foo & ); //copy constructor //first parameter must be a reference, and almost always be a const reference } class Foo2 { public : //explicit prevents implicit conversion explicit Foo2 () = default ; explicit Foo2 ( int num ) : n ( num ) {} private : int n ; }; copy-assignment constructor class Foo { public : /* *we define a copy-assignment constructor below *keyword operator+symbol is an overloaded operator *which defines an operator(like =,+,- and so on) */ Foo & operator = ( const Foo & f ){ this -> n = f -> n ; return * this ; } private : int n ; } int main (){ Foo f1 , f2 (); //f2 is default initialized f1 = f2 ; //equals to f1(f2) }; stop the copy if we don't want a copy operation, we need to define it as the delete function class NoCopy { public : NoCopy () = default ; /* *\"= delete\" must be present when we firstly declare it. * *by the way, we can delete any functions(except the destructor), *thongh i haven't clearly understood its effect and affect. *one interesting and meaningful example is, if a class's member *can't be implicitly initialized, copied, assigned or destroied, *its implicit initializer's member function is deleted. *It prevents from creating indestructible object. * *principle: destructor can't be delete */ NoCopy ( const NoCopy & ) = delete ; //stop the copy NoCopy & operator = ( const NoCopy & ) = delete ; //stop the copy-assignment ~ NoCopy () = default ; /* *we can put the copy constructor into private zone to prevent from copying it. *we need to declare it in the private zone first *then define it in the public zone.(in order to prevent friend use it) *however, this practice is not recommended. */ } destructor destructor delete the resource used by objects, and destruct non-static elements it is used whenever the object is destroyed implicitly destruct a pointer won't delete the object it points. on the contrary, smart pointer is class type with destructor, thus it can delete the object class Foo { public : ~ Foo () = default ; //destructor.this function can't be overloaded }; principle define destructor before assuring weather it needs a destructor or not if a class needs a copy constructor, it always need a copy-assignment constructor. And vice verse copy control and resource management behave like a value: the copy and the original object is fully independent behave like a pointer: the copy and the original object point to the same underlying data classes which behave like a value class HasPtr { public : HasPtr ( const std :: string & s = std :: string ()) : ps ( new std :: string ( s )), i ( 0 ) {} //every HasPtr's copy has its own string member with equal value HasPtr ( const HasPtr & p ) : ps ( new std :: string ( * ( p . ps ))), i ( p . i ) {} /* *most copy assignment constructor combines the function *of destructor and copy constructor. * *for instance, copy assignment constructor *destroys the left side object's resource as destructor, *and copies data from the right side object *to the left one like copy constructor * *if possible, copy assignment constructor should be exception safe. *which means when an exception occurs, *it can put the left side object in a meaningful state */ HasPtr & operator = ( const HasPtr & ); ~ HasPtr () { delete ps ; } private : std :: string * ps ; int i ; }; /* *in this case, to ensure exception safety, *we copy the right object's data first *to ensure exception safety before assignment. *then we delete the resource of the left object and execute assignment */ HasPtr & HasPtr :: operator = ( const HasPtr & rhs ) { auto newp = new std :: string ( * rhs . ps ); delete ps ; ps = newp ; i = rhs . i ; return * this ; } classes which behave like a pointer use reference count to control the underlying data class HasPtr { public : HasPtr ( const std :: string & s = std :: string ()) : ps ( new std :: string ( s )), i ( 0 ), use ( new std :: size_t ( 1 )) {} //copy the pointer to ensure they point to the same underlying data //increase the reference count HasPtr ( const HasPtr & p ) : ps ( p . ps ), i ( p . i ), use ( p . use ) { ++* use ; } HasPtr & operator = ( const HasPtr & ); ~ HasPtr (); private : std :: string * ps ; int i ; std :: size_t * use ; //reference count }; HasPtr ::~ HasPtr () { if ( --* use == 0 ) { delete ps ; delete use ; } } HasPtr & HasPtr :: operator = ( const HasPtr & rhs ) { ++* rhs . use ; //execute the left object's destructor if ( --* use == 0 ) { delete ps ; delete use ; } //execute assignment ps = rhs . ps ; i = rhs . i ; use = rhs . use ; return * this ; } swap we can swap the pointer to decrease extra memory allocation class HasPtr { friend void swap ( HasPtr & , HasPtr & ); } /* *if a menber of a class has its own swap function, *use the std::swap is an error *and if we implicitly use swap function, the compiler use the overloaded one by default */ inline void swap ( HasPtr & lhs , HasPtr & rhs ){ using std :: swap ; swap ( lhs . ps , rhs . ps ); swap ( lhs . i , rhs . i ); } int main (){ HasPtr h1 (), h2 (); using std :: swap ; swap ( h1 , h2 ); //use the overloaded one } //tip:this function can't overload the HasPtr &HasPtr::operator=(HasPtr &rhs) HasPtr & HasPtr :: operator = ( HasPtr rhs ){ //parameter is a copy, not a reference swap ( * this , rhs ); return * this ; //rhs is destroyed }; move constructor library container, string and shared_ptr class support both move and copy operation IO class and unique_ptr class can be moved, but can't be copied rvalue reference must be bound to an rvalue. we get rvalue reference through && instead of & rvalue reference must be bound to an object ready to be destroyed therefore, we can freely move an rvalue reference resource to another object moreover, we can bound a const lvalue reference to an rvalue, as well expression returns an rvalue. But rvalue reference variate itself is a lvalue eg: int i = 42 ; int & r = i ; const int & r2 = i * 42 ; int && r3 = i * 42 ; int && r4 = r3 ; //illegal all of them is legal except the last one std::move avails to use a lvalue as an rvalue. What's more, we must recognize that executing move means we promote not to use the original element unless we assign or destruct it. int && r4 = std :: move ( r3 ); //legal //use std::move instead of move in order to prevent from potential naming conflict an example of move constructor StrVec :: StrVec ( StrVec && s ) noexcept //move operation shouldn't throw error //initializer take over resource of s : elements ( s . elements ), first_feet ( s . first_feet ), cap ( s . cap ) { s . elements = s . first_feet = s . cap = nullptr ; //brilliant! //get the spark of controlling dynamic memory! //now destructing s is safe //i wander weather we permit s to be meaningfully assigned, //and after insperation, i find that void StrVec::push_back(const std::string &) //has considered this situation. Now both assignment and destruction is ligal. //and at the same time we can't read its value //(certainly i put the whole code into my cpp file to avoid making my notes bloated) } move assignment constructor StrVec & StrVec :: operator = ( StrVec && rhs ) noexcept { //check self-assignment //I guess this operation is designed to avoid freeing itself //otherwise it may move meaningless data and put itself in a meaningless state if ( this != & rhs ) { free (); //release itself elements = rhs . elements ; first_feet = rhs . first_feet ; cap = rhs . cap ; //put rhs in a destructible state rhs . elements = rhs . first_feet = rhs . cap = nullptr ; } return * this ; } //copy and move operation's overload StrVec v1 , v2 ; v1 = v2 ; //copy assignment constructor StrVec getVec ( istream & ); //getVec returns an rvalue //because getVec() dosen't return value instead of reference //up to now getVec() is just a declaration v2 = getVec ( cin ); //move assignment constructor /* *if we didn't define a move constructor *the compiler will convert an rvalue reference to a const reference *and call copy constructor */ reference qualifier C++ permit us to assign value to a rvalue object(so weird) eg: string s1 ( \"a\" ), s2 ( 3 , 'b' ); //s1 = \"a\", s2 = \"bbb\"; /* *(s1 + s2) is an rvalue which never affects s1 and s2's value without assignment *usually it is created by compiler and released soon *the following expression execute: * create a string temp_s = s1 + s2 = \"abbb\"; * assign \"Wow\" to temp_s and return \"Wow\"; * assign \"Wow\" to s3; * release temp_s *Just from my own guess.If there's something wrong, I'll correct it */ string s3 = ( s1 + s2 ) = \"Wow\" ; cout << s3 << endl ; return 0 ; we can use the reference qualifier to enforce the left object is an lvalue or an rvalue class Foo { public : //the & in the back of parameter list enforce the left object is an lvalue Foo & operator = ( const Foo & ) & ; // }; Foo & Foo :: operator = ( const Foo & rhs ) & { // return * this ; } class Foo { public : Foo someMember () const & ; //const should be in front of reference qualifier } reference qualifier and overloaded class Foo { public : Foo sorted () && ; Foo sorted () const & ; private : vector < int > data ; }; //because object is an rvalue, we can change itself without any affection Foo Foo::sorted () && { sort ( data . begin (), data . end ()); return * this ; } //object is an lvalue, thus we can't affect its value Foo Foo::sorted () const & { Foo temp ( * this ); sort ( temp . data . begin (), temp . data . end ()); return temp ; } overloading and type conversion basic concept an operator function should be a member of a class or have at least than one class type parameter which means we can't overload operators acting on the build-in type overloaded operator's priority and associative law is the same as the original operator operators can be overloaded + - * / % ^ & ~ ! , = < > <= >= ++ -- << >> == != && += -= /= %= ^= &= = *= <<= >>= [] () -> ->* new new[] delete delete[] operators can not be overloaded :: .* . ? : operators there are various of operators overloading practice. and you know, cujus rei demonstrationem mirabilem sane detexi. Hanc marginis exiguitas non caperet .(I'm sure I've discovered a wonderful demonstration, but the space here is too small to fill it). so I write them all down in my practice .cpp file and just note some announcements there. The essence of operator overloading is a function call. therefore we can't save the original order of evaluation and the short circuit evaluation. and that's why we don't advice you to overload comma, address, logic and, logic or. when we define an operator as a member function, its left operand must be an object of the operator's class. operator(=), index([]), call(()), member accession(->) operator must be member function of class. ostream(<<), istream(>>) can't be member function. index operator usually define two overloading versions, the const one and the nonconst one. increase and decrease operators usually be set as member functions. strBlobPtr & operator ++ (); //preoperator strBlobPtr operator ++ ( int ); //postoperator strBlobPtr strBlobPtr :: operator ++ ( int ) { strBlobPtr ret = * this ; ++* this ; return ret ; } if we overload the call operator, the object of this class is called function object, because we can call this object. function object is usually used as actual parameter of generic algorithm. moreover, lambda is an unnamed class' unnamed object, whose call operator is overloaded by lambda's function body. liberty functional defines a succession of function class as templates. and they are listed below. arithmetic relation logic plus<Type> equal_to<Type> logical_and<Type> minus<Type> not_equal_to<Type> logical_or<Type> multiplies<Type> greater<Type> logical_not<Type> divides<Type> greater_equal<Type> modulus<Type> less<Type> negate<Type> less_equal<Type> operator type () const is class-type conversions or be named user-define conversions. it allows a type to be an object's return type. this conversion is implicit. we can define explicit conversion operator to control class-type conversion. class SmallInt { public : SmallInt ( int i = 0 ) : val ( i ) {} explicit operator int () const { return val ;} operator = ( int ); private : int val ; }; SmallInt si = 3 ; static_cast < int > ( si ) + 3 ; //explicitly request for type conversion however, if the conversion is used as a condition, the compiler will automatically execute the conversion. function table function, function pointer, function class, lambda expression, classes built by bind and any other classes which has overloaded the call operator are all callable object. function class defined in liberty functional can be used to reserve callable object. #include <functional> function < int ( int , int ) > f1 = add ; //f1(4,2) == 6; //equal to add(4,2); //f1 == true; //f1 has a callable object; function < int ( int , int ) > f2 = []( int a , int b ){ return i * j ;}; we can define a function table to reserve callable objects with same retType(args) . map < string , function < int ( int , int ) >> binops = { { \"+\" , add }, //each element is a pair { \"-\" , minus < int > ()}, { \"/\" , divide ()}, { \"*\" , []( int i , int j ){ return i * j ;}}, { \"%\" , mod }, }; //in this case, binos[\"+\"](4,2) == 6; Object-Oriented Programming inheritance class Quote { public : Quote () = default ; Quote ( const std :: string & book , double sales_price ) : bookNo ( book ), price ( sales_price ) {} std :: string isbn () const { return bookNo ; } //key word virtual defines a virtual function //which means the base class permits drived classes to override it virtual double net_price ( std :: size_t n ) const { return n * price ; } //moreover, if we don't wish our clients use the base class' member function //we need to define this member function to be a pure virtual function as the following code row //notice :the pure virtual function can only be defined in the declaration body virtual double net_price ( std :: size_t n ) const = 0 ; virtual ~ Quote () = default ; //dynamically bind destructor private : std :: string bookNo ; /* *key word protected serves for those members *which are not supposed to be used by object's users *but needed to be used by derived class */ protected : double price = 0.0 ; //common price without discount }; /* *type of class derivation list:colon and a list of base class *whose type is base class behind optional assess specifire *and splited by comma */ class Bulk_quote : public Quote { public : Buli_quote () = default ; Built_quote ( const std :: string & , double , std :: size_t , double ); /* *key word override explicitly declare that this member function *will be used to redefine the base class' virtual function *if not, the compiler will throw error */ double net_price ( std :: size_t ) const override ; private : //the minimum purchase quantity of discount std :: size_t min_qty = 0 ; double discount = 0.0 ; }; because derived class has its base class member, compiler can implicitly convert it into its base class as a reference or pointer. On the contrary, compiler doesn't allow us to implicitly convert base class object into derived class object. However, if we ensure this action's safety, we can use static_cast enforce the conversion. But this action is not recommended. What's more, if the base class has at least one virtual function, we can use dynamic_cast to check this conversion's safety and let the compiler divides whether allow or not. if a base class defines a static member, the whole inheritance system has only one instance no matter how many derived classes and objects have been defined. base class must be defined before defining derived classes. key word final restrict us from using a class as base class. key word final can be used to declare that a virtual function is the final function, which means this function can't be overrode. class NoDerived final { /*details*/ } //illegal, we can't use Noderived as a base class class Bad : public NoDerived { /*details*/ } virtual function can have acquiescent parameters, and its acquiescent parameters depend on the static type of the call. class Base { public : virtual void funcion ( int a = 0 , int b = 1 ){ /*details*/ } } class Derived : public Base { public : void function ( int a = 1 , int b = 2 ) override { /*details*/ } } void execuse_function ( Base & b ){ b . function (); } int main (){ Derived d ; execuse_function ( d ); //execuse Base::function(int a = 0, int b = 1); } scope notions: iff the derived class publicly inherits base class can users use the conversions between derived class and base class. if the derived class publicly or protected inherits base class, the derived class can use the conversions. if the derived class privately inherits base class, the derived class' objects and friends can't use the conversions. friend relationship can't be inherited. each class controls its members' accessible permissions. if we need to change a member's accessible permission, we can use the using declaration in the corresponding action scope class Base { public : std :: size_t size () const { return n ;} protected : std :: size_t n ; } //we inherit the base class in the private scope class Derived : private Base { public : //then Base::size() is public using Base :: size ; protected : using Base :: n ; } acquiescent derived scope operators depend on class' type. struct acquiescently owns public scope while class having private scope. derived class' scope is combined into base class' scope. thus derived class' member with the same name as base class' has higher priority. name lookup precedes type lookup. function declared in the inner scope won't override but cover the outer scope's function.(which remind us to use the override key word. otherwise we must ensure that the derived class's function has the same parameters list as the base class') struct Base { int memfunc (); } struct Derived : Base { //Base's scope operator is public int memfunc ( int ); } Derived d ; Base b ; b . memfunc (); d . memfunc ( 10 ); d . memfunc (); //error:Base::memfunc() is hided. the right way is written below d . Base :: memfunc (); dynamic binding double print_total ( ostream & os , const Quote & item , size_t n ) { //calling Quote::net_price or Bulk_quote::net_price //depends on item's object type //moreover, accessible members which we can use depend on the static type //for instance, this item below has no right to use Bulk_quote's unique public members double ret = item . net_price ( n ); os << \"ISBN: \" << item . isbn () << \"# sold: \" << n << \"total due: \" << ret << endl ; return ret ; } //if we don'y want to use dynamic binding, we need to explicitly declare the scope double ret = item -> Quote :: net_price ( 42 ); now, we need to consider this situation where we delete a derived object pointed by a base class pointer. we must ensure that the delete command executes the derived object's destructor. So we declare the base class' destructor as a virtual function to solve this problem. what's more, virtual destructor will impede generating movement operation. What's more, if we use containers to save objects, it is supposed to indirectly save it. An common usage is using pointer. Then we are able to use base class pointer calling derived objects. template template < typename T > //key word:template //<template T> is template parameter list //template parameters are divided by comma /* *moerover, key word typename is the same with key word class in this situation */ int compare ( const T & v1 , const T & v2 ) { if ( v1 > v2 ) return -1 ; else if ( v2 < v1 ) return 1 ; else return 0 ; } //type parameter can be used as return type or parameter type //it can be used as variables declaration and type translation, as well template < typename T > T foo ( T * p ) { T tmp = * p ; //omitted details return T ; } /* *we can define nontype parameter and the parameter's value is provided by *clients or compiler *in this case, compiler provide nontype parameters int values depends on *const char array's length *nontype parameter can be int, object/function pointer or lvalue reference */ template < unsigned N , unsigned M > int compare ( const char ( & p1 )[ N ], const char ( & p2 )[ M ]){ return strcmp ( p1 , p2 ); } /* *template can be declared as inline or constexpr *this declaration should be put between template parameter list and return type */ template < typename T > inline T min ( const T & , const T & ); principle : template function's parameters are supposed to be const reference, which guarantees non-copyable object's availability. if we want to define a class member function out of the class body, it's type should be: template < typename > return - type class - name :: member - name ( parameter - list ) { function - bod } By default, template class' member function is instantiated when it is called, which help us to use a template class even though there are some member function incompatible with a type, we can use part of class functions. friend declaration //friend declaration template < typename T > class Pal ; class C { friend class Pal < C > ; //Pal instantiated by class C is a friend template < typename T > friend class Pal2 ; //each instantiated Pal2 is C's friend }; template < typename T > class C2 { friend class Pal < T > ; template < typename X > friend class Pal2 ; //each instantiated Pal2 is each instantiated C2's friend //notice: friend's typename should be different from template class' friend class Pal3 ; //Pal3 is a non-template class, every instantiated C2 is Pal3's friend }; //let template's typename as friend template < typename T > class C3 { friend T ; //type T is friend of C3 instantiated by T }; if a template class contains static members, each type instantiated class has its own static members. if we access a type name from a template class, we need to use the key word typename to explicitly ask compiler treats the name as a type name. we can define default template argument, like code below. template < typename T , typename F = less < T >> int compare ( const T & v1 , const T & v2 , F f = F ()){ if ( f ( v1 , v2 )) return -1 ; if ( f ( v2 , v1 )) return 1 ; return 0 ; } //even if all the parameters of a template's typename parameter list is default argued //we have to use angle brackets to ask compiler instantiate a class from a template template < typename T = int > class tmp_array { /*details*/ }; tmp_array <> a ; Besides, it is known that once we define a template class' type, compiler instantiates a class instance. But this activity faces an embarrassing situation. Once we create a project and use template class with the same type in different file, the compiler will instantiates several instances in each file. Which may be a mass overhead. We can use the key word extern to declare a class to prevent from such overhead. extern template class Blob < string > ; //declaration template int compare ( const int & , const int & ); //definition //in this case, compiler will instantiates the whole members //thus the type must apply to every member int main () { Blob < string > sa1 , sa2 ; //compiler instantiates class in other file //Thus key word extern expresses that there is a definition in our project } and if we can't make sure what the return type definitely is, we can use the tail-set return to declare function's return type //using tail-set return to explicitly declare function's return type template < typename It > auto fcn ( It beg , It end ) -> decltype ( * beg ) { //details return * beg ; } reference collapsing: X& &, X& &&, X&& & will collapse to X& X&& && will be collapse to X&& By define a parameter as an rvalue reference, we can save all of argument's type-info. By using reference, we can save the const-info. By define parameters as rvalue references, we can use reference collapsing to save arguments' reference characteristic. template < typename F , typename T1 , typename T2 > void flip ( F f , T1 && t1 , T2 && t2 ) { f ( t1 , t2 ); } However, function expression returns an lvalue, which restrict us from binding an rvalue reference to an rvalue reference. In this case, we need to use the lib function std::forward , which is defined in lib utility , to save the reference type(by using the reference collapsing). Thus, we modifies the original code to the below one template < typename F , typename T1 , typename T2 > void flip ( F f , T1 && t1 , T2 && t2 ) { f ( std :: forward < T1 > ( t1 ), std :: forward < T2 > ( t2 )); } When we overload a template function, compiler will chose the more specialized one. Thus if we define a template function template < typename T > string func ( T & a ) { /*details*/ } template < typename T > string func ( T * a ) { /*details*/ } and we hope the compiler may cope with char & const char as string , we need to define two specialized overloaded function string func ( const string & ); //declare a string type instance to avoid from default call string func ( char * p ) { return func ( string ( p ));} string func ( const char * p ) { return func ( string ( p ));} parameter packet we use symbol ... after keyword typename or class to express indefinite number of parameters //Args is a template parameter packet, rest is a function parameter packet //Args means zero or several template parameters //rest means zero or several function parameters //types in packet can be different from each other template < typename T , typename ... Args > void foo ( const T & t , const Args & ... rest ){ cout << T << \" \\t \" ; print ( cout , rest )...; return ; } we can use sizeof to calculate the number of parameters in the packet call packet parameters : //end the recursion and print the last element template < typename T > ostream & print ( ostream & os , const T & t ) { return os << t ; } //recursion call template < typename T , typename ... Args > ostream & print ( ostream & os , const T & t , const Args & ... rest ) { os << t << \" \\t \" ; return print ( os , rest ...); } int main () { int i = 1 ; double d = 2.0 ; long l = 321 ; string s = \"hello world!\" ; foo ( cout , i , d , l , s ); return 0 ; } //output:1 2 321 hello world! specialize //specialize template < typename T > int compare ( const T & , const T & ); template < size_t N , size_t M > int compare ( const char ( & )[ N ], const char ( & )[ M ]); //const char(&)[M] is a reference to an char array //a specialized instance of function compare template <> int compare ( const char * const & , const char * const & ); //a reference to an const (or not) pointer notice : Once we need a specialized instance but forget to declare or define one, where there is a template suits to this instance's type, the compiler will instantiate an instance. This mistake won't be checked up. Thus we are supposed to define templates with the same name in the same header file. And put the specialized instances after those template. Certainly we need to check up whether we have declared an instance or not.","title":"C++ learning notes"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#c-learning-notes","text":"","title":"C++ learning notes"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#generic-algorithm","text":"","title":"Generic algorithm"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#lambda","text":"[capture list] (parameter list) -> return type {function body} we can ignore the parameter list and return type , but the capture list and the function body must be reserved eg: []( const string & a , const string & b ) { return a . size () < b . size ();}","title":"lambda"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#dynamic-memory","text":"","title":"dynamic memory"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#shared_ptr","text":"use function make_shared<>()","title":"shared_ptr &lt;&gt;"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#unique_ptr","text":"must be initialized once the pointer is created","title":"unique_ptr &lt;&gt;"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#weak_ptr","text":"can be assigned","title":"weak_ptr &lt;&gt;"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#allocator","text":"allocator < string > alloc ; auto const p = alloc . allocate ( n ); weak_ptr < string [] > q = p ; for ( int i = 0 ; i != n ; ++ i ){ alloc . construct ( q ++ , \"hello world!\" ); } for ( int i = 0 ; i != n ; ++ i ) { cout << * ( p + i ) << endl ; } alloc . deallocate ( p , n ); delete p ; //provided p points to an object or be nullptr delete [] p ; //provided p points to an array or be nullptr","title":"allocator"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#copy-assign-and-destroy","text":"","title":"Copy, Assign and Destroy"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#specific-member-function-to-control-above-three-operations","text":"copy constructor copy-assignment operator move constructor move-assignment operator destructor","title":"specific member function to control above three operations"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#copy-constructor","text":"class Foo { public : /* *default defination in class body is inline *if we don't hope so, we need to define \"= default\" out of the class body *generally, function defined in class body is inline */ Foo () = default ; //default constructor Foo ( const Foo & ); //copy constructor //first parameter must be a reference, and almost always be a const reference } class Foo2 { public : //explicit prevents implicit conversion explicit Foo2 () = default ; explicit Foo2 ( int num ) : n ( num ) {} private : int n ; };","title":"copy constructor"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#copy-assignment-constructor","text":"class Foo { public : /* *we define a copy-assignment constructor below *keyword operator+symbol is an overloaded operator *which defines an operator(like =,+,- and so on) */ Foo & operator = ( const Foo & f ){ this -> n = f -> n ; return * this ; } private : int n ; } int main (){ Foo f1 , f2 (); //f2 is default initialized f1 = f2 ; //equals to f1(f2) };","title":"copy-assignment constructor"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#stop-the-copy","text":"if we don't want a copy operation, we need to define it as the delete function class NoCopy { public : NoCopy () = default ; /* *\"= delete\" must be present when we firstly declare it. * *by the way, we can delete any functions(except the destructor), *thongh i haven't clearly understood its effect and affect. *one interesting and meaningful example is, if a class's member *can't be implicitly initialized, copied, assigned or destroied, *its implicit initializer's member function is deleted. *It prevents from creating indestructible object. * *principle: destructor can't be delete */ NoCopy ( const NoCopy & ) = delete ; //stop the copy NoCopy & operator = ( const NoCopy & ) = delete ; //stop the copy-assignment ~ NoCopy () = default ; /* *we can put the copy constructor into private zone to prevent from copying it. *we need to declare it in the private zone first *then define it in the public zone.(in order to prevent friend use it) *however, this practice is not recommended. */ }","title":"stop the copy"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#destructor","text":"destructor delete the resource used by objects, and destruct non-static elements it is used whenever the object is destroyed implicitly destruct a pointer won't delete the object it points. on the contrary, smart pointer is class type with destructor, thus it can delete the object class Foo { public : ~ Foo () = default ; //destructor.this function can't be overloaded };","title":"destructor"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#principle","text":"define destructor before assuring weather it needs a destructor or not if a class needs a copy constructor, it always need a copy-assignment constructor. And vice verse","title":"principle"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#copy-control-and-resource-management","text":"behave like a value: the copy and the original object is fully independent behave like a pointer: the copy and the original object point to the same underlying data","title":"copy control and resource management"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#classes-which-behave-like-a-value","text":"class HasPtr { public : HasPtr ( const std :: string & s = std :: string ()) : ps ( new std :: string ( s )), i ( 0 ) {} //every HasPtr's copy has its own string member with equal value HasPtr ( const HasPtr & p ) : ps ( new std :: string ( * ( p . ps ))), i ( p . i ) {} /* *most copy assignment constructor combines the function *of destructor and copy constructor. * *for instance, copy assignment constructor *destroys the left side object's resource as destructor, *and copies data from the right side object *to the left one like copy constructor * *if possible, copy assignment constructor should be exception safe. *which means when an exception occurs, *it can put the left side object in a meaningful state */ HasPtr & operator = ( const HasPtr & ); ~ HasPtr () { delete ps ; } private : std :: string * ps ; int i ; }; /* *in this case, to ensure exception safety, *we copy the right object's data first *to ensure exception safety before assignment. *then we delete the resource of the left object and execute assignment */ HasPtr & HasPtr :: operator = ( const HasPtr & rhs ) { auto newp = new std :: string ( * rhs . ps ); delete ps ; ps = newp ; i = rhs . i ; return * this ; }","title":"classes which behave like a value"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#classes-which-behave-like-a-pointer","text":"use reference count to control the underlying data class HasPtr { public : HasPtr ( const std :: string & s = std :: string ()) : ps ( new std :: string ( s )), i ( 0 ), use ( new std :: size_t ( 1 )) {} //copy the pointer to ensure they point to the same underlying data //increase the reference count HasPtr ( const HasPtr & p ) : ps ( p . ps ), i ( p . i ), use ( p . use ) { ++* use ; } HasPtr & operator = ( const HasPtr & ); ~ HasPtr (); private : std :: string * ps ; int i ; std :: size_t * use ; //reference count }; HasPtr ::~ HasPtr () { if ( --* use == 0 ) { delete ps ; delete use ; } } HasPtr & HasPtr :: operator = ( const HasPtr & rhs ) { ++* rhs . use ; //execute the left object's destructor if ( --* use == 0 ) { delete ps ; delete use ; } //execute assignment ps = rhs . ps ; i = rhs . i ; use = rhs . use ; return * this ; }","title":"classes which behave like a pointer"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#swap","text":"we can swap the pointer to decrease extra memory allocation class HasPtr { friend void swap ( HasPtr & , HasPtr & ); } /* *if a menber of a class has its own swap function, *use the std::swap is an error *and if we implicitly use swap function, the compiler use the overloaded one by default */ inline void swap ( HasPtr & lhs , HasPtr & rhs ){ using std :: swap ; swap ( lhs . ps , rhs . ps ); swap ( lhs . i , rhs . i ); } int main (){ HasPtr h1 (), h2 (); using std :: swap ; swap ( h1 , h2 ); //use the overloaded one } //tip:this function can't overload the HasPtr &HasPtr::operator=(HasPtr &rhs) HasPtr & HasPtr :: operator = ( HasPtr rhs ){ //parameter is a copy, not a reference swap ( * this , rhs ); return * this ; //rhs is destroyed };","title":"swap"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#move-constructor","text":"library container, string and shared_ptr class support both move and copy operation IO class and unique_ptr class can be moved, but can't be copied rvalue reference must be bound to an rvalue. we get rvalue reference through && instead of & rvalue reference must be bound to an object ready to be destroyed therefore, we can freely move an rvalue reference resource to another object moreover, we can bound a const lvalue reference to an rvalue, as well expression returns an rvalue. But rvalue reference variate itself is a lvalue eg: int i = 42 ; int & r = i ; const int & r2 = i * 42 ; int && r3 = i * 42 ; int && r4 = r3 ; //illegal all of them is legal except the last one std::move avails to use a lvalue as an rvalue. What's more, we must recognize that executing move means we promote not to use the original element unless we assign or destruct it. int && r4 = std :: move ( r3 ); //legal //use std::move instead of move in order to prevent from potential naming conflict an example of move constructor StrVec :: StrVec ( StrVec && s ) noexcept //move operation shouldn't throw error //initializer take over resource of s : elements ( s . elements ), first_feet ( s . first_feet ), cap ( s . cap ) { s . elements = s . first_feet = s . cap = nullptr ; //brilliant! //get the spark of controlling dynamic memory! //now destructing s is safe //i wander weather we permit s to be meaningfully assigned, //and after insperation, i find that void StrVec::push_back(const std::string &) //has considered this situation. Now both assignment and destruction is ligal. //and at the same time we can't read its value //(certainly i put the whole code into my cpp file to avoid making my notes bloated) }","title":"move constructor"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#move-assignment-constructor","text":"StrVec & StrVec :: operator = ( StrVec && rhs ) noexcept { //check self-assignment //I guess this operation is designed to avoid freeing itself //otherwise it may move meaningless data and put itself in a meaningless state if ( this != & rhs ) { free (); //release itself elements = rhs . elements ; first_feet = rhs . first_feet ; cap = rhs . cap ; //put rhs in a destructible state rhs . elements = rhs . first_feet = rhs . cap = nullptr ; } return * this ; } //copy and move operation's overload StrVec v1 , v2 ; v1 = v2 ; //copy assignment constructor StrVec getVec ( istream & ); //getVec returns an rvalue //because getVec() dosen't return value instead of reference //up to now getVec() is just a declaration v2 = getVec ( cin ); //move assignment constructor /* *if we didn't define a move constructor *the compiler will convert an rvalue reference to a const reference *and call copy constructor */","title":"move assignment constructor"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#reference-qualifier","text":"C++ permit us to assign value to a rvalue object(so weird) eg: string s1 ( \"a\" ), s2 ( 3 , 'b' ); //s1 = \"a\", s2 = \"bbb\"; /* *(s1 + s2) is an rvalue which never affects s1 and s2's value without assignment *usually it is created by compiler and released soon *the following expression execute: * create a string temp_s = s1 + s2 = \"abbb\"; * assign \"Wow\" to temp_s and return \"Wow\"; * assign \"Wow\" to s3; * release temp_s *Just from my own guess.If there's something wrong, I'll correct it */ string s3 = ( s1 + s2 ) = \"Wow\" ; cout << s3 << endl ; return 0 ; we can use the reference qualifier to enforce the left object is an lvalue or an rvalue class Foo { public : //the & in the back of parameter list enforce the left object is an lvalue Foo & operator = ( const Foo & ) & ; // }; Foo & Foo :: operator = ( const Foo & rhs ) & { // return * this ; } class Foo { public : Foo someMember () const & ; //const should be in front of reference qualifier } reference qualifier and overloaded class Foo { public : Foo sorted () && ; Foo sorted () const & ; private : vector < int > data ; }; //because object is an rvalue, we can change itself without any affection Foo Foo::sorted () && { sort ( data . begin (), data . end ()); return * this ; } //object is an lvalue, thus we can't affect its value Foo Foo::sorted () const & { Foo temp ( * this ); sort ( temp . data . begin (), temp . data . end ()); return temp ; }","title":"reference qualifier"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#overloading-and-type-conversion","text":"","title":"overloading and type conversion"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#basic-concept","text":"an operator function should be a member of a class or have at least than one class type parameter which means we can't overload operators acting on the build-in type overloaded operator's priority and associative law is the same as the original operator operators can be overloaded + - * / % ^ & ~ ! , = < > <= >= ++ -- << >> == != && += -= /= %= ^= &= = *= <<= >>= [] () -> ->* new new[] delete delete[] operators can not be overloaded :: .* . ? :","title":"basic concept"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#operators","text":"there are various of operators overloading practice. and you know, cujus rei demonstrationem mirabilem sane detexi. Hanc marginis exiguitas non caperet .(I'm sure I've discovered a wonderful demonstration, but the space here is too small to fill it). so I write them all down in my practice .cpp file and just note some announcements there. The essence of operator overloading is a function call. therefore we can't save the original order of evaluation and the short circuit evaluation. and that's why we don't advice you to overload comma, address, logic and, logic or. when we define an operator as a member function, its left operand must be an object of the operator's class. operator(=), index([]), call(()), member accession(->) operator must be member function of class. ostream(<<), istream(>>) can't be member function. index operator usually define two overloading versions, the const one and the nonconst one. increase and decrease operators usually be set as member functions. strBlobPtr & operator ++ (); //preoperator strBlobPtr operator ++ ( int ); //postoperator strBlobPtr strBlobPtr :: operator ++ ( int ) { strBlobPtr ret = * this ; ++* this ; return ret ; } if we overload the call operator, the object of this class is called function object, because we can call this object. function object is usually used as actual parameter of generic algorithm. moreover, lambda is an unnamed class' unnamed object, whose call operator is overloaded by lambda's function body. liberty functional defines a succession of function class as templates. and they are listed below. arithmetic relation logic plus<Type> equal_to<Type> logical_and<Type> minus<Type> not_equal_to<Type> logical_or<Type> multiplies<Type> greater<Type> logical_not<Type> divides<Type> greater_equal<Type> modulus<Type> less<Type> negate<Type> less_equal<Type> operator type () const is class-type conversions or be named user-define conversions. it allows a type to be an object's return type. this conversion is implicit. we can define explicit conversion operator to control class-type conversion. class SmallInt { public : SmallInt ( int i = 0 ) : val ( i ) {} explicit operator int () const { return val ;} operator = ( int ); private : int val ; }; SmallInt si = 3 ; static_cast < int > ( si ) + 3 ; //explicitly request for type conversion however, if the conversion is used as a condition, the compiler will automatically execute the conversion.","title":"operators"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#function-table","text":"function, function pointer, function class, lambda expression, classes built by bind and any other classes which has overloaded the call operator are all callable object. function class defined in liberty functional can be used to reserve callable object. #include <functional> function < int ( int , int ) > f1 = add ; //f1(4,2) == 6; //equal to add(4,2); //f1 == true; //f1 has a callable object; function < int ( int , int ) > f2 = []( int a , int b ){ return i * j ;}; we can define a function table to reserve callable objects with same retType(args) . map < string , function < int ( int , int ) >> binops = { { \"+\" , add }, //each element is a pair { \"-\" , minus < int > ()}, { \"/\" , divide ()}, { \"*\" , []( int i , int j ){ return i * j ;}}, { \"%\" , mod }, }; //in this case, binos[\"+\"](4,2) == 6;","title":"function table"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#object-oriented-programming","text":"","title":"Object-Oriented Programming"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#inheritance","text":"class Quote { public : Quote () = default ; Quote ( const std :: string & book , double sales_price ) : bookNo ( book ), price ( sales_price ) {} std :: string isbn () const { return bookNo ; } //key word virtual defines a virtual function //which means the base class permits drived classes to override it virtual double net_price ( std :: size_t n ) const { return n * price ; } //moreover, if we don't wish our clients use the base class' member function //we need to define this member function to be a pure virtual function as the following code row //notice :the pure virtual function can only be defined in the declaration body virtual double net_price ( std :: size_t n ) const = 0 ; virtual ~ Quote () = default ; //dynamically bind destructor private : std :: string bookNo ; /* *key word protected serves for those members *which are not supposed to be used by object's users *but needed to be used by derived class */ protected : double price = 0.0 ; //common price without discount }; /* *type of class derivation list:colon and a list of base class *whose type is base class behind optional assess specifire *and splited by comma */ class Bulk_quote : public Quote { public : Buli_quote () = default ; Built_quote ( const std :: string & , double , std :: size_t , double ); /* *key word override explicitly declare that this member function *will be used to redefine the base class' virtual function *if not, the compiler will throw error */ double net_price ( std :: size_t ) const override ; private : //the minimum purchase quantity of discount std :: size_t min_qty = 0 ; double discount = 0.0 ; }; because derived class has its base class member, compiler can implicitly convert it into its base class as a reference or pointer. On the contrary, compiler doesn't allow us to implicitly convert base class object into derived class object. However, if we ensure this action's safety, we can use static_cast enforce the conversion. But this action is not recommended. What's more, if the base class has at least one virtual function, we can use dynamic_cast to check this conversion's safety and let the compiler divides whether allow or not. if a base class defines a static member, the whole inheritance system has only one instance no matter how many derived classes and objects have been defined. base class must be defined before defining derived classes. key word final restrict us from using a class as base class. key word final can be used to declare that a virtual function is the final function, which means this function can't be overrode. class NoDerived final { /*details*/ } //illegal, we can't use Noderived as a base class class Bad : public NoDerived { /*details*/ } virtual function can have acquiescent parameters, and its acquiescent parameters depend on the static type of the call. class Base { public : virtual void funcion ( int a = 0 , int b = 1 ){ /*details*/ } } class Derived : public Base { public : void function ( int a = 1 , int b = 2 ) override { /*details*/ } } void execuse_function ( Base & b ){ b . function (); } int main (){ Derived d ; execuse_function ( d ); //execuse Base::function(int a = 0, int b = 1); }","title":"inheritance"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#scope","text":"notions: iff the derived class publicly inherits base class can users use the conversions between derived class and base class. if the derived class publicly or protected inherits base class, the derived class can use the conversions. if the derived class privately inherits base class, the derived class' objects and friends can't use the conversions. friend relationship can't be inherited. each class controls its members' accessible permissions. if we need to change a member's accessible permission, we can use the using declaration in the corresponding action scope class Base { public : std :: size_t size () const { return n ;} protected : std :: size_t n ; } //we inherit the base class in the private scope class Derived : private Base { public : //then Base::size() is public using Base :: size ; protected : using Base :: n ; } acquiescent derived scope operators depend on class' type. struct acquiescently owns public scope while class having private scope. derived class' scope is combined into base class' scope. thus derived class' member with the same name as base class' has higher priority. name lookup precedes type lookup. function declared in the inner scope won't override but cover the outer scope's function.(which remind us to use the override key word. otherwise we must ensure that the derived class's function has the same parameters list as the base class') struct Base { int memfunc (); } struct Derived : Base { //Base's scope operator is public int memfunc ( int ); } Derived d ; Base b ; b . memfunc (); d . memfunc ( 10 ); d . memfunc (); //error:Base::memfunc() is hided. the right way is written below d . Base :: memfunc ();","title":"scope"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#dynamic-binding","text":"double print_total ( ostream & os , const Quote & item , size_t n ) { //calling Quote::net_price or Bulk_quote::net_price //depends on item's object type //moreover, accessible members which we can use depend on the static type //for instance, this item below has no right to use Bulk_quote's unique public members double ret = item . net_price ( n ); os << \"ISBN: \" << item . isbn () << \"# sold: \" << n << \"total due: \" << ret << endl ; return ret ; } //if we don'y want to use dynamic binding, we need to explicitly declare the scope double ret = item -> Quote :: net_price ( 42 ); now, we need to consider this situation where we delete a derived object pointed by a base class pointer. we must ensure that the delete command executes the derived object's destructor. So we declare the base class' destructor as a virtual function to solve this problem. what's more, virtual destructor will impede generating movement operation. What's more, if we use containers to save objects, it is supposed to indirectly save it. An common usage is using pointer. Then we are able to use base class pointer calling derived objects.","title":"dynamic binding"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#template","text":"template < typename T > //key word:template //<template T> is template parameter list //template parameters are divided by comma /* *moerover, key word typename is the same with key word class in this situation */ int compare ( const T & v1 , const T & v2 ) { if ( v1 > v2 ) return -1 ; else if ( v2 < v1 ) return 1 ; else return 0 ; } //type parameter can be used as return type or parameter type //it can be used as variables declaration and type translation, as well template < typename T > T foo ( T * p ) { T tmp = * p ; //omitted details return T ; } /* *we can define nontype parameter and the parameter's value is provided by *clients or compiler *in this case, compiler provide nontype parameters int values depends on *const char array's length *nontype parameter can be int, object/function pointer or lvalue reference */ template < unsigned N , unsigned M > int compare ( const char ( & p1 )[ N ], const char ( & p2 )[ M ]){ return strcmp ( p1 , p2 ); } /* *template can be declared as inline or constexpr *this declaration should be put between template parameter list and return type */ template < typename T > inline T min ( const T & , const T & ); principle : template function's parameters are supposed to be const reference, which guarantees non-copyable object's availability. if we want to define a class member function out of the class body, it's type should be: template < typename > return - type class - name :: member - name ( parameter - list ) { function - bod } By default, template class' member function is instantiated when it is called, which help us to use a template class even though there are some member function incompatible with a type, we can use part of class functions.","title":"template"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#friend-declaration","text":"//friend declaration template < typename T > class Pal ; class C { friend class Pal < C > ; //Pal instantiated by class C is a friend template < typename T > friend class Pal2 ; //each instantiated Pal2 is C's friend }; template < typename T > class C2 { friend class Pal < T > ; template < typename X > friend class Pal2 ; //each instantiated Pal2 is each instantiated C2's friend //notice: friend's typename should be different from template class' friend class Pal3 ; //Pal3 is a non-template class, every instantiated C2 is Pal3's friend }; //let template's typename as friend template < typename T > class C3 { friend T ; //type T is friend of C3 instantiated by T }; if a template class contains static members, each type instantiated class has its own static members. if we access a type name from a template class, we need to use the key word typename to explicitly ask compiler treats the name as a type name. we can define default template argument, like code below. template < typename T , typename F = less < T >> int compare ( const T & v1 , const T & v2 , F f = F ()){ if ( f ( v1 , v2 )) return -1 ; if ( f ( v2 , v1 )) return 1 ; return 0 ; } //even if all the parameters of a template's typename parameter list is default argued //we have to use angle brackets to ask compiler instantiate a class from a template template < typename T = int > class tmp_array { /*details*/ }; tmp_array <> a ; Besides, it is known that once we define a template class' type, compiler instantiates a class instance. But this activity faces an embarrassing situation. Once we create a project and use template class with the same type in different file, the compiler will instantiates several instances in each file. Which may be a mass overhead. We can use the key word extern to declare a class to prevent from such overhead. extern template class Blob < string > ; //declaration template int compare ( const int & , const int & ); //definition //in this case, compiler will instantiates the whole members //thus the type must apply to every member int main () { Blob < string > sa1 , sa2 ; //compiler instantiates class in other file //Thus key word extern expresses that there is a definition in our project } and if we can't make sure what the return type definitely is, we can use the tail-set return to declare function's return type //using tail-set return to explicitly declare function's return type template < typename It > auto fcn ( It beg , It end ) -> decltype ( * beg ) { //details return * beg ; }","title":"friend declaration"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#reference-collapsing","text":"X& &, X& &&, X&& & will collapse to X& X&& && will be collapse to X&& By define a parameter as an rvalue reference, we can save all of argument's type-info. By using reference, we can save the const-info. By define parameters as rvalue references, we can use reference collapsing to save arguments' reference characteristic. template < typename F , typename T1 , typename T2 > void flip ( F f , T1 && t1 , T2 && t2 ) { f ( t1 , t2 ); } However, function expression returns an lvalue, which restrict us from binding an rvalue reference to an rvalue reference. In this case, we need to use the lib function std::forward , which is defined in lib utility , to save the reference type(by using the reference collapsing). Thus, we modifies the original code to the below one template < typename F , typename T1 , typename T2 > void flip ( F f , T1 && t1 , T2 && t2 ) { f ( std :: forward < T1 > ( t1 ), std :: forward < T2 > ( t2 )); } When we overload a template function, compiler will chose the more specialized one. Thus if we define a template function template < typename T > string func ( T & a ) { /*details*/ } template < typename T > string func ( T * a ) { /*details*/ } and we hope the compiler may cope with char & const char as string , we need to define two specialized overloaded function string func ( const string & ); //declare a string type instance to avoid from default call string func ( char * p ) { return func ( string ( p ));} string func ( const char * p ) { return func ( string ( p ));}","title":"reference collapsing:"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#parameter-packet","text":"we use symbol ... after keyword typename or class to express indefinite number of parameters //Args is a template parameter packet, rest is a function parameter packet //Args means zero or several template parameters //rest means zero or several function parameters //types in packet can be different from each other template < typename T , typename ... Args > void foo ( const T & t , const Args & ... rest ){ cout << T << \" \\t \" ; print ( cout , rest )...; return ; } we can use sizeof to calculate the number of parameters in the packet call packet parameters : //end the recursion and print the last element template < typename T > ostream & print ( ostream & os , const T & t ) { return os << t ; } //recursion call template < typename T , typename ... Args > ostream & print ( ostream & os , const T & t , const Args & ... rest ) { os << t << \" \\t \" ; return print ( os , rest ...); } int main () { int i = 1 ; double d = 2.0 ; long l = 321 ; string s = \"hello world!\" ; foo ( cout , i , d , l , s ); return 0 ; } //output:1 2 321 hello world!","title":"parameter packet"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B_learning_notes/#specialize","text":"//specialize template < typename T > int compare ( const T & , const T & ); template < size_t N , size_t M > int compare ( const char ( & )[ N ], const char ( & )[ M ]); //const char(&)[M] is a reference to an char array //a specialized instance of function compare template <> int compare ( const char * const & , const char * const & ); //a reference to an const (or not) pointer notice : Once we need a specialized instance but forget to declare or define one, where there is a template suits to this instance's type, the compiler will instantiate an instance. This mistake won't be checked up. Thus we are supposed to define templates with the same name in the same header file. And put the specialized instances after those template. Certainly we need to check up whether we have declared an instance or not.","title":"specialize"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%28Template%20Meta-Programming%29/","tags":["C++"],"text":"Why Care About Meta-Programming Each STL employs more metaprogramming techniques Some requirements are impossible without advanced techniques(e.g. std::optional ) Many third libraries, besides Boost. All C++ programmer should understand the basics Any library developer should understand a good bit more C++ 20 concept and independent requires expressions Metafunctions Traditional Functions Traditional functions have zero+ parameters and return a value(or void ) Mechanism for returning a value from a function is return Compiler can enforce return values and syntax Metadunctions A metafunction is not a function but a class/struct Metafunction are not part of the language and have no formal language support They exist as an idiomatic use of existing language features Their use is dictated by convention C++ community has created common \"standard\" conventions Technically, a class with zero+ template parameters and zero+ return types and values Convention is that a metafunction should return one thing, like a regular function Convention was developed over times, so plenty of existing examples that do not follow this convention More modern metafunction do follow this convention Return From a MetaFunction If you want to return a value, you should expose a public value always called \"value\" template < typename T > struct AnswerOfSpace { static constexpr int value = 42 ; } If you want to have a type-based function, we should expose a public type cnameed \"type\" template < typename T > struct Echo { using type = T ; } They return by exposing public member. Like the follow instance. // Traditional function int int_identity ( int x ){ return x ; } assert ( 42 == int_identity ( 42 )); // metafunction template < int x > struct IntIdentity { public : static constexpr int value = x ; }; assert ( 42 == IntIdentity < 42 >:: value ); Thus, we called metafunction through the below way template < auto x , auto y > struct Sum { static constexpr auto value = x + y ; } auto value = Sum < 15 , 26 >:: value ; Sometimes we can conveniently call metafunction as below way template < auto x , auto y > inline constexpr auto Sum_v = Sum < x , y >:: value ; This way is more easier to use, and has litter requirements on class' public exposure member name. However, each one of this calling method must be explicitly hand written. Traits Standard C++ 17 Standard Unary Type Trait Class template One(two for Binary Type Traits) template type argument*. \"*\" means you can add template parameters to help to define the described class Cpp 17 Default Constructible Cpp 17 Copy Constructible Public and unambiguously derived from a specialization of std::integral_constant The member names of the base characteristic shall not be hidden and shall be unambiguously available template < class T , T v > struct integral_constant { static constexpr T value = v ; using value_type = T ; using type = integral_constant < T , v > ; constexpr operator value_type () const noexcept { return value ; } constexpr value_type operator ()() const noexcept { return value ; } } C++ 17 Transformation Trait Class template One template type argument* Define a publicly accessible nested type named type No default/copy constructible requirement No inheritance requirement Undefined Behavior Do not specialize standard type traits Be very careful when using incomplete types Instant Unary/Binary Type Trait namespace std { using true_type = integral_constant < bool , true > ; using false_type = integral_constant < bool , false > ; } template < typename T > struct is_void : std :: false_type {} template <> struct is_void < void >: std :: true_type {} For any given type T, the result of applying one of these templates to T and to const / volatile T shall yield the same result. Transformation Trait This remove_const function shall remove the top-level const-qualifier. remove_const < int const > -> int remove_const < int const *> -> int const * remove_const < int * const > -> int * remove_const < int const * const > -> int const * template < typename T > struct TypeIdentity { using type = T ; }; // Primary template, do nothing if no const template < typename T > struct remove_const : TypeIdentity < T > {}; // Partial specialization, when detect const template < typename T > struct remove_const < T const > : TypeIdentity < T > {}; // Standard mandated convenience alias using remove_const_t = typename remove_const < T >:: type ;","title":"C++\u6a21\u677f\u5143\u7f16\u7a0b(Template Meta-Programming)"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%28Template%20Meta-Programming%29/#why-care-about-meta-programming","text":"Each STL employs more metaprogramming techniques Some requirements are impossible without advanced techniques(e.g. std::optional ) Many third libraries, besides Boost. All C++ programmer should understand the basics Any library developer should understand a good bit more C++ 20 concept and independent requires expressions","title":"Why Care About Meta-Programming"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%28Template%20Meta-Programming%29/#metafunctions","text":"","title":"Metafunctions"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%28Template%20Meta-Programming%29/#traditional-functions","text":"Traditional functions have zero+ parameters and return a value(or void ) Mechanism for returning a value from a function is return Compiler can enforce return values and syntax","title":"Traditional Functions"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%28Template%20Meta-Programming%29/#metadunctions","text":"A metafunction is not a function but a class/struct Metafunction are not part of the language and have no formal language support They exist as an idiomatic use of existing language features Their use is dictated by convention C++ community has created common \"standard\" conventions Technically, a class with zero+ template parameters and zero+ return types and values Convention is that a metafunction should return one thing, like a regular function Convention was developed over times, so plenty of existing examples that do not follow this convention More modern metafunction do follow this convention","title":"Metadunctions"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%28Template%20Meta-Programming%29/#return-from-a-metafunction","text":"If you want to return a value, you should expose a public value always called \"value\" template < typename T > struct AnswerOfSpace { static constexpr int value = 42 ; } If you want to have a type-based function, we should expose a public type cnameed \"type\" template < typename T > struct Echo { using type = T ; } They return by exposing public member. Like the follow instance. // Traditional function int int_identity ( int x ){ return x ; } assert ( 42 == int_identity ( 42 )); // metafunction template < int x > struct IntIdentity { public : static constexpr int value = x ; }; assert ( 42 == IntIdentity < 42 >:: value ); Thus, we called metafunction through the below way template < auto x , auto y > struct Sum { static constexpr auto value = x + y ; } auto value = Sum < 15 , 26 >:: value ; Sometimes we can conveniently call metafunction as below way template < auto x , auto y > inline constexpr auto Sum_v = Sum < x , y >:: value ; This way is more easier to use, and has litter requirements on class' public exposure member name. However, each one of this calling method must be explicitly hand written.","title":"Return From a MetaFunction"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%28Template%20Meta-Programming%29/#traits-standard","text":"","title":"Traits Standard"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%28Template%20Meta-Programming%29/#c-17-standard-unary-type-trait","text":"Class template One(two for Binary Type Traits) template type argument*. \"*\" means you can add template parameters to help to define the described class Cpp 17 Default Constructible Cpp 17 Copy Constructible Public and unambiguously derived from a specialization of std::integral_constant The member names of the base characteristic shall not be hidden and shall be unambiguously available template < class T , T v > struct integral_constant { static constexpr T value = v ; using value_type = T ; using type = integral_constant < T , v > ; constexpr operator value_type () const noexcept { return value ; } constexpr value_type operator ()() const noexcept { return value ; } }","title":"C++ 17 Standard Unary Type Trait"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%28Template%20Meta-Programming%29/#c-17-transformation-trait","text":"Class template One template type argument* Define a publicly accessible nested type named type No default/copy constructible requirement No inheritance requirement","title":"C++ 17 Transformation Trait"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%28Template%20Meta-Programming%29/#undefined-behavior","text":"Do not specialize standard type traits Be very careful when using incomplete types","title":"Undefined Behavior"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%28Template%20Meta-Programming%29/#instant","text":"","title":"Instant"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%28Template%20Meta-Programming%29/#unarybinary-type-trait","text":"namespace std { using true_type = integral_constant < bool , true > ; using false_type = integral_constant < bool , false > ; } template < typename T > struct is_void : std :: false_type {} template <> struct is_void < void >: std :: true_type {} For any given type T, the result of applying one of these templates to T and to const / volatile T shall yield the same result.","title":"Unary/Binary Type Trait"},{"location":"Programming%20Language/C%2B%2B/C%2B%2B%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%28Template%20Meta-Programming%29/#transformation-trait","text":"This remove_const function shall remove the top-level const-qualifier. remove_const < int const > -> int remove_const < int const *> -> int const * remove_const < int * const > -> int * remove_const < int const * const > -> int const * template < typename T > struct TypeIdentity { using type = T ; }; // Primary template, do nothing if no const template < typename T > struct remove_const : TypeIdentity < T > {}; // Partial specialization, when detect const template < typename T > struct remove_const < T const > : TypeIdentity < T > {}; // Standard mandated convenience alias using remove_const_t = typename remove_const < T >:: type ;","title":"Transformation Trait"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/","tags":["Notes","C++"],"text":"\u6761\u6b3e01\uff1a\u89c6C++\u4e3a\u4e00\u4e2a\u8bed\u8a00\u8054\u90a6 C++\u662f\u4e2a\u591a\u91cd\u6cdb\u578b\u7f16\u7a0b\u8bed\u8a00(multi-paradigm programming language)\uff1a \u8fc7\u7a0b\u5f62\u5f0f(procedural) \u9762\u5411\u5bf9\u8c61\u5f62\u5f0f(object-oriented) \u51fd\u6570\u5f62\u5f0f(functional) \u6cdb\u578b\u5f62\u5f0f(generic) \u5143\u7f16\u7a0b\u5f62\u5f0f(meta-programming) C++\u7684\u6b21\u8bed\u8a00(sub-language)\uff1a C\uff1a \u533a\u5757(blocks)\u3001\u8bed\u53e5(statements)\u3001\u9884\u5904\u7406\u5668(preprocessor)\u3001\u5185\u7f6e\u6570\u636e\u7c7b\u578b(built-in data type)\u3001\u6570\u7ec4(arrays)\u3001\u6307\u9488(pointers)\u3002 \u5c40\u9650\uff1a\u7f3a\u4e4f\u6a21\u677f(templates)\u3001\u5f02\u5e38(exceptions)\u3001\u91cd\u8f7d(overloading)\u2026\u2026 Object-Oriented C++\uff1a classes\u3001\u5c01\u88c5(encapsulation)\u3001\u7ee7\u627f(inheritance)\u3001\u591a\u6001(polymorphism)\u3001virtual\u51fd\u6570(\u52a8\u6001\u7ed1\u5b9a)\u2026\u2026 Template C++\uff1a \u6cdb\u578b\u7f16\u7a0b(generic programming)\u90e8\u5206\u3002 \u65b0\u7684\u7f16\u7a0b\u8303\u5f0f(programming paradigm)\uff1atemplate meta-programming(TMP\uff0c\u6a21\u677f\u5143\u7f16\u7a0b)\u3002 STL\uff1a \u5bb9\u5668(containers)\u3001\u8fed\u4ee3\u5668(iterators)\u3001\u7b97\u6cd5(algorithms)\u3001\u51fd\u6570\u5bf9\u8c61(function objects) C++\u7684\u9ad8\u6548\u7f16\u7a0b\u53d6\u51b3\u4e8e\u6240\u4f7f\u7528\u7684\u8303\u5f0f\u3002 \u6761\u6b3e02\uff1a\u5c3d\u91cf\u4ee5const\uff0cenum\uff0cinline\u66ff\u6362#define \u5c3d\u91cf\u4ee5\u7f16\u8bd1\u5668\u66ff\u6362\u9884\u5904\u7406\u5668\u3002 \u7528\u5e38\u91cf\u66ff\u6362\u5b8f\u3002\u9632\u6b62\u8be5\u540d\u79f0\u672a\u8bb0\u5165\u8bb0\u53f7\u8868(symbol table)\u5185\u3002 \u7279\u6b8a\u60c5\u51b5\uff1a \u5b9a\u4e49\u5e38\u91cf\u6307\u9488(constant pointers)\uff1a\u7531\u4e8e\u5e38\u91cf\u5b9a\u4e49\u901a\u5e38\u88ab\u653e\u5728\u5934\u6587\u4ef6\u5185\uff0c\u56e0\u6b64\u6709\u5fc5\u8981\u5c06\u6307\u9488\uff08\u672c\u8eab\uff09\u58f0\u660e\u4e3a const \uff0c\u5373\u9876\u5c42const\u3002 class\u7684\u4e13\u5c5e\u5e38\u91cf\uff1a\u4e3a\u4e86\u7ea6\u675f\u5176\u4f5c\u7528\u57df(scope)\uff0c\u5fc5\u987b\u5c06\u5176\u4f5c\u4e3a\u4e00\u4e2a\u7c7b\u6210\u5458 (member)\u3002\u4e3a\u4e86\u4fdd\u8bc1\u6539\u53d8\u91cf\u81f3\u591a\u53ea\u6709\u4e00\u4efd\u5b9e\u4f53\uff0c\u5fc5\u987b\u5c06\u5176\u5b9a\u4e49\u4e3a static \u6210\u5458\u3002 enum: \u7c7b\u4f3c #define \uff0c\u5bf9\u5176\u53d6\u5730\u5740\u662f\u975e\u6cd5\u7684 \u7f16\u8bd1\u5668\u4e0d\u4f1a\u4e3a\u5b83\u5206\u914d\u989d\u5916\u50a8\u5b58\u7a7a\u95f4 \u662ftemplate meta-programming \u7684\u57fa\u7840\u6280\u672f \u7528template inline function\u6765\u83b7\u53d6\u5b8f\u7684\u6548\u7387\uff08\u65e0\u9700\u8c03\u7528\u51fd\u6570\u7684\u5f00\u9500\uff09\u548c\u4e00\u822c\u51fd\u6570\u7684\u6240\u6709\u53ef\u9884\u6599\u884c\u4e3a\u548c\u7c7b\u578b\u5b89\u5168\u6027\u3002\u5982\uff1a // Macro implementation, with a lot unexpected results #define CALL_WITH_MAX(a,b) f((a) > (b)) ? (a) : (b)) // template inline function implementation template < typename T > inline void callWithMax ( const T & a , const T & b ){ f ( a > b ? a : b ); } \u6761\u6b3e03\uff1a\u5c3d\u53ef\u80fd\u4f7f\u7528const char greeting [] = \"Hello\" ; char * p = greeting ; //non-const pointer, non-const data const char * p = greeting ; //non-const pointer, const data char * const p = greeting ; //const pointer, non-const data const char * const p = greeting ; //const pointer, const data \u5176\u533a\u522b\u5728\u4e8e const \u51fa\u73b0\u4e8e * \u7684\u5de6\u8fb9\u8fd8\u662f\u53f3\u8fb9\u3002 \u7531\u4e8eSTL\u8fed\u4ee3\u5668\u7531\u6307\u9488\u5851\u6a21\u51fa\u6765\uff0c\u6240\u4ee5\u58f0\u660e\u8fed\u4ee3\u5668\u4e3a const \u76f8\u5f53\u4e8e\u5c06\u6307\u9488\u58f0\u660e\u4e3a const \uff08\u5373 T* const \u4e00\u6837\uff09\u3002\u5982\u679c\u60f3\u8ba9\u8fed\u4ee3\u5668\u6307\u5411\u7684\u4e1c\u897f\u4e0d\u53ef\u6539\u52a8\uff0c\u5e94\u4f7f\u7528 const_iterator \u5728\u51fd\u6570\u58f0\u660e\u5f0f\u5185\uff0c const \u53ef\u4ee5\u548c\u51fd\u6570\u8fd4\u56de\u503c\u3001\u5404\u53c2\u6570\u3001\u51fd\u6570\u81ea\u8eab\uff08\u5982\u679c\u662f\u6210\u5458\u51fd\u6570\uff09\u4ea7\u751f\u5173\u8054\u3002 \u51fd\u6570\u8fd4\u56de\u503c class Rational { /*details*/ }; const Rational operator * ( const Rational & lhs , const Rational & rhs ); // To provide from the below situation Rational a , b , c ; if ( a * b = c ); // It is a mistake on comparison. And the compiler will return an error \u53c2\u6570\uff1a\u9632\u6b62\u8bef\u4fee\u6539\u3002\u5982\u6307\u9488\u6216\u5f15\u7528\u53c2\u6570\u3002 \u6210\u5458\u51fd\u6570 \u597d\u5904\uff1a \u4f7fclass\u63a5\u53e3\u5bb9\u6613\u88ab\u7406\u89e3\u3002\u53ef\u4ee5\u5f97\u77e5\u54ea\u4e2a\u51fd\u6570\u53ef\u4ee5\u6539\u52a8\u5bf9\u8c61\uff0c\u54ea\u4e2a\u51fd\u6570\u4e0d\u53ef\u4ee5\u3002 \u4f7f\u201c\u64cd\u4f5cconst\u5bf9\u8c61\u201d\u6210\u4e3a\u53ef\u80fd\u3002 \u7528\u6cd5\uff1a \u4e24\u4e2a\u6210\u5458\u51fd\u6570\u82e5\u4ec5\u662f\u5e38\u91cf\u6027(constness)\u4e0d\u540c\uff0c\u53ef\u4ee5\u88ab\u91cd\u8f7d class TextBlock { public : //details const char & operator []( std :: size_t position ) const { return text [ position ]; } char & operator []( std :: size_t position ){ return text [ position ]; } private : std :: string text ; } int main (){ TextBlock tb ( \"Hello\" ); std :: cout << tb [ 0 ]; // non-const TextBlock::operator[] const TextBlock ctb ( \"World\" ); std :: cout << ctb [ 0 ]; // const TextBlock::operator[] tb [ 0 ] = \"W\" ; // valid ctb [ 0 ] = \"H\" ; // invalid } \u4e3a\u4ee3\u7801\u590d\u7528\uff0c\u5e94\u4f7f\u7528non-const\u6210\u5458\u8c03\u7528const\u6210\u5458\u800c\u975e\u76f8\u53cd\u3002\u56e0\u4e3anon-const\u65b9\u6cd5\u4e0d\u627f\u8bfa\u4e0d\u6539\u53d8\u5bf9\u8c61\u53c2\u6570\u3002\u6545\u800cconst\u6210\u5458\u8c03\u7528non-const\u6210\u5458\u6709\u98ce\u9669\u3002\u5982\u4e0a\u9762\u7684\u4ee3\u7801\u8bfe\u6539\u4e3a\uff1a class TextBlock { public : //details const char & operator []( std :: size_t position ) const { return text [ position ]; } char & operator []( std :: size_t position ){ return const_cast < char &> ( // turn to non-const static_cast < const TextBlock &> ( * this ) // To call the const function [ position ]; ) } private : std :: string text ; } \u82e5\u5bf9\u4e8econst\u5bf9\u8c61\u5185\u53ef\u63a5\u53d7\u4fee\u6539\u7684\u6210\u5458\uff08\u9664static\u6210\u5458\u5916\uff09\uff0c\u5e94\u7528 mutable \u4fee\u9970\u3002 \u6761\u6b3e04\uff1a\u786e\u5b9a\u5bf9\u8c61\u88ab\u4f7f\u7528\u524d\u5df2\u5148\u88ab\u521d\u59cb\u5316 \u4e0d\u8981\u6df7\u6dc6\u8d4b\u503c(assignment)\u548c\u521d\u59cb\u5316(initialization)\u3002\u521d\u59cb\u5316\u5728\u8c03\u7528\u6784\u9020\u51fd\u6570\u9636\u6bb5\uff0c\u65e9\u4e8e\u8d4b\u503c\u3002 \u7528\u6210\u5458\u521d\u59cb\u5217(member initialization list)\u66ff\u6362\u8d4b\u503c\u52a8\u4f5c\uff1a class Test { Test ( int aValue , char bValue , std :: string & strValue ) : a ( aValue ), b ( bValue ), str ( strValue ) {} private : int a ; char b ; std :: string str ; } \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0cC++\u6807\u51c6\u6309\u7167\u58f0\u660e\u4f4d\u7f6e\u4ece\u524d\u5230\u540e\u7684\u65b9\u5f0f\u521d\u59cb\u5316\u6210\u5458\u3002\u56e0\u6b64\uff0c\u5982\u679c\u4f60\u60f3\u7528\u524d\u4e00\u4e2a\u6210\u5458\u6765\u521d\u59cb\u5316\u540e\u4e00\u4e2a\u6210\u5458\uff08\u4e00\u822c\u4e0d\u63a8\u8350\uff09\uff0c\u4f60\u9700\u8981\u5728\u540e\u4e00\u4e2a\u6210\u5458\u4e4b\u524d\u5b9a\u4e49\u524d\u4e00\u4e2a\u6210\u5458\u3002\u800c\u5404\u6210\u5458\u5728\u6210\u5458\u521d\u59cb\u5217\u4e2d\u7684\u987a\u5e8f\u5e76\u4e0d\u5f71\u54cd\u521d\u59cb\u5316\u987a\u5e8f\u3002\u4e5f\u56e0\u6b64\u5efa\u8bae\u4f60\u4f7f\u7528\u58f0\u660e\u987a\u5e8f\u6765\u5199\u6210\u5458\u521d\u59cb\u5217\u3002 \u4f7f\u7528\u6210\u5458\u521d\u59cb\u5217\u65f6\u5e94\u5f53\u5217\u51fa\u6240\u6709\u6210\u5458\u53d8\u91cf\uff0c\u4ee5\u514d\u5fd8\u8bb0\u521d\u59cb\u5316\u8fdb\u800c\u5bfc\u81f4ub\u3002 const \u548c reference \u6210\u5458\u53d8\u91cf\u53ea\u80fd\u88ab\u521d\u59cb\u5316\uff0c\u4e0d\u80fd\u88ab\u8d4b\u503c\u3002\u6545\u800c\u603b\u662f\u63a8\u8350\u4f7f\u7528\u6210\u5458\u521d\u59cb\u5217\u3002 \u5982\u679c\u7c7b\u6709\u591a\u4e2a\u6784\u9020\u51fd\u6570\uff0c\u53ef\u4ee5\u5c06\u90a3\u4e9b\u201c\u8d4b\u503c\u8868\u73b0\u50cf\u521d\u59cb\u5316\u4e00\u6837\u597d\u201d\u7684\u53d8\u91cf\u79fb\u5230\u5355\u72ec\u7684\u51fd\u6570\u4e2d\uff0c\u5e76\u5728\u6bcf\u4e2a\u6784\u9020\u51fd\u6570\u7684\u51fd\u6570\u4f53\u5185\u8c03\u7528\u5b83\u4eec\uff0c\u4ee5\u907f\u514d\u5197\u4f59\u91cd\u590d\u7684\u6210\u5458\u521d\u59cb\u5217\u3002 \u5bf9\u4e8e non-local static \u53d8\u91cf\uff0c\u82e5\u5b83\u4eec\u5728\u4e0d\u540c\u7f16\u8bd1\u5355\u5143\u5185\u5b9a\u4e49\uff08\u5982\u5728\u4e0d\u540c\u7684file\uff0c\u6700\u7ec8\u88ab #include fileName \u8fdb\u4e00\u4e2a\u6e90\u6587\u4ef6\uff09\u3002\u82e5\u5176\u4e2d\u4e00\u4e2a non-local static \u53d8\u91cf\u4f7f\u7528\u53e6\u4e00\u4e2a non-local static \u53d8\u91cf\u521d\u59cb\u5316\uff0c\u5219\u540e\u8005\u53ef\u80fd\u672a\u88ab\u521d\u59cb\u5316\uff0c\u8fdb\u800c\u5bfc\u81f4ub\u3002\u5bf9\u6b64\u89e3\u51b3\u65b9\u6cd5\u662f\u5c06\u6bcf\u4e2a non-local static \u53d8\u91cf\u653e\u5728\u81ea\u5df1\u7684\u4e13\u5c5e\u51fd\u6570(reference-returning function)\u5185\uff08\u7528 local static \u53d8\u91cf\u5c06\u5176\u66ff\u6362\uff0c\u5e76\u8fd4\u56de\u8be5\u53d8\u91cf\u7684\u5f15\u7528\uff09\u3002\u4f8b\u5982\uff1a class BaseClass { // details; } BaseClass & bc (){ static BaseClass bco ; return bco ; } \u8fd9\u6837\uff0c\u6211\u4eec\u901a\u8fc7\u63a5\u53e3 bc() \u8c03\u7528\u8fd9\u4e2a\u9759\u6001\u5bf9\u8c61\u3002\u82e5\u8be5\u53d8\u91cf\u5c1a\u672a\u521d\u59cb\u5316\uff0c\u5b83\u4f1a\u5728\u8fd4\u56de\u521d\u503c\u524d\u5b8c\u6210\u521d\u59cb\u5316\uff0c\u53cd\u4e4b\u5219\u4e0d\u4f1a\u6709\u8be5\u5f00\u9500\u3002\u82e5\u662f\u5f15\u7528\u6587\u4ef6\u672a\u8c03\u7528\u8be5\u63a5\u53e3\uff0c\u5219\u6839\u672c\u4e0d\u4f1a\u5b58\u5728\u6784\u9020\u548c\u6790\u6784\u4ee3\u4ef7\u3002 \u4f46 non-const static \u5bf9\u8c61\u5728\u591a\u7ebf\u7a0b\u73af\u5883\u4e0b\u90fd\u4f1a\u6709\u4e0d\u786e\u5b9a\u6027\u3002\u8be5\u95ee\u9898\u7684\u89e3\u51b3\u65b9\u6cd5\u4e4b\u4e00\u662f\uff1a\u5728\u7a0b\u5e8f\u7684\u5355\u7ebf\u7a0b\u542f\u52a8\u9636\u6bb5(single-threaded startup portion)\u624b\u52a8\u8c03\u7528\u6240\u6709 reference-returning function\u3002\u8fd9\u53ef\u6d88\u9664\u4e0e\u521d\u59cb\u5316\u6709\u5173\u7684\u201c\u7ade\u901f\u5f62\u5f0f(race conditions)\u201d \u6761\u6b3e05\uff1a\u4e86\u89e3C++\u9ed8\u8ba4\u7f16\u5199\u5e76\u8c03\u7528\u54ea\u4e9b\u51fd\u6570 default \u6784\u9020/\u6790\u6784\u51fd\u6570\uff1a \u8c03\u7528 base class \u548c non-static \u53d8\u91cf\u7684\u6784\u9020/\u6790\u6784\u51fd\u6570\u3002 \u7f16\u8bd1\u5668\u4ea7\u751f\u7684\u6790\u6784\u51fd\u6570\u662f non-virtual \u7684\uff0c\u9664\u975e\u8be5\u51fd\u6570\u7684 base class \u6709\u58f0\u660e virtual \u7684\u6790\u6784\u51fd\u6570\u3002\u8fd9\u79cd\u60c5\u51b5\u4e0b\u8be5\u51fd\u6570\u7684\u865a\u5c5e\u6027(virtualness)\u4e3b\u8981\u6765\u81ea base class\u3002 default copy\u51fd\u6570\u901a\u8fc7\u8d4b\u503c\u5185\u7f6e\u7c7b\u578b\u5e76\u8c03\u7528\u5176\u4ed6 non-static \u6210\u5458\u7684 copy \u51fd\u6570\u751f\u6210\u3002\u56e0\u6b64\u7f16\u8bd1\u5668\u4f1a\u62d2\u7edd\u4e3a\u4ee5\u4e0b\u4e09\u79cd\u60c5\u51b5\u751f\u6210 copy \u51fd\u6570\uff08\u800c\u5fc5\u987b\u81ea\u884c\u5b9a\u4e49\uff09\uff1a \u5185\u542b reference \u6210\u5458\u3002C++\u6807\u51c6\u4e0d\u5141\u8bb8 reference \u53d8\u91cf\u6307\u5411\u65b0\u7684\u5143\u7d20\u3002 \u5185\u542b const \u6210\u5458\u3002C++\u6807\u51c6\u4e0d\u5141\u8bb8\u6539\u53d8 const \u53d8\u91cf\u7684\u503c\u3002 \u5185\u542b\u67d0\u4e2a\u6210\u5458\u53d8\u91cf\uff0c\u901a\u8fc7 ClassMember::ClassMember(ClassMember &) = delete; \u8bed\u53e5\u6216\u5c06 copy \u8bed\u53e5\u7f6e\u4e8e private scope \u5185\uff0c\u4ee5\u6b64\u62d2\u7edd copy \u64cd\u4f5c\u3002 \u53e6\u5916\u4e00\u4e2aC++\u9ed8\u8ba4\u51fd\u6570\u7684\u95ee\u9898\u8be6\u89c1\u6211\u8fd9\u4e2a\u7ecf\u9a8c\u8d34\uff1a C++\u7684 0/3/5 \u89c4\u5219 \u6761\u6b3e06\uff1a\u82e5\u4e0d\u60f3\u4f7f\u7528\u7f16\u8bd1\u5668\u81ea\u52a8\u751f\u6210\u7684\u51fd\u6570\uff0c\u5c31\u8be5\u660e\u786e\u62d2\u7edd \u5bf9\u4e8e\u7c7b\u5185\u4e0d\u9700\u8981\u7684\u81ea\u52a8\u751f\u6210\u51fd\u6570\uff0c\u5e94\u5f53\u660e\u786e\u544a\u77e5\u4e0d\u9700\u8981\uff0c\u5982\u4ee5\u4e0b\u8bed\u6cd5\uff1a class ClassTest { public : ClassTest () = default ; ~ ClassText () = default ; // keyword delete explicitly denote that you don't need a copy function ClassTest ( const ClassText & ) = delete ; } \u4f46\u5bf9\u4e8e C++11 \u4ee5\u524d\u7684\u6807\u51c6\uff0c\u6ca1\u6709\u5b9e\u73b0\u7528\u4e8e\u963b\u6b62\u81ea\u52a8\u751f\u6210\u51fd\u6570\u7684 delete \u5173\u952e\u8bcd\uff0c\u5927\u5bb6\u4e00\u822c\u901a\u8fc7\u5c06\u5176\u58f0\u660e\u5728 private scope\u91cc\u5e76\u4e0d\u53bb\u5b9a\u4e49\u5b83\u6765\u8fbe\u5230\u8fd9\u4e2a\u6548\u679c\u3002 class ClassTest { public : ClassTest () { /*details*/ } ~ ClassText () { /*details*/ } private : ClassTest ( const ClassText & ); } \u8fd9\u6837\uff0c\u7c7b\u5916\u65b9\u6cd5\u5c31\u65e0\u6cd5\u8c03\u7528\u8be5\u51fd\u6570\u3002\u800c\u7c7b\u5185\u6210\u5458\u6216\u53cb\u5143\u5c1d\u8bd5\u8c03\u7528\u5b83\u65f6\u5c31\u4f1a\u9047\u5230\u94fe\u63a5\u5668\u9519\u8bef\u3002\u4f60\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u5c06\u94fe\u63a5\u5668\u9519\u8bef\u8f6c\u5316\u4e3a\u7f16\u8bd1\u5668\u9519\u8bef\uff1a class BaseClass { public : BaseClass () {} ~ BaseClass () {} private : BaseClass ( const BaseClass & ); } class ClassTest : public BaseClass { //details } \u8fd9\u6837\uff0c\u5728\u7f16\u8bd1\u5668\u5c1d\u8bd5\u4e3a ClassTest \u7c7b\u81ea\u52a8\u751f\u6210 copy \u64cd\u4f5c\u65f6\uff0c\u7531\u4e8e\u65e0\u6cd5\u8c03\u7528 BaseClass \u7684 copy \u51fd\u6570\uff0c\u5c31\u4e0d\u4f1a\u4e3a\u8be5\u7c7b\u751f\u6210 copy \u51fd\u6570\u3002\u4f46\u8fd9\u79cd\u65b9\u6cd5\u53ef\u80fd\u9020\u6210\u591a\u91cd\u7ee7\u627f\u3002 \u6761\u6b3e07\uff1a\u4e3a\u591a\u6001\u57fa\u7c7b\u58f0\u660evirtual\u6790\u6784\u51fd\u6570 \u82e5 class \u610f\u56fe\u88ab\u5f53\u4f5c\u4e00\u4e2a \u5e26\u591a\u6001\u6027\u8d28\u7684 base class \u4f7f\u7528\uff0c\u5e94\u5f53\u6309\u7167\u9700\u6c42\u4e3a\u5176\u5b9a\u5236 virtual \u6790\u6784\u51fd\u6570\u3002 \u82e5\u7c7b\u5b58\u5728\u81f3\u5c11\u4e00\u4e2avirtual\u51fd\u6570\uff0c\u518d\u4e3a\u5176\u5b9a\u5236 virtual \u6790\u6784\u51fd\u6570\uff0c\u5426\u5219\u4e0d\u8981\u5b9a\u4e49 virtual \u51fd\u6570\u3002 virtual\u51fd\u6570\u4f1a\u5e26\u6765\u989d\u5916\u7684 vtpr(virtual table pointer)\u7684\u5f00\u9500\uff0c\u5e76\u4f1a\u4e27\u5931\u548c\u5176\u4ed6\u8bed\u8a00\uff08\u5982C\uff09\u5185\u7684\u76f8\u540c\u58f0\u660e\u4e00\u6837\u7684\u7ed3\u6784\uff0c\u4ece\u800c\u4e27\u5931\u53ef\u79fb\u690d\u6027\u3002 \u5e94\u5f53\u7528 final \u5173\u952e\u8bcd\u62d2\u7edd\u7c7b\u88ab\u7ee7\u627f\u6216\u7279\u5b9a\u865a\u51fd\u6570\u88ab\u91cd\u5199\u3002 \u6761\u6b3e08\uff1a\u522b\u8ba9\u5f02\u5e38\u9003\u79bb\u6790\u6784\u51fd\u6570 \u5bf9\u4e8e\u6790\u6784\u51fd\u6570\u5185\u9020\u6210\u7684\u5f02\u5e38\uff0c\u82e5\u9009\u62e9\u7f6e\u4e4b\u4e0d\u7406\uff0c\u5219\u5f88\u53ef\u80fd\u9020\u6210ub\u3002\u4e00\u822c\u800c\u8a00\u6709\u4e09\u79cd\u89e3\u51b3\u65b9\u5f0f\uff1a \u82e5\u629b\u51fa\u5f02\u5e38\u5219\u7ed3\u675f\u7a0b\u5e8f\u3002\u901a\u5e38\u901a\u8fc7\u8c03\u7528 std::abort \u5b8c\u6210\u3002 \u541e\u4e0b\u5f02\u5e38\u3002 \u91cd\u65b0\u8bbe\u8ba1\u63a5\u53e3\u548c\u7c7b\uff0c\u5c06\u53ef\u80fd\u9020\u6210\u5f02\u5e38\u7684\u884c\u4e3a\u79fb\u51fa\u6790\u6784\u51fd\u6570\u3002 \u6761\u6b3e09\uff1a\u7edd\u4e0d\u518d\u6784\u9020\u548c\u6790\u6784\u8fc7\u7a0b\u4e2d\u8c03\u7528virtual\u51fd\u6570 base class \u6784\u9020\u671f\u95f4\u5176 virtual \u51fd\u6570\u7edd\u4e0d\u4f1a\u4e0b\u964d\u5230 derived classes \u9636\u5c42\u3002\u8be5 virtual \u51fd\u6570\u4ecd\u7136\u4f1a\u6267\u884c base class \u91cc\u5b9a\u4e49\u7684\u5b9e\u4f8b\u3002 \u6839\u672c\u539f\u56e0\uff1a\u5728 derived class \u7684 base class \u6784\u9020\u671f\u95f4\uff0c\u5bf9\u8c61\u7684\u7c7b\u578b\u662f base class \u800c\u975e derived class\u3002 \u6761\u6b3e10\uff1a\u4ee4operator=\u8fd4\u56de\u4e00\u4e2areference To *this \u7531\u4e8eC++\u652f\u6301\u8d4b\u503c\u8fde\u9501\u5f62\u5f0f\uff0c\u4e14\u8d4b\u503c\u91c7\u7528\u53f3\u7ed3\u5408\u5f8b\u3002 int x , y , z ; x = y = z = 15 ; // the above sentence is interpreted as the below style x = ( y = ( z = 15 )); \u4e3a\u4e86\u5b9e\u73b0\u8fde\u9501\u8d4b\u503c\uff0c\u8d4b\u503c\u64cd\u4f5c\u7b26\u5fc5\u987b\u8fd4\u56de\u4e00\u4e2a reference \u5b9e\u53c2\u3002 class Test { public : //details Test & operator ( const Test & rhs ){ //details return * this ; } } \u6761\u6b3e11\uff1a\u5728operator=\u4e2d\u5904\u7406\u201c\u81ea\u6211\u8d4b\u503c\u201d \u81ea\u8d4b\u503c\u5373\u5bf9\u8c61\u8d4b\u503c\u7ed9\u81ea\u5df1\uff0c\u4e00\u822c\u76f4\u63a5\u6216\u95f4\u63a5\u5730\u53d1\u751f\u4e8e\u4ee5\u4e0b\u60c5\u51b5\uff1a w = w ; a [ i ] = a [ j ]; //when i == j * px = * py ; //when px == py \u5982\u679c\u5bf9\u8c61\u81ea\u884c\u7ba1\u7406\u8d44\u6e90\uff0c\u4e14\u4e0d\u786e\u5b9a\u5176 copy \u884c\u4e3a\u662f\u5b89\u5168\u7684\uff08\u5982\u53ef\u80fd\u5728\u505c\u6b62\u4f7f\u7528\u8d44\u6e90\u524d\u610f\u5916\u5730\u91ca\u653e\u4e86\u5b83\uff09\uff0c\u5c31\u53ef\u80fd\u9020\u6210\u96be\u4ee5 debug \u7684 ub\u3002 \u5728\u8bbe\u8ba1 copy \u884c\u4e3a\u65f6\uff0c\u5e94\u5173\u6ce8\u8be5\u884c\u4e3a\u662f\u4e0d\u662f \u201c\u81ea\u8d4b\u503c\u5b89\u5168\u201d \u548c \u201c\u5f02\u5e38\u5b89\u5168\u201d \u7684\u3002\u4e14\u4e00\u822c\u800c\u8a00\uff0c\u201c\u5f02\u5e38\u5b89\u5168\u201d\u7684 copy \u884c\u4e3a\u5f80\u5f80\u4e5f\u662f\u201c\u81ea\u8d4b\u503c\u5b89\u5168\u201d\u7684\uff0c\u56e0\u6b64\u6709\u8bb8\u591a\u4eba\u90fd\u81f4\u529b\u4e8e\u5b9e\u73b0 \u201c\u5f02\u5e38\u5b89\u5168\u6027\u201d(exception safety)\u4e0a\u3002\u4e0b\u9762\u662f\"\u81ea\u8d4b\u503c\u5b89\u5168\"\u548c\"\u5f02\u5e38\u5b89\u5168\"\u7684\u4e24\u4e2a\u4f8b\u5b50\uff1a class Widget { public : Widget & operator = ( const Widget & rhs ); private : int * pb ; } // self-assignment safety but exception unsafety Widget & Widget :: operator = ( const Widget & rhs ){ if ( this == & rhs ) return * this ; //identity test delete pb ; pb = new int ( * rhs . pb ); //exception unsafety, new operation possibly fails return * this ; } //exception safety and self-assignment safety Widget & Widget :: operator = ( const Widget & rhs ){ int * temp = pb ; pb = new int ( * rhs . pb ); //pb still points to its origin value if new operation fails delete temp ; return * this ; } //Another way satisfies exception safety and self-assignment safety Widget & Widget :: operator = ( const Widget & rhs ){ Widget temp ( rhs ); swap ( temp ); return * this ; } \u6761\u6b3e12\uff1a\u590d\u5236\u5bf9\u8c61\u65f6\u52ff\u5fd8\u5176\u6bcf\u4e00\u4e2a\u6210\u5206 \u82e5\u7c7b\u6dfb\u52a0\u4e86\u65b0\u7684\u53d8\u91cf\uff0c\u4e14\u4f60\u81ea\u5b9a\u4e49\u4e86 copy(copy \u548c copy-assignment) \u51fd\u6570\uff0c\u4f60\u5c31\u8981\u4fee\u6539\u5b83\u4eec\u3002\u4f60\u9700\u8981\u786e\u4fdd\uff1a \u590d\u5236\u6240\u6709\u7684 local \u6210\u5458\u53d8\u91cf\u3002 \u8c03\u7528\u6240\u6709 base classes \u5185\u7684\u9002\u5f53\u7684 copying \u51fd\u6570\u3002 \u4e0d\u8be5\u4ee4 copy-assignment \u64cd\u4f5c\u7b26\u8c03\u7528 copy \u6784\u9020\u51fd\u6570\uff0c\u6216\u662f\u76f8\u53cd\u3002\u66ff\u4ee3\u65b9\u6848\u662f\u5efa\u7acb\u4e00\u4e2a private \u7684 init \u51fd\u6570\u4f9b\u4e8c\u8005\u8c03\u7528\u3002 \u6761\u6b3e13\uff1a\u4ee5\u5bf9\u8c61\u7ba1\u7406\u8d44\u6e90 \u5c06\u8d44\u6e90\u653e\u8fdb\u5bf9\u8c61\u5185\uff0c\u8ba9\u5bf9\u8c61\u5728\u7ed3\u675f\u751f\u547d\u5468\u671f\u540e\u6790\u6784\u5b83\u4eec\u3002 \u7528\u667a\u80fd\u6307\u9488\u6765\u7ba1\u7406 heap-based \u8d44\u6e90\u3002\u4f46\u8981\u6ce8\u610f\uff0c \u667a\u80fd\u6307\u9488\u4e0d\u652f\u6301 contravariance \uff0c\u56e0\u6b64\u5728\u8003\u8651\u9762\u5411\u5bf9\u8c61\u7684\u591a\u6001\u5c5e\u6027\u65f6\u8981\u8fdb\u884c\u53d6\u820d\u3002 \u8d44\u6e90\u53d6\u5f97\u7684\u65f6\u673a\u4fbf\u662f\u521d\u59cb\u5316\u7684\u65f6\u673a(Resource Acquisition Is Initialization; RAII) \u6761\u6b3e14\uff1a\u5728\u8d44\u6e90\u7ba1\u7406\u7c7b\u4e2d\u5c0f\u5fc3copying\u884c\u4e3a \u4e24\u79cd\u65b9\u6cd5\u907f\u514d\u8d44\u6e90\u7ba1\u7406\u7c7b\u7684 copying \u884c\u4e3a\u5bfc\u81f4\u7684 bug\uff08\u5982\u591a\u6b21delete\uff09\uff1a \u7981\u6b62\u590d\u5236 \u5bf9\u5e95\u5c42\u8d44\u6e90\u4f7f\u7528\u201c\u5f15\u7528\u8ba1\u6570\u6cd5\u201d\uff1a \u5185\u542b std::shared_ptr \u6210\u5458\u53d8\u91cf\u3002\u4f46\u8981\u6ce8\u610f std::shared_ptr \u7684\u7f3a\u7701\u884c\u4e3a\uff1a\u5f53\u5f15\u7528\u6b21\u6570\u4e3a\u96f6\u65f6\u5220\u9664\u5176\u6240\u6307\u7269\u3002 \u53ef\u4ee5\u901a\u8fc7\u81ea\u5b9a\u4e49 std::shared_ptr \u7684\u201c\u5220\u9664\u5668\u201d(deleter)\u7684\u65b9\u5f0f\u6765\u81ea\u5b9a\u4e49\u201c\u5f15\u7528\u8ba1\u6570\u5668\u7f6e0\u65f6\u201d\u7684\u884c\u4e3a\u3002\u5220\u9664\u5668\u51fd\u6570\u6307\u9488\u662f std::shared_ptr \u7684\u7b2c\u4e8c\u4e2a\u53c2\u6570\uff08\u53ef\u7f3a\u7701\uff09\u3002 \u4e24\u79cd\u65b9\u6cd5\u6765\u786e\u4fdd\u5b89\u5168\u5730 copy \u5e95\u5c42\u8d44\u6e90\uff1a \u590d\u5236\u5e95\u90e8\u8d44\u6e90\u3002 \u8f6c\u79fb\u5e95\u90e8\u8d44\u6e90\u7684\u6240\u6709\u6743\u3002 \u6761\u6b3e15\uff1a\u5728\u8d44\u6e90\u7ba1\u7406\u7c7b\u4e2d\u63d0\u4f9b\u5bf9\u539f\u59cb\u8d44\u6e90\u7684\u8bbf\u95ee \u663e\u5f0f\u8f6c\u6362\uff1a\u901a\u8fc7 get() \u7b49\u63a5\u53e3\u8fd4\u56de\u7c7b\u7ba1\u7406\u7684\u539f\u59cb\u6307\u9488\uff08\u7684\u590d\u4ef6\uff09\u3002 \u9690\u5f0f\u8f6c\u6362\uff1a\u91cd\u8f7d\u64cd\u4f5c\u7b26\uff0c\u81f3\u5c11\u5305\u62ec\u6307\u9488\u53d6\u503c(pointer dereferencing)\u64cd\u4f5c\u7b26( operator-> \u548c operator* ) \u6761\u6b3e16\uff1a\u6210\u5bf9\u4f7f\u7528new\u548cdelete\u65f6\u8981\u91c7\u53d6\u76f8\u540c\u5f62\u5f0f std :: string * StrPtr = new std :: string ( \"Hello World\" ); delete StrPtr ; std :: string * StrArrayPtr = new std :: string [ 100 ]; delete [] StrArrayPtr ; \u5bf9\u4e8e\u6307\u5411\u5143\u7d20\u548c\u6307\u5411\u6570\u7ec4\u7684\u6307\u9488\u6709\u4e0d\u540c\u7684 delete \u903b\u8f91\u3002\u9700\u8981\u683c\u5916\u6ce8\u610f\u4e24\u4ef6\u4e8b\uff1a \u5f53\u4f60\u7684 class \u542b\u6709\u4e00\u4e2a\u6307\u9488\u6307\u5411\u52a8\u6001\u5185\u5b58\uff0c\u4e14\u63d0\u4f9b\u591a\u4e2a\u6784\u9020\u51fd\u6570\u65f6\uff0c\u9700\u8981\u683c\u5916\u6ce8\u610f\u8be5\u89c4\u5219\u3002 \u4f7f\u7528 typedef \u65f6\u5fc5\u987b\u8bf4\u6e05\u695a\uff0c\u5f53\u7a0b\u5e8f\u5458\u4ee5 new \u6765\u521b\u5efa\u5bf9\u8c61\u65f6\uff0c\u8be5\u4ee5\u54ea\u79cd delete \u5f62\u5f0f\u5220\u9664\u5b83\u3002 \u6761\u6b3e17\uff1a\u4ee5\u72ec\u7acb\u8bed\u53e5\u5c06 Newed \u5bf9\u8c61\u7f6e\u5165\u667a\u80fd\u6307\u9488 class Widget ; int priority (); // executable sentence void processWidget ( std :: shared_ptr < Widget > ( new Widget ), priority ()); \u5bf9\u4e8e\u4e0a\u9762\u7684\u6267\u884c\u8bed\u53e5\uff0c\u7f16\u8bd1\u5668\u4fdd\u8bc1\uff1a new Widget \u5728\u521b\u5efa std::shared_ptr \u4e4b\u524d\u5b8c\u6210\u3002\u4f46\u6267\u884c\u5e76\u8fd4\u56de priority() \u7684\u987a\u5e8f\u4e0d\u786e\u5b9a\u3002\u8fd9\u6837\uff0c\u5047\u5982 priority() \u7684\u6267\u884c\u987a\u5e8f\u5728 new Widget \u548c std::shared_ptr \u4e4b\u95f4\uff0c\u4e14\u5728\u6267\u884c\u8fc7\u7a0b\u4e2d\u53d1\u751f\u5f02\u5e38\u3002\u5c31\u4f1a\u5bfc\u81f4 new Widget \u7684\u8fd9\u5757\u5185\u5b58\u6cc4\u6f0f\u3002 \u6b63\u786e\u65b9\u5f0f\u662f\u5c06\u5efa\u7acb\u667a\u80fd\u6307\u9488\u8bed\u53e5\u653e\u5728\u72ec\u7acb\u8bed\u53e5\u4e2d\u3002\u8fd9\u6837\u7f16\u8bd1\u5668\u603b\u4fdd\u8bc1\u5728\u4e0b\u4e00\u6761\u72ec\u7acb\u8bed\u53e5\u6267\u884c\u524d\u6267\u884c\u5168\u90e8\u8be5\u72ec\u7acb\u8bed\u53e5\u7684\u64cd\u4f5c\u3002 std :: shared_ptr < Widget > pw ( new Widget ); processWidget ( pw , priority ()); \u6761\u6b3e18\uff1a\u8ba9\u63a5\u53e3\u5bb9\u6613\u88ab\u6b63\u786e\u4f7f\u7528\uff0c\u4e0d\u6613\u88ab\u8bef\u7528 \u7406\u60f3\u4e0a\uff0c\u5982\u679c\u5ba2\u6237\u4f01\u56fe\u4f7f\u7528\u67d0\u4e2a\u63a5\u53e3\u800c\u5374\u6ca1\u6709\u83b7\u5f97\u4ed6\u6240\u9884\u671f\u7684\u884c\u4e3a\uff0c\u8fd9\u4e2a\u4ee3\u7801\u4e0d\u8be5\u901a\u8fc7\u7f16\u8bd1\uff1b\u5982\u679c\u4ee3\u7801\u901a\u8fc7\u4e86\u7f16\u8bd1\uff0c\u5b83\u7684\u4f5c\u4e3a\u5c31\u8be5\u662f\u5ba2\u6237\u6240\u60f3\u8981\u7684\u3002 \u5728\u53c2\u6570\u8bbe\u8ba1\u4e0a\uff0c\u53ef\u4ee5\u5f15\u5165\u7c7b\u578b\u7cfb\u7edf(type system)\u6765\u963b\u6b62\u9519\u8bef\u4f20\u53c2\u3002\u5982\u8bbe\u8ba1\u201c\u65e5\u5386\u201d\u63a5\u53e3\uff1a class Date { public : Data ( int month , int day , int year ); // details } \u8fd9\u662f\u4e0d\u826f\u7684\u8bbe\u8ba1\uff0c\u53ef\u80fd\u4f1a\u9020\u6210\u9519\u8bef\u4f20\u53c2\u3002\u6211\u4eec\u53ef\u4ee5\u5f15\u5165\u5916\u8986\u7c7b\u578b(wrapper types)\u6765\u533a\u522b\u5e74\u6708\u65e5\uff1a struct Day { explicit Day ( int d ) : day ( d ) {} private : int day ; } struct Month { explicit Month ( int m ) : month ( m ) {} private : int month ; } struct Year { explicit Year ( int y ) : year ( y ) {} private : int year ; } class Date { public : Date ( const Month & m , const Day & d , const Year & y ); //details } // executable sentence Date ( Month ( 6 ), Day ( 4 ), Year ( 1989 )); \u4e00\u65e6\u5df2\u7ecf\u5b9a\u4e49\u4e86\u6b63\u786e\u7684\u7c7b\u578b\uff0c\u5728\u6b64\u57fa\u7840\u4e0a\u9650\u5236\u5176\u503c\u4e5f\u662f\u5408\u7406\u7684\uff0c\u5982\u8003\u8651\u5230\u4e00\u5e74\u53ea\u670912\u4e2a\u6708\uff0c\u6708\u4efd\u63a5\u53e3\u53ef\u4ee5\u5982\u4e0b\u8bbe\u8ba1\uff1a class Month { public : static Month Jan () { return Month ( 1 ); } static Month Feb () { return Month ( 2 ); } //... static Month Dec () { return Month ( 12 ); } private : explicit Month ( int m ) : month ( m ) {} int month ; } Date ( Month :: Jun (), Day ( 4 ), Year ( 1989 )); \u9650\u5236\u7c7b\u578b\u5185\u4ec0\u4e48\u4e8b\u53ef\u4ee5\u505a\uff0c\u4ec0\u4e48\u4e8b\u4e0d\u53ef\u4ee5\u505a \u5e38\u89c1\u7684\u9650\u5236\u662f\u52a0\u4e0a const \u3002 \u5c3d\u91cf\u63d0\u4f9b\u4e00\u81f4\u6027\u7684\u63a5\u53e3 \u9664\u975e\u6709\u597d\u7406\u7531\uff0c\u5426\u5219\u5c3d\u91cf\u8ba9\u4f60\u7684 types \u7684\u884c\u4e3a\u548c\u7cfb\u7edf\u5185\u7f6e types \u7684\u884c\u4e3a\u4e00\u81f4\u3002 \u5bf9\u76f8\u540c\u529f\u80fd\u63d0\u4f9b\u76f8\u540c\u7684\u63a5\u53e3\u3002\uff08\u5982 STL \u5bb9\u5668\u7684 size() \u6210\u5458\u51fd\u6570\uff09 \u907f\u514d\u8ba9\u5ba2\u6237\u53bb\u505a\u67d0\u4e9b\u4e8b\u60c5 \u5982\u679c\u7c7b\u7684\u8bbe\u8ba1\u8981\u6c42\u5ba2\u6237\u5fc5\u987b\u505a\u67d0\u4e9b\u4e8b\u60c5\uff0c\u5ba2\u6237\u6709\u53ef\u80fd\u4f1a\u5fd8\u8bb0\u53bb\u505a\u5b83\u3002\u6bd4\u5982\u5f53\u7c7b\u8fd4\u56de\u4e00\u4e2a\u6307\u9488\u65f6\uff0c\u5ba2\u6237\u53ef\u80fd\u4f1a\u5fd8\u8bb0\u91ca\u653e\u5b83\uff0c\u9020\u6210\u5185\u5b58\u6cc4\u6f0f\u3002\u89e3\u51b3\u65b9\u6cd5\u662f\u5c06\u5b83\u5c01\u88c5\u6210\u4e00\u4e2a std::shared_ptr \u8fd4\u56de\u7ed9\u5ba2\u6237\u3002 \u5982\u679c\u8fd9\u4efd\u8d44\u6e90\u9700\u8981\u7279\u522b\u7684\u6790\u6784\u5668\u6765\u6790\u6784\uff0c\u4e5f\u5e94\u5f53\u5c06\u8fd9\u4e2a\u6790\u6784\u5668\u4f5c\u4e3a\u7b2c\u4e8c\u4e2a\u53c2\u6570\u4f20\u7ed9 std::shared_ptr \u8fd4\u56de\u7ed9\u5ba2\u6237\u3002 \u6761\u6b3e19\uff1a\u8bbe\u8ba1class\u72b9\u5982\u8bbe\u8ba1type \u597d\u7684 type \u6709\u81ea\u7136\u7684\u8bed\u6cd5\uff0c\u76f4\u89c2\u7684\u8bed\u4e49\uff0c\u4ee5\u53ca\u4e00\u6216\u591a\u4e2a\u9ad8\u6548\u5b9e\u73b0\u54c1\u3002 \u5728\uff08\u50cf\u8bbe\u8ba1 type \u4e00\u6837\uff09\u8bbe\u8ba1 class \u65f6\u9700\u8981\u56de\u7b54\u4ee5\u4e0b\u95ee\u9898\uff1a \u65b0 type \u7684\u5bf9\u8c61\u5e94\u8be5\u5982\u4f55\u88ab\u521b\u5efa\u548c\u9500\u6bc1\uff1f \u8fd9\u4f1a\u5f71\u54cd\u5230\u4f60\u7684 class \u7684\u6784\u9020\u51fd\u6570\u3001\u6790\u6784\u51fd\u6570\u53ca\u5185\u5b58\u5206\u914d\u548c\u91ca\u653e\u51fd\u6570( operator new \u3001 operator new[] \u3001 operator delete \u3001 operator delete[] ) \u5bf9\u8c61\u7684\u521d\u59cb\u5316\u548c\u5bf9\u8c61\u7684\u8d4b\u503c\u8be5\u6709\u4ec0\u4e48\u6837\u7684\u5dee\u522b\uff1f \u51b3\u5b9a\u4e86\u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c(assignment)\u64cd\u4f5c\u7b26\u7684\u884c\u4e3a\u3002 \u65b0 type \u7684\u5bf9\u8c61\u5982\u679c\u88ab passed by value\uff08\u4ee5\u503c\u4f20\u9012\uff09\uff0c\u610f\u5473\u7740\u4ec0\u4e48\uff1f copy \u6784\u9020\u51fd\u6570\u7528\u6765\u5b9a\u4e49\u4e00\u4e2a type \u7684 pass-by-value \u8be5\u5982\u4f55\u5b9e\u73b0\u3002 \u4ec0\u4e48\u662f\u65b0 type \u7684 \u201c\u5408\u6cd5\u503c\u201d\uff1f \u51b3\u5b9a\u4e86\u4f60\u7684 class \u5fc5\u987b\u7ef4\u62a4\u7684\u7ea6\u675f\u6761\u4ef6(invariants)\u3002 \u51b3\u5b9a\u4e86\u6210\u5458\u51fd\u6570\uff08\u5c24\u5176\u662f\u6784\u9020\u51fd\u6570\u3001\u8d4b\u503c\u64cd\u4f5c\u7b26\u548c\"setter\"\u51fd\u6570\uff09\u5fc5\u987b\u8fdb\u884c\u7684\u9519\u8bef\u68c0\u67e5\u5de5\u4f5c\u3002 \u5f71\u54cd\u51fd\u6570\u629b\u51fa\u7684\u5f02\u5e38\uff0c\u4ee5\u53ca\uff08\u6781\u5c11\u88ab\u4f7f\u7528\u7684\uff09\u51fd\u6570\u5f02\u5e38\u660e\u7ec6\u5217(exception specifications) \u4f60\u7684\u65b0 type \u9700\u8981\u914d\u5408\u67d0\u4e2a\u7ee7\u627f\u56fe\u7cfb(inheritance graph)\u5417\uff1f \u5982\u679c\u4f60\u7684 class \u7ee7\u627f\u81ea\u65e2\u6709 classes\uff0c \u5c31\u4f1a\u53d7\u5230\u5b83\u4eec\u7684\u7ea6\u675f\uff0c\u7279\u522b\u4f1a\u53d7\u5230\u5176\u51fd\u6570\u662f\u5426\u4e3a virtual \u7684\u5f71\u54cd \u5982\u679c\u4f60\u5141\u8bb8\u5176\u4ed6 classes \u7ee7\u627f\u4f60\u7684 class\uff08\u5426\u5219\u7684\u8bdd\u53ef\u4ee5\u58f0\u660e\u4e3a final \uff09\uff0c\u5c31\u4f1a\u5f71\u54cd\u4f60\u6240\u58f0\u660e\u7684\u51fd\u6570\u2014\u2014\u5c24\u5176\u662f\u6790\u6784\u51fd\u6570\u2014\u2014\u662f\u5426\u4e3a virtual\u3002 \u4f60\u7684\u65b0 type \u9700\u8981\u4ec0\u4e48\u6837\u7684\u8f6c\u6362\uff1f \u82e5\u5141\u8bb8\u9690\u5f0f\u8f6c\u6362\uff0c\u9700\u8981\u5b9a\u4e49\u7c7b\u578b\u8f6c\u6362\u51fd\u6570\uff08 Class1::operator Class2() \uff09\u6216\u5728 Class2 \u5185\u5199\u4e00\u4e2a non-explicit-one-argument\uff08\u53ef\u88ab\u5355\u4e00\u5b9e\u53c2\u8c03\u7528\uff09\u7684\u6784\u9020\u51fd\u6570\uff08\u5e76\u4ee5 Class1 \u4e3a\u53c2\uff09\u3002 \u82e5\u53ea\u5141\u8bb8\u663e\u793a\u8f6c\u6362\uff0c\u5219\u9700\u5b9a\u4e49\u8f6c\u6362\u51fd\u6570\u3002 \u4ec0\u4e48\u6837\u7684\u64cd\u4f5c\u7b26\u548c\u51fd\u6570\u5bf9\u6b64\u65b0 type \u800c\u8a00\u662f\u5408\u7406\u7684\uff1f \u4ec0\u4e48\u6837\u7684\u6807\u51c6\u51fd\u6570\u5e94\u8be5\u9a73\u56de\uff1f \u8fd9\u4e9b\u51fd\u6570\u5fc5\u987b\u58f0\u660e\u4e3a private\u3002 \u8c01\u8be5\u53d6\u7528\u65b0 type \u7684\u6210\u5458\uff1f \u51b3\u5b9a\u4e86\u6210\u5458\u7684 scope\u3002 \u51b3\u5b9a\u4e86\u5176\u4ed6\u7c7b/\u51fd\u6570\u5e94\u4e0d\u5e94\u8be5\u4f5c\u4e3a\u53cb\u5143\u3002 \u4ec0\u4e48\u662f\u65b0 type \u7684\u201c\u672a\u58f0\u660e\u63a5\u53e3(undeclared interface)\u201d\uff1f \u9700\u8981\u56de\u7b54\u5b83\u5bf9\u6548\u7387\u3001\u5f02\u5e38\u5b89\u5168\u6027\u4ee5\u53ca\u8d44\u6e90\u8fd0\u7528\uff08\u4f8b\u5982\u591a\u4efb\u52a1\u9501\u5b9a\u548c\u52a8\u6001\u5185\u5b58\uff09\u63d0\u4f9b\u4f55\u79cd\u4fdd\u8bc1\uff1f\u8fd9\u4e9b\u95ee\u9898\u4f1a\u4e3a\u5b9e\u73b0\u4ee3\u7801\u6dfb\u52a0\u7ea6\u675f\u6761\u4ef6\u3002 \u4f60\u7684\u65b0 type \u6709\u591a\u4e48\u4e00\u822c\u5316\uff1f \u5982\u679c\u4f60\u9700\u8981\u5b9a\u4e49\u4e00\u7cfb\u5217 types\uff0c\u6216\u8bb8\u4f60\u9700\u8981\u5b9a\u4e49\u4e00\u4e2a class template\u3002 \u4f60\u771f\u7684\u9700\u8981\u4e00\u4e2a\u65b0 type \u5417\uff1f \u6761\u6b3e20\uff1a\u5b81\u4ee5pass-by-lvalue-reference\u548cpass-by-lvalue-reference-to-const\u66ff\u6362pass-by-value \u7531\u4e8e pass-by-value \u65b9\u5f0f\u4f20\u9012\u7684\u662f\u53c2\u6570\u7684\u526f\u672c\u3002\u6240\u4ee5\u5bf9\u67d0\u4e9b\u7c7b\u578b\u800c\u8a00\uff0c\u901a\u8fc7pass-by-value\u4f20\u9012\u4f1a\u9020\u6210\u989d\u5916\u7684\u6784\u9020\u548c\u6790\u6784\u5f00\u9500\u3002\u800c\u4ee5\u5f15\u7528\u65b9\u5f0f\u4f20\u53c2\uff08\u4ec5\u4f20\u6307\u9488\u7684\u526f\u672c\uff09\u5219\u4f1a\u964d\u4f4e\u8fd9\u4e9b\u5f00\u9500\u3002 by-reference \u4f20\u9012\u53ef\u4ee5\u907f\u514d slicing\uff08\u5bf9\u8c61\u5207\u5272\uff09\u95ee\u9898\u3002\u5982\u4e3a\u4e00\u4e2a\u63a5\u53d7 base class \u7684 by-value \u548c by-reference \u51fd\u6570\u4f20\u9012\u4e00\u4e2a derived class \u53c2\u6570\u3002\u524d\u8005\u53ea\u4f1a\u8c03\u7528 base class \u7684 copy \u51fd\u6570\u5e76\u83b7\u5f97 base class \u7684\u4e00\u4e2a\u526f\u672c\u3002\u800c\u540e\u8005\u5b9e\u9645\u6307\u5411\u4e00\u4e2a derived class \u5219\u53ef\u4ee5\u5e94\u7528 covariance\u3002\u8fd9\u4f1a\u5f71\u54cd\u5230\u8c03\u7528 virtual \u51fd\u6570\u7684\u903b\u8f91\u3002 \u7531\u4e8e\u5f15\u7528\u5b9e\u9645\u4e0a\u662f\u6307\u9488\u7684\u4e00\u79cd\u5c01\u88c5\uff0c\u6240\u4ee5\u5b83\u7684\u5f00\u9500\u4f1a\u7a0d\u5927\u4e8e\u7f16\u8bd1\u5668\u5185\u7f6e\u7c7b\u578b\u548cSTL\u7684\u8fed\u4ee3\u5668\u548c\u51fd\u6570\u5bf9\u8c61\u3002\u8fd9\u4e9b types \u90fd\u662f\u4e60\u60ef\u4e0a\u88ab\u8bbe\u8ba1\u4e3a passed-by-value \u7684\u3002 \u9664\u4e86\u4e0a\u8ff0 types \u5916\uff0c\u4e0d\u5efa\u8bae\u5c06\u5c0f types \u8bbe\u8ba1\u4e3a passed-by-value\u3002\u539f\u56e0\u6709\u4e8c\uff1a \u67d0\u4e9b\u7f16\u8bd1\u5668\u5728\u5bf9\u5f85\u201c\u5185\u7f6e\u7c7b\u578b\u201d\u548c\u201c\u7528\u6237\u81ea\u5b9a\u4e49\u7c7b\u578b\u201d\u7684\u6001\u5ea6\u622a\u7136\u4e0d\u540c\uff0c\u7eb5\u4f7f\u4e24\u8005\u6709\u76f8\u540c\u7684\u5e95\u5c42\u63cf\u8ff0(underlying representation)\u3002\u5982\u7f16\u8bd1\u5668\u4f1a\u5c06 double \u53d8\u91cf\u653e\u8fdb\u7f13\u5b58\u5668\u5185\uff0c\u5374\u62d2\u7edd\u5c06\u53ea\u542b\u4e00\u4e2a double \u6210\u5458\u53d8\u91cf\u7684\u5bf9\u8c61\u653e\u8fdb\u7f13\u5b58\u5668\u5185\uff08\u800c\u8fd9\u5b9e\u9645\u4e0a\u589e\u52a0\u4e86\u590d\u5236\u548c\u53d6\u503c\u7684\u5f00\u9500\uff09\u3002 \u7528\u6237\u81ea\u5b9a\u4e49 types \u7684\u5927\u5c0f\u662f\u4f1a\u6539\u53d8\u7684\u3002 pass-by-reference-to-const \u53ef\u4ee5\u6307\u5411 rvalue\u3002 \u6761\u6b3e21\uff1a\u5fc5\u987b\u8fd4\u56de\u5bf9\u8c61\u65f6\uff0c\u522b\u5984\u60f3\u8fd4\u56de\u5176reference \u51fd\u6570\u521b\u5efa\u65b0\u5bf9\u8c61\u6709\u4e24\u79cd\u9014\u5f84\uff1a\u5728 Stack \u6216\u5728 Heap \u4e0a\u3002 \u51fd\u6570\u5185\u521b\u9020\u7684 local \u5bf9\u8c61\u5728 Stack \u5185\uff0c\u5176\u751f\u547d\u5468\u671f\u968f\u7740\u51fd\u6570\u7684\u7ed3\u675f\u800c\u7ed3\u675f\u3002 \u901a\u8fc7 new \u65b9\u6cd5\u83b7\u5f97\u7684\u5bf9\u8c61\u5728 Heap \u5185\uff0c\u9700\u8981\u624b\u52a8\uff08\u6216\u7528\u8d44\u6e90\u7ba1\u7406\u7c7b\uff09\u7ba1\u7406\u5176\u751f\u547d\u5468\u671f\u3002 \u82e5\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u5bf9\u8c61\u7684\u5f15\u7528\uff1a \u82e5\u8be5\u5bf9\u8c61\u5efa\u7acb\u5728 Stack \u4e0a\uff0c\u8fd4\u56de\u7684\u5f15\u7528\u5219\u4f1a\u6307\u5411\u4e00\u4e2a\u5df2\u6790\u6784\u7684\u5bf9\u8c61\u3002\u8fd9\u4f1a\u5bfc\u81f4ub\u3002 \u82e5\u8be5\u5bf9\u8c61\u5efa\u7acb\u5728 Heap \u4e0a\uff0c\u5ba2\u6237\u5f88\u6709\u53ef\u80fd\u4f1a\u5fd8\u8bb0\uff0c\u751a\u81f3\u6839\u672c\u610f\u8bc6\u4e0d\u5230\u8981\u91ca\u653e\u5b83\u4eec\u3002 \u82e5\u8fd4\u56de\u8be5\u7c7b\u7684 static \u5bf9\u8c61\u7684\u5f15\u7528\uff0c\u5219\u4f1a\u53d1\u751f\u591a\u7ebf\u7a0b\u5b89\u5168\u6027\u3001\u540c\u4e00\u8bed\u53e5\u5185\u6267\u884c\u9020\u6210\u7684ub\u95ee\u9898\u3002\uff08\u8fd9\u79cd\u4f8b\u5b50\u5f88\u96be\u4e0d\u8ba9\u8bfb\u8005\u53d1\u7b11\uff0c\u8111\u6d1e\u679c\u7136\u4e0d\u4e00\u822c\uff09 \u5efa\u7acb\u4e0a\u8ff0\u5bf9\u8c61\u672c\u8eab\u4e5f\u8981\u4ed8\u51fa\u6784\u9020\u51fd\u6570\u7684\u4ee3\u4ef7\u3002 \u6761\u6b3e22\uff1a\u5c06\u6210\u5458\u53d8\u91cf\u58f0\u660e\u4e3aprivate \u8bed\u6cd5\u4e00\u81f4\u6027 \u5982\u679c\u6210\u5458\u53d8\u91cf\u90fd\u662f private \u7684\uff0c\u90a3\u4e48 public \u63a5\u53e3\u5185\u6bcf\u6837\u4e1c\u897f\u90fd\u662f\u51fd\u6570\u3002\u8fd9\u6837\u53ef\u4ee5\u65b9\u4fbf\u5ba2\u6237\u8bb0\u5fc6\uff08\u63a5\u53e3\u662f\u5426\u4e3a\u51fd\u6570\uff09\u548c\u4f7f\u7528\u3002 \u51fd\u6570\u53ef\u4ee5\u63d0\u4f9b\u5bf9\u6210\u5458\u53d8\u91cf\u66f4\u7cbe\u786e\u7684\u63a7\u5236 \u901a\u8fc7\"getter\"\u548c\"setter\"\u51fd\u6570\u63d0\u4f9b\u5bf9\u6210\u5458\u53d8\u91cf\u7684\u201c\u4e0d\u51c6\u8bbf\u95ee\u201d\u3001\u201c\u53ea\u8bfb\u8bbf\u95ee\u201d\u3001\u201c\u8bfb\u5199\u8bbf\u95ee\u201d\u751a\u81f3\u201c\u53ea\u5199\u8bbf\u95ee\u201d\u3002 \u53ef\u4ee5\u63d0\u4f9b\u66f4\u597d\u7684\u5c01\u88c5\u6027\u3002\u5ba2\u6237\u65e0\u9700\u77e5\u6653\u7c7b\u5185\u90e8\u7684\u7ec6\u8282\uff0c\u6216\u662f\u67d0\u4e2a\u53d8\u91cf\u7684\u5177\u4f53\u529f\u80fd\u3002\u7531\u5b9e\u73b0\u8005\u4fdd\u8bc1\u6210\u5458\u53d8\u91cf\u88ab\u6b63\u786e\u4f7f\u7528\u3002 \u901a\u8fc7\u51fd\u6570\u8bbf\u95ee\u6210\u5458\u53d8\u91cf\u53ef\u4ee5\u786e\u4fdd class \u7684\u7ea6\u675f\u6761\u4ef6\u4fdd\u6301\u6709\u6548\uff0c\u4e14\u4f5c\u8005\u4fdd\u7559\u4e86\u65e5\u540e\u53d8\u66f4\u7684\u6743\u5229\u3002 \u9690\u85cf\u6210\u5458\u53d8\u91cf\u53ef\u4ee5\u4e3a\u53ef\u80fd\u7684\u5b9e\u73b0\u63d0\u4f9b\u5f39\u6027\uff0c\u4e0d\u5fc5\u53d7\u5230 public \u6210\u5458\u53d8\u91cf\u53ef\u80fd\u53d7\u5230\u7684\u675f\u7f1a\uff08\u5982\u53ef\u80fd\u6539\u53d8\u5ba2\u6237\u7801\uff09\u3002 \u6210\u5458\u53d8\u91cf\u7684\u5c01\u88c5\u6027\u4e0e\u201c\u6210\u5458\u53d8\u91cf\u7684\u5185\u5bb9\u6539\u53d8\u65f6\u6240\u7834\u574f\u7684\u4ee3\u7801\u6570\u91cf\u201d\u6210\u53cd\u6bd4\u3002\u6545\u800c protected \u4f5c\u7528\u57df\u540c\u6837\u4f1a\u53d7\u5230\u5176 derived class \u7684\u675f\u7f1a\u3002 \u6240\u4ee5\uff0c\u53ea\u6709\u4e24\u79cd\u8bbf\u95ee\u6743\u9650\uff1aprivate\uff08\u63d0\u4f9b\u5c01\u88c5\uff09\u548c\u5176\u4ed6\uff08\u4e0d\u63d0\u4f9b\u5c01\u88c5\uff09\u3002 \u6761\u6b3e23\uff1a\u5b81\u4ee5non-member\u3001non-friend\u66ff\u6362member\u51fd\u6570 \u63a8\u5d07\u5c01\u88c5\u7684\u539f\u56e0\uff1a\u5b83\u4f7f\u6211\u4eec\u80fd\u591f\u6539\u53d8\u4e8b\u7269\u800c\u53ea\u5f71\u54cd\u6709\u9650\u5ba2\u6237\u3002 \u5bf9 class \u6765\u8bf4\uff0c\u90a3\u4e9b\u53ef\u4ee5\u5b8c\u5168\u8c03\u7528 public \u63a5\u53e3\u5b8c\u6210\u7684\u529f\u80fd\uff0cmember\u51fd\u6570\u7684\u5c01\u88c5\u6027\u6bd4 non-member \u548c non-friend \u51fd\u6570\u7684\u5c01\u88c5\u6027\u8981\u4f4e\uff1a \u5982\u4e0a\u4e00\u6761\u6240\u8bf4\uff0c\u51fd\u6570\u7684\u5c01\u88c5\u6027\u53ef\u4e0e\u80fd\u8bbf\u95ee\u5b83\uff08\u6539\u53d8\u5185\u5bb9\u540e\u53ef\u80fd\u4f1a\u8feb\u5bb3\uff09\u7684\u4ee3\u7801\u7684\u6570\u91cf\u6210\u53cd\u6bd4\u3002non-member \u548c non-friend \u51fd\u6570\u4e0d\u4f1a\u964d\u4f4e class \u7684\u5c01\u88c5\u6027\uff08\u4e0d\u4f1a\u6709\u8bbf\u95ee private \u53d8\u91cf\u7684\u9690\u5fe7\uff09\u3002 \u5bf9\u4e8e Java\u3001C# \u800c\u8a00\uff0c\u8be5 class \u7684 non-member \u51fd\u6570\u53ef\u4ee5\u662f\u5176\u4ed6\u7c7b\u7684 member \u51fd\u6570\uff0c\u5982\u53ef\u80fd\u662f\u53e6\u4e00\u4e2a\u5de5\u5177\u51fd\u6570\u7684 static member function\u3002\u5bf9\u4e8e C++\u6765\u8bf4\uff0c\u8f83\u81ea\u7136\u7684\u505a\u6cd5\u662f\u8ba9\u8fd9\u4e2a non-member \u51fd\u6570\u4f4d\u4e8e\u548c class \u6240\u5728\u7684\u540c\u4e00\u4e2a namespace \u5185\u3002 \u4e0a\u8ff0\u505a\u6cd5\u7684\u597d\u5904\u5728\u4e8e\uff0cnamespace \u53ef\u4ee5\u8de8\u8d8a\u591a\u4e2a\u6587\u4ef6\uff0c\u800c classes \u4e0d\u80fd\u3002\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5c06\u4e0d\u540c\u7c7b\u578b\u7684 non-member \u548c non-friend \u51fd\u6570\u58f0\u660e\u5728\u4e0d\u540c\u5934\u6587\u4ef6\u5185\uff08\u5f53\u7136\uff0c\u58f0\u660e\u5728\u548c class \u76f8\u540c\u7684 namespace \u5185\uff09\u3002\u5141\u8bb8\u5ba2\u6237\u53ea\u5bf9\u4ed6\u4eec\u6240\u7528\u7684\u90a3\u4e00\u5c0f\u90e8\u5206\u7cfb\u7edf\u5f62\u6210\u7f16\u8bd1\u76f8\u4f9d\u3002 \u58f0\u660e\u5728 namespace \u5185\u540c\u6837\u65b9\u4fbf\u4e86\u5ba2\u6237\u6839\u636e\u9700\u6c42\u6269\u5c55\u8fd9\u4e9b non-member \u548c non-friend \u51fd\u6570\u3002 \u6761\u6b3e24\uff1a\u82e5\u6240\u6709\u53c2\u6570\u7686\u9700\u8981\u7c7b\u578b\u8f6c\u6362\uff0c\u8bf7\u4ee5\u6b64\u91c7\u7528non-member\u51fd\u6570 \u53ea\u6709\u5f53\u53c2\u6570\u88ab\u5217\u4e8e\u53c2\u6570\u5217(parameter list)\u5185\uff0c\u8fd9\u4e2a\u53c2\u6570\u624d\u662f\u9690\u5f0f\u7c7b\u578b\u8f6c\u6362\u7684\u5408\u683c\u53c2\u4e0e\u8005\u3002 \u5047\u8bbe\u6211\u4eec\u8bbe\u8ba1\u4e00\u4e2a\u6709\u7406\u6570\u7c7b\uff0c\u5141\u8bb8 non-explicit \u8f6c\u6362\uff1a class Rational { public : Rational ( int numerator = 0 , int denominator = 1 ); // permit int2Ration transformation int numerator () const ; int denominator () const ; private : //details } \u82e5\u6211\u4eec\u91c7\u7528 member function of operator* \uff0c\u4ee3\u7801\u5982\u4e0b\uff1a class Rational { public : const Rational operator * ( const Rational & ); } const Rational Rational :: operator * ( const Rational & rhs ){ //details } int main (){ Rational oneQuarter ( 1 , 4 ); Rational result ; result = oneQuarter * 2 ; //valid, equal to Rational(2,1) * oneQuarter /** * The below way is invalid. * Cause the compiler called `2.operator*(const Rational &)` and failed. */ result = 2 * oneQuarter ; } \u7efc\u4e0a\uff0c\u4e3a\u4e86\u8ba9\u9690\u5f0f\u8f6c\u6362\u5bf9\u64cd\u4f5c\u7b26\uff08\u6216\u51fd\u6570\u4e24\u53c2\u6570\uff09\u90fd\u751f\u6548\uff0c\u5e94\u8be5\u5c06\u5176\u5b9a\u4e49\u4e3a\u4e00\u4e2a non-member \u7684\u51fd\u6570\u3002 const Rational operator * ( const Rational & lhs , const Rational & rhs ){ return Rational ( lhs . numerator * rhs . numerator , lhs . denominator * rhs . denominator ); } \u8fd9\u4e00\u8bbe\u8ba1\u5b88\u5219\u5728 Object-Oriented \u8bbe\u8ba1\u8303\u5f0f\u4e2d\u6709\u6548\u3002\u4f46\u5728 Template C++ \u8bbe\u8ba1\u4e2d\u5219\u8981\u8003\u8651\u65b0\u7684\u4e89\u8bae\u548c\u89e3\u6cd5\u3002\u8fd9\u4e9b\u4f1a\u5728\u7b2c46\u6761\u5efa\u8bae\u4e2d\u6307\u51fa\u3002 \u6761\u6b3e25\uff1a\u8003\u8651\u5199\u51fa\u4e00\u4e2a\u4e0d\u629b\u51fa\u5f02\u5e38\u7684swap\u51fd\u6570 swap\u51fd\u6570\u662f\u5f02\u5e38\u5b89\u5168\u6027\u7f16\u7a0b(exception-safety programming)\u7684\u810a\u67f1\uff0c\u4e5f\u662f\u7528\u6765\u5904\u7406\u81ea\u8d4b\u503c\u53ef\u80fd\u6027\u7684\u4e00\u4e2a\u5e38\u89c1\u673a\u5236\u3002 \u7f3a\u7701\u60c5\u51b5\u4e0b swap \u52a8\u4f5c\u53ef\u7531\u6807\u51c6\u5e93\u63d0\u4f9b\u7684 swap \u7b97\u6cd5\u5b8c\u6210\uff0c\u5176\u5178\u578b\u5b9e\u73b0\u5982\u4e0b\uff08\u975e\u5e38non-economical\uff09 namespace std { template < typename T > void swap ( T & a , T & b ){ T temp ( a ); a = b ; b = temp ; } } \u8fd9\u79cd swap \u7b97\u6cd5\u5728\u7279\u6b8a\u6761\u4ef6\uff0c\u5982pimpl(pointer to implementation)\u65f6\uff0c\u662f\u4f4e\u6548\u7684\u3002\u8fd9\u65f6\u5019\u5c31\u9700\u8981\u4f60\u81ea\u5df1\u8bbe\u8ba1\u4e00\u4e2a swap \u51fd\u6570\uff08\u4ea4\u6362\u6307\u9488\u6765\u53d6\u7f14\u590d\u5236\u548c\u8d4b\u503c\u51fd\u6570\u7684\u5f00\u9500\uff09\u3002 \u4e3a\u4e86\u907f\u514d\u589e\u52a0\u989d\u5916\u7684 friend \u51fd\u6570\uff0c\u53ef\u4ee5\u5728\u7c7b\u5185\u5b9e\u73b0\u4e00\u4e2a public \u7684 swap \u51fd\u6570\uff0c\u968f\u540e\u5728\u7c7b\u5916\u7684\u7279\u5316 non-member swap function \u4e2d\u8c03\u7528\u5b83\u3002 \u4f60\u53ef\u4ee5\u901a\u8fc7\u4e3a std::swap() \u51fd\u6570\u63d0\u4f9b\u7279\u5316\u7248\u672c\u6765\u63d0\u9192\u7f16\u8bd1\u5668\u8c03\u7528\u5f00\u9500\u66f4\u5c0f\u7684\u90a3\u4e2a\uff1a class Widget { public : // details void swap ( Widget & rhs ) { /* details */ } private : // details } namespace std { template <> swap < Widget > ( Widget & a , Widget & b ){ a . swap ( b ); } } C++\u53ea\u5141\u8bb8\u5bf9 class templates \u504f\u7279\u5316\uff0c\u5728 function templates \u4e0a\u4e0d\u80fd\u504f\u7279\u5316\u3002\u8fd9\u79cd\u60c5\u51b5\u4e0b\u6211\u4eec\u5c06\u7279\u5316 swap \u51fd\u6570\u5b9a\u4e49\u5728\u4e0e\u7c7b\u76f8\u540c\u7684 namespace \u5185\u3002 namespace WidgetNS { template < typename T > class Widget { /*details*/ } } // The below type is invalid // error: non-class, non-variable partial specialization \u2018swap<Widget<T> >\u2019 is not allowed namespace std { template < typename T > swap < Widget < T >> ( Widget < T > & lhs , Widget < T > & rhs ){ lhs . swap ( rhs ); } } /** * The below type is valid * And the compiler will call WidgetNS::swap first * when you declare `using namespace std` and `WidgetNS` at the same time */ namespace WidgetNS { template < typename T > void swap ( Widget < T > & lhs , Widget < T > & rhs ) { lhs . swap ( rhs ); } } \u5982\u679c\u4f60\u8c03\u7528 swap\uff0c \u8bf7\u786e\u4fdd\u5305\u542b\u4e00\u4e2a using std::swap \u58f0\u660e\u5f0f\uff0c\u8ba9 std::swap \u5728\u51fd\u6570\u5185\u53ef\u89c1\u3002\u4ee5\u4fbf\u5728\u627e\u4e0d\u5230\u7279\u5316\u7248\u672c\u65f6\u53ef\u4ee5\u8c03\u7528\u8be5\u7f3a\u7701\u51fd\u6570\u3002 \u8fd9\u6837\uff0c\u5728\u4f60\u5e0c\u671b\u8c03\u7528\u7279\u5316\u7248\u672c\uff0c\u5426\u5219\u8c03\u7528 std \u5185\u7684\u7f3a\u7701\u7248\u672c\u65f6\u5e94\u5f53\u8fd9\u6837\u505a\uff1a template < typename T > void doSomething ( T & lhs , T & rhs ){ using std :: swap ; //details swap ( lhs , rhs ); //details } \u7531\u4e8e swap \u7684\u4e00\u4e2a\u5e94\u7528\u65f6\u5e2e\u52a9 classes\uff08\u548c class templates\uff09\u63d0\u4f9b\u5f3a\u70c8\u7684\u5f02\u5e38\u5b89\u5168\u6027(exception-safety)\u4fdd\u969c\u3002\u6240\u4ee5\u5bf9\u6b64\u7684\u4e00\u4e2a\u5047\u8bbe\u662f\uff1a\u4f5c\u4e3a\u6210\u5458\u51fd\u6570\u548c\u7c7b\u7684\u7279\u5316swap\u7edd\u4e0d\u629b\u51fa\u5f02\u5e38\u3002\u8fd9\u4e00\u7279\u6027\u5f80\u5f80\u548c swap \u51fd\u6570\u7684\u9ad8\u6548\u6027\u76f8\u5173\u8054\u3002\u56e0\u4e3a\u9ad8\u6548\u7387\u7684 swap \u51fd\u6570\u51e0\u4e4e\u603b\u662f\u57fa\u4e8e\u5bf9\u5185\u7f6e\u7c7b\u578b\u7684\u64cd\u4f5c\uff0c\u800c\u8fd9\u90e8\u5206\u64cd\u4f5c\u7edd\u4e0d\u4f1a\u629b\u51fa\u5f02\u5e38\u3002 \u4f46\u6807\u51c6\u5e93\u63d0\u4f9b\u7684 std::swap \u51fd\u6570\u7531\u4e8e\u8c03\u7528\u4e86\u590d\u5236\u548c\u8d4b\u503c\u64cd\u4f5c\u7b26\u51fd\u6570\u2014\u2014\u4e00\u822c\u60c5\u51b5\u4e0b\u8fd9\u4e24\u4e2a\u51fd\u6570\u90fd\u5141\u8bb8\u629b\u51fa\u5f02\u5e38\u2014\u2014\u4e0d\u4fdd\u8bc1\u5b83\u662f\u5f02\u5e38\u5b89\u5168\u7684\u3002 \u6761\u6b3e26\uff1a\u5c3d\u53ef\u80fd\u5ef6\u540e\u53d8\u91cf\u5b9a\u4e49\u5f0f\u7684\u51fa\u73b0\u65f6\u95f4 \u6700\u597d\u5ef6\u540e\u53d8\u91cf\u5b9a\u4e49\u5f0f\u7684\u51fa\u73b0\u65f6\u95f4\uff0c\u76f4\u5230\u4f60\u771f\u7684\u9700\u8981\u5b83\u3002\u5426\u5219\u96be\u514d\u627f\u62c5\u591a\u4f59\u7684\u6784\u9020\u548c\u6790\u6784\u6210\u672c\u3002 \u5728\u5bf9\u8c61\u6784\u9020\u65f6\u671f\u5c31\u5e94\u8be5\u7ed9\u5b83\u4e00\u4e2a\u6709\u610f\u4e49\u7684\u521d\u503c\u800c\u975edefault\u6784\u9020\u51fd\u6570\u3002 \u5728\u5faa\u73af\u4e2d\uff0c\u5c06\u53d8\u91cf\u58f0\u660e\u5728\u5faa\u73af\u4e4b\u5185\u8fd8\u662f\u4e4b\u5916 \u6210\u672c\uff1a \u5faa\u73af\u4e4b\u5916\uff1a1\u4e2a\u6784\u9020\u51fd\u6570 + 1\u4e2a\u6790\u6784\u51fd\u6570 + n\u4e2a\u8d4b\u503c\u64cd\u4f5c \u5faa\u73af\u4e4b\u5185\uff1an\u4e2a\u6784\u9020\u51fd\u6570 + n\u4e2a\u6790\u6784\u51fd\u6570 \u53ef\u7ef4\u62a4\u6027\uff1a \u5b9a\u4e49\u4e8e\u5faa\u73af\u4e4b\u5916\u7684\u53d8\u91cf\u4f5c\u7528\u57df\u66f4\u5927\uff0c\u6709\u65f6\u53ef\u80fd\u5bf9\u7a0b\u5e8f\u7684\u53ef\u7406\u89e3\u6027\u548c\u6613\u7ef4\u62a4\u6027\u9020\u6210\u51b2\u7a81\u3002 \u56e0\u6b64\u4e00\u822c\u60c5\u51b5\u4e0b\u63a8\u8350\u5b9a\u4e49\u5728\u5faa\u73af\u4e4b\u5185\uff0c\u9664\u975e\uff1a \u4f60\u77e5\u9053\u8d4b\u503c\u6210\u672c\u6bd4\u201c\u6784\u9020+\u6790\u6784\u201d\u6210\u672c\u4f4e\uff1b \u4f60\u6b63\u5728\u5904\u7406\u4ee3\u7801\u4e2d\u6548\u7387\u9ad8\u5ea6\u654f\u611f(performance-sensitive)\u7684\u90e8\u5206\u3002 \u6761\u6b3e27\uff1a\u5c3d\u91cf\u5c11\u505a\u8f6c\u578b\u52a8\u4f5c C++\u89c4\u5219\u7684\u8bbe\u8ba1\u76ee\u6807\u4e4b\u4e00\u662f\uff1a\u4fdd\u8bc1\u201c\u7c7b\u578b\u9519\u8bef\u201d\u7edd\u4e0d\u53ef\u80fd\u53d1\u751f.\u7136\u800c\u8f6c\u578b(cast)\u7834\u574f\u4e86\u7c7b\u578b\u7cfb\u7edf(type system)\u3002\u76f8\u8f83C\u3001C#\u548cJava\uff0cC++\u7684\u8f6c\u578b\u66f4\u52a0\u5371\u9669\u3002 \u65e7\u5f0f\u8f6c\u578b(C-style casts)\uff1a ( T ) expression ; T ( expression ); C++\u63d0\u4f9b\u56db\u79cd\u65b0\u5f0f\u8f6c\u578b(C+-style casts)\uff1a const_cast < T > ( expression ); dynamic_cast < T > ( expression ); reinterpret_cast < T > ( expression ); static_cast < T > ( expression ); const_cast\uff1a\u7528\u4e8e\u5c06\u5bf9\u8c61\u7684\u5e38\u91cf\u6027\u8f6c\u9664(cast away the constness)\u3002 dynamic_cast\uff1a\u7528\u4e8e\u6267\u884c\u201c\u5b89\u5168\u5411\u4e0b\u8f6c\u578b\u201c(safe downcasting)\uff0c\u5b83\u5224\u65ad\u6307\u5411\u57fa\u7c7b\u7684\u6307\u9488\u662f\u5426\u5c5e\u4e8e\u4e00\u4e2a\u5b8c\u6574\u7684\u6d3e\u751f\u7c7b\uff0c\u5e76\u51b3\u5b9a\u662f\u5426\u8fdb\u884c\u7c7b\u578b\u8f6c\u6362\u3002\u5b83\u662f\u552f\u4e00\u65e0\u6cd5\u7531 C-style casts \u6267\u884c\u7684\u52a8\u4f5c\uff0c\u4e5f\u662f\u552f\u4e00\u53ef\u80fd\u8017\u8d39\u91cd\u5927\u8fd0\u884c\u6210\u672c\u7684\u8f6c\u578b\u52a8\u4f5c\u3002 reinterpret_cast\uff1a\u6267\u884c\u4f4e\u7ea7\u8f6c\u578b\uff0c\u5b9e\u9645\u52a8\u4f5c\uff08\u53ca\u7ed3\u679c\uff09\u53ef\u80fd\u53d6\u51b3\u4e8e\u7f16\u8bd1\u5668\u3002\u8fd9\u610f\u5473\u7740\u5b83\u4e0d\u53ef\u79fb\u690d\u3002\u5982\u5c06\u4e00\u4e2a pointer to int \u8f6c\u578b\u4e3a\u4e00\u4e2a int \u3002 static_cast\uff1a\u7528\u4e8e\u5f3a\u8feb\u9690\u5f0f\u8f6c\u6362(implicit conversions)\u3002 \u65b0\u5f0f\u8f6c\u578b\u7684\u4f18\u70b9\uff1a \u5f88\u5bb9\u6613\u5728\u4ee3\u7801\u4e2d\u88ab\u8fa8\u8bc6\u51fa\u6765\uff0c\u56e0\u6b64\u53ef\u4ee5\u7b80\u5316\u201d\u627e\u51fa\u7c7b\u578b\u7cfb\u7edf\u5728\u54ea\u4e2a\u5730\u70b9\u88ab\u7834\u574f\u201c\u7684\u8fc7\u7a0b \u5404\u8f6c\u578b\u52a8\u4f5c\u7684\u76ee\u6807\u7a84\u5316\uff0c\u7f16\u8bd1\u5668\u53ef\u80fd\u8bca\u65ad\u51fa\u9519\u8bef\u7684\u8fd0\u7528\u3002 \u7c7b\u578b\u8f6c\u6362\u5e76\u975e\u4e0d\u7528\u505a\u4efb\u4f55\u5de5\u4f5c\uff0c\u5982 int \u5411 double \u7c7b\u578b\u8f6c\u6362\u65f6\u9700\u8981\u66f4\u6539\u7f16\u7801\u65b9\u5f0f\u3002\u800c\u5728\u67d0\u4e9b\u65f6\u5019\u5219\u4f1a\u6d89\u53ca\u5230\u7f16\u8bd1\u5668\u7684\u5177\u4f53\u5b9e\u73b0\u7ec6\u8282(\u800c\u6709\u6240\u4e0d\u540c)\uff1a class Base { /*...*/ }; class Derived : public Base { /*...*/ }; Derived d ; Base * pb = & d ; \u5728\u4e0a\u8ff0\u4ee3\u7801\u4e2d\uff0c pb \u6240\u6307\u7684\u503c\u5e76\u4e0d\u4e00\u5b9a\u7b49\u4e8e &d \uff0c\u800c\u662f\u52a0\u4e0a\u4e86\u4e00\u4e2a\u504f\u79fb\u91cf\uff08\u60f3\u60f3\u4ec0\u4e48\u60c5\u51b5\u4e0b\u4f1a\u51fa\u73b0\u8fd9\u79cd\u60c5\u51b5\uff09\u3002\u8fd9\u4e00\u5b9e\u73b0\u65b9\u5f0f\u7531\u7f16\u8bd1\u5668\u5b9e\u73b0\u7684\u4e0d\u540c\u800c\u4e0d\u540c\u3002\u6240\u4ee5\u4e00\u822c\u60c5\u51b5\u4e0b\u6211\u4eec\u8981\u907f\u514d\u505a\u51fa\u201d\u5bf9\u8c61\u5728 C++ \u4e2d\u5982\u4f55\u5e03\u5c40\u201c\u7684\u5047\u8bbe\uff0c\u4e5f\u4e0d\u5e94\u8be5\u4ee5\u6b64\u5047\u8bbe\u4e3a\u57fa\u7840\u6267\u884c\u4efb\u4f55\u8f6c\u578b\u52a8\u4f5c\u3002 \u5bf9\u4e8evirtual\u51fd\u6570\uff0cderived classes \u901a\u8fc7\u8f6c\u578b\u6765\u8c03\u7528 base class \u7684\u51fd\u6570\u5b9e\u9645\u4e0a\u662f\u884c\u4e0d\u901a\u7684\u3002\u56e0\u4e3a\u6307\u9488\u6240\u6307\u7684\u5bf9\u8c61\u5b9e\u9645\u4e0a\u6ca1\u6709\u5dee\u522b\u3002\u5982\u679c\u60f3\u8981\u8c03\u7528 base class \u7684\u51fd\u6570\uff0c\u9700\u8981\u8fd9\u6837\u58f0\u660e\uff1a class Derived : public Base { public : virtual void ChangeSth (){ Base :: ChangeSth (); /*...*/ } /*...*/ } dynamic_cast \u7684\u8bb8\u591a\u5b9e\u73b0\u7248\u672c\u6267\u884c\u901f\u5ea6\u76f8\u5f53\u6162\uff0c\u5728\u6df1\u5ea6\u7ee7\u627f\u6216\u591a\u91cd\u7ee7\u627f\u65f6\u8fd9\u79cd\u6210\u672c\u5f00\u9500\u5c24\u751a\u3002\u6709\u4e24\u79cd\u505a\u6cd5\u53ef\u4ee5\u907f\u514d\u591a\u6b21\u4f7f\u7528 dynamic_cast \u5e26\u6765\u7684\u5927\u91cf\u5f00\u9500\uff1a \u4f7f\u7528\u5bb9\u5668\u5e76\u5728\u5176\u4e2d\u5b58\u50a8\u76f4\u63a5\u6307\u5411 derived class \u5bf9\u8c61\u7684\u6307\u9488\uff08\u901a\u5e38\u662f\u667a\u80fd\u6307\u9488\uff09\u3002\u5982\u6b64\u4fbf\u6d88\u9664\u4e86\u201c\u901a\u8fc7 base class \u63a5\u53e3\u5904\u7406\u5bf9\u8c61\u201d\u7684\u9700\u8981\u3002 \u4f46\u8fd9\u79cd\u65b9\u6cd5\u65e0\u6cd5\u7528\u4e00\u4e2a\u5bb9\u5668\u50a8\u5b58\u6307\u9488\u6307\u5411\u6240\u6709\u53ef\u80fd\u7684\u6d3e\u751f\u7c7b\u3002\u6216\u9700\u8981\u591a\u4e2a\u5bb9\u5668\uff0c\u4e14\u90fd\u5fc5\u987b\u5177\u5907\u7c7b\u578b\u5b89\u5168\u6027(type-safe)\u3002 \u5728 base class \u5185\u5b9a\u4e49 virtual \u63a5\u53e3\u3002\u8ba9\u6d3e\u751f\u7c7b\u7ee7\u627f\u800c\u975e\u8986\u76d6\u63a5\u53e3\u3002 \u6b64\u5916\uff0c\u4e00\u5b9a\u8981\u675c\u7edd\u8fde\u4e32 dynamic_cast \uff0c\u6bd4\u65b9\u8bf4\u5728\u6bcf\u4e2a if \u5206\u652f\u5185\u90fd\u8c03\u7528 dynamic_cast \u3002\u8fd9\u79cd\u505a\u6cd5\u603b\u5e94\u8be5\u7528 virtual \u51fd\u6570\u4ee3\u66ff\u4e4b\u3002 \u6761\u6b3e28\uff1a\u907f\u514d\u8fd4\u56dehandles\u6307\u5411\u5bf9\u8c61\u5185\u90e8\u6210\u5206 \u5f71\u54cd\u5bf9\u8c61\u5c01\u88c5\u6027 \u6210\u5458\u53d8\u91cf\u7684\u5c01\u88c5\u6027\u6700\u591a\u53ea\u7b49\u4e8e\u201c\u8fd4\u56de\u5176 reference\u201d\u7684\u51fd\u6570\u7684\u8bbf\u95ee\u7ea7\u522b\u3002 \u82e5 const \u6210\u5458\u51fd\u6570\u4f20\u51fa\u4e00\u4e2a reference\uff0c\u4e14\u540e\u8005\u6240\u6307\u6570\u636e\u4e0e\u5bf9\u8c61\u81ea\u8eab\u6709\u5173\u8054\uff0c\u800c\u5b83\u53c8\u88ab\u50a8\u5b58\u4e8e\u5bf9\u8c61\u4e4b\u5916\uff08\u5982\u5bf9\u8c61\u7684\u4e00\u4e2a\u6307\u9488\u6210\u5458\u53d8\u91cf\u6240\u6307\u7684\u503c\u7684reference\uff09\uff0c\u90a3\u4e48\u8fd9\u4e2a\u51fd\u6570\u7684\u8c03\u7528\u8005\u53ef\u4ee5\u4fee\u6539\u90a3\u4e2a\u6570\u636e\u3002 references\u3001pointers \u548c iterators \u90fd\u662f handles\u3002\u51fd\u6570\u8fd4\u56de\u5b83\u4eec\u90fd\u53ef\u80fd\u964d\u4f4e\u5bf9\u8c61\u5c01\u88c5\u6027\uff0c\u4e5f\u53ef\u80fd\u9020\u6210\u201c\u8c03\u7528 const \u6210\u5458\u51fd\u6570\u5374\u9020\u6210\u5bf9\u8c61\u72b6\u6001\u88ab\u66f4\u6539\u201d\u7684\u95ee\u9898\u3002 \u9020\u6210 Dangling Handles \u5982\u4fdd\u7559\u4e00\u4e2ahandle\u8d85\u8fc7\u5b83\u7684\u5bf9\u8c61\u7684\u751f\u547d\u5468\u671f\u2026\u2026 \u6761\u6b3e29\uff1a\u4e3a\u201c\u5f02\u5e38\u5b89\u5168\u201d\u800c\u52aa\u529b\u662f\u503c\u5f97\u7684 \u5f02\u5e38\u5b89\u5168\u6027\u7684\u4e24\u4e2a\u6761\u4ef6 \u5f53\u5f02\u5e38\u88ab\u629b\u51fa\u65f6\uff0c\u5e26\u6709\u5f02\u5e38\u5b89\u5168\u6027\u7684\u51fd\u6570\u4f1a\uff1a \u4e0d\u6cc4\u9732\u4efb\u4f55\u8d44\u6e90\uff1a\u4ee5\u5bf9\u8c61\u65b9\u6cd5\u7ba1\u7406\u8d44\u6e90\u3002 \u4e0d\u5141\u8bb8\u6570\u636e\u7834\u574f\u3002 \u5f02\u5e38\u5b89\u5168\u51fd\u6570(Exception-safe functions)\u63d0\u4f9b\u4ee5\u4e0b\u4e09\u4e2a\u4fdd\u8bc1\u4e4b\u4e00 \u57fa\u672c\u627f\u8bfa\uff1a\u82e5\u5f02\u5e38\u88ab\u629b\u51fa\uff0c\u7a0b\u5e8f\u5185\u7684\u4efb\u4f55\u4e8b\u7269\u4ecd\u7136\u4fdd\u6301\u5728\u6709\u6548\u72b6\u6001\u4e0b\u3002\u6ca1\u6709\u4efb\u4f55\u5bf9\u8c61\u6216\u6570\u636e\u7ed3\u6784\u4f1a\u56e0\u6b64\u88ab\u7834\u574f\uff08\u5982\u6240\u6709\u7684 class \u7ea6\u675f\u90fd\u7ee7\u7eed\u83b7\u5f97\u6ee1\u8db3\uff0c\u6216\u6240\u6709\u5bf9\u8c61\u7684\u6307\u9488\u90fd\u4e0d\u7a7a\u60ac\uff09\u3002\u4f46\u7a0b\u5e8f\u7684\u73b0\u5b9e\u72b6\u6001(exact state)\u6050\u6015\u4e0d\u53ef\u9884\u6599\u3002\u5982\u629b\u51fa\u5f02\u5e38\u540e\u5bf9\u8c61\u53d8\u6210\u7f3a\u7701\u503c\u3002\u987e\u5ba2\u53ef\u80fd\u5fc5\u987b\u8c03\u7528\u67d0\u4e2a\u6210\u5458\u51fd\u6570\u624d\u77e5\u9053\u5bf9\u8c61\u5b9e\u9645\u4e0a\u53d8\u6210\u4e86\u4ec0\u4e48\uff08\u5c3d\u7ba1\u5bf9\u8c61\u4f9d\u7136\u662f\u5408\u6cd5\u7684\uff09\u3002 \u5f3a\u70c8\u4fdd\u8bc1\uff1a\u5982\u679c\u5f02\u5e38\u88ab\u629b\u51fa\uff0c\u7a0b\u5e8f\u72b6\u6001\u4e0d\u6539\u53d8\u3002\u8c03\u7528\u8fd9\u6837\u7684\u51fd\u6570\u6709\u4e24\u79cd\u7ed3\u679c\uff1a\u51fd\u6570\u6267\u884c\u5b8c\u5168\u6210\u529f\uff1b\u6216\u662f\u629b\u51fa\u5f02\u5e38\u540e\u7a0b\u5e8f\u4f1a\u56de\u590d\u5230\u201c\u8c03\u7528\u51fd\u6570\u4e4b\u524d\u201d\u7684\u72b6\u6001\u3002 \u4e0d\u629b\u63b7(nothrow)\u4fdd\u8bc1\uff1a\u627f\u8bfa\u7edd\u4e0d\u629b\u51fa\u5f02\u5e38\uff0c\u56e0\u4e3a\u5b83\u4eec\u603b\u662f\u80fd\u591f\u5b8c\u6210\u5b83\u4eec\u539f\u5148\u627f\u8bfa\u7684\u529f\u80fd\u3002\u4f5c\u7528\u4e8e\u5185\u7f6e\u7c7b\u578b\uff08\u5982 int \uff0c\u6307\u9488\u7b49\u7b49\uff09\u8eab\u4e0a\u7684\u6240\u6709\u64cd\u4f5c\u90fd\u63d0\u4f9b nothrow \u4fdd\u8bc1\u3002\u8fd9\u662f\u5f02\u5e38\u5b89\u5168\u4ee3\u7801(Exception-safe code)\u4e2d\u4e00\u4e2a\u5fc5\u4e0d\u53ef\u5c11\u7684\u5173\u952e\u57fa\u7840\u6750\u6599\u3002 \u5bf9\u5f3a\u70c8\u4fdd\u8bc1\u7684\u8ba8\u8bba \u4e00\u79cd\u63d0\u4f9b \u5f3a\u70c8\u4fdd\u8bc1 \u7684\u65b9\u5f0f\u662f copy and swap\uff1a\u4e3a\u4f60\u6253\u7b97\u4fee\u6539\u7684\u5bf9\u8c61\uff08\u539f\u4ef6\uff09\u505a\u51fa\u4e00\u4e2a\u526f\u672c\uff0c\u7136\u540e\u5728\u526f\u672c\u4e0a\u505a\u4e00\u5207\u5fc5\u8981\u4fee\u6539\u3002\u82e5\u4efb\u4f55\u4fee\u6539\u52a8\u4f5c\u629b\u51fa\u5f02\u5e38\uff0c\u539f\u5bf9\u8c61\u4ecd\u7136\u4fdd\u6301\u672a\u6539\u53d8\u72b6\u6001\u3002\u5f85\u6240\u6709\u6539\u53d8\u90fd\u6210\u529f\u540e\uff0c\u518d\u5c06\u4fee\u6539\u8fc7\u7684\u90a3\u4e2a\u526f\u672c\u548c\u539f\u5bf9\u8c61\u5728\u4e00\u4e2a\u4e0d\u629b\u51fa\u5f02\u5e38\u7684\u64cd\u4f5c\u4e2d\u7f6e\u6362(swap)\u3002\uff08\u53ef\u53c2\u7167\u6761\u6b3e25\uff09 \u5b9e\u73b0\u4e0a\u901a\u5e38\u662f\u5c06\u6240\u6709\u201c\u96b6\u5c5e\u5bf9\u8c61\u7684\u6570\u636e\u201d\u4ece\u539f\u5bf9\u8c61\u653e\u8fdb\u53e6\u4e00\u4e2a\u5bf9\u8c61\uff08\u4e00\u822c\u4e3a struct \uff0c\u56e0\u4e3a\u6570\u636e\u7684\u5c01\u88c5\u6027\u5df2\u7ecf\u7531 private scope \u4fdd\u8bc1\u4e86\u3002\u5c06\u6570\u636e\u653e\u5728 struct \u5185\u6709\u52a9\u4e8e\u7c7b\u6210\u5458\u65b9\u6cd5\u76f4\u63a5\u8c03\u7528\u5b83\u4eec\uff09\u5185\uff0c\u7136\u540e\u8d4b\u4e88\u539f\u5bf9\u8c61\u4e00\u4e2a\u6307\u9488\uff0c\u6307\u5411\u90a3\u4e2a\u5b9e\u73b0\u5bf9\u8c61(implement object)\u3002\u8fd9\u79cd\u624b\u6cd5\u5e38\u88ab\u79f0\u4e3a pimpl idiom\u3002 \u8fde\u5e26\u5f71\u54cd(side effects) \u8fd9\u79cd copy-and-swap \u7b56\u7565\u662f\u5bf9\u5bf9\u8c61\u72b6\u6001\u505a\u51fa\u201c\u5168\u6709\u6216\u5168\u65e0\u201d\u6539\u53d8\u7684\u4e00\u4e2a\u5f88\u597d\u529e\u6cd5\uff0c\u4f46\u4e00\u822c\u800c\u8a00\u5b83\u5e76\u4e0d\u4fdd\u8bc1\u6574\u4e2a\u51fd\u6570\u6709\u5f3a\u70c8\u7684\u5f02\u5e38\u5b89\u5168\u6027\u3002\u8003\u8651\u4e00\u4e2a\u4f7f\u7528 copy-and-swap \u7b56\u7565\u7684\u51fd\u6570 someFuc \uff0c \u4f46\u8be5\u51fd\u6570\u5185\u8fd8\u5305\u62ec\u5bf9\u53e6\u5916\u4e24\u4e2a\u51fd\u6570 f1 \u548c f2 \u7684\u8c03\u7528\u3002\u5176\u4e2d f1 \u548c f2 \u51fd\u6570\u7ba1\u7406\u4e00\u90e8\u5206 non-local data\uff1a void someFuc (){ /*\u5bf9 local \u72b6\u6001\u505a\u4e00\u4efd\u526f\u672c*/ f1 (); f2 (); /*\u5c06\u4fee\u6539\u540e\u7684\u72b6\u6001\u7f6e\u6362\u8fc7\u6765*/ } \u5982\u679c f1 \u548c f2 \u7684\u5f02\u5e38\u5b89\u5168\u6027\u6bd4\u201c\u5f3a\u70c8\u4fdd\u8bc1\u201d\u4f4e\uff0c\u5c31\u5f88\u96be\u8ba9 someFuc \u6210\u4e3a\u201c\u5f3a\u70c8\u5f02\u5e38\u5b89\u5168\u201d\u3002 \u5373\u4f7f f1 \u548c f2 \u90fd\u662f\u201c\u5f3a\u70c8\u4fdd\u8bc1\u201d\u7684\uff0c\u6211\u4eec\u4ecd\u7136\u4e0d\u80fd\u4fdd\u8bc1 someFuc \u7684\u5f02\u5e38\u5b89\u5168\u6027\u3002\u4f8b\u5982 f1 \u6b63\u5e38\u6267\u884c\uff08\u5df2\u7ecf\u6539\u53d8\u4e86\u7a0b\u5e8f\u72b6\u6001\uff09\u4f46 f2 \u629b\u51fa\u5f02\u5e38\u3002 \u6548\u7387 copy \u548c swap \u52a8\u4f5c\u4f1a\u8017\u8d39\u53ef\u80fd\u65e0\u6cd5\uff08\u6216\u4e0d\u613f\uff09\u4ed8\u51fa\u7684\u8d44\u6e90\u3002 \u5f53\u201c\u5f3a\u70c8\u4fdd\u8bc1\u201d\u4e0d\u5207\u5b9e\u9645\u65f6\uff0c\u5fc5\u987b\u63d0\u4f9b\u201c\u57fa\u672c\u4fdd\u8bc1\u201d\u3002\u5426\u5219\uff0c\u5f53\u7cfb\u7edf\u91cc\u6709\u4e00\u4e2a\u51fd\u6570\u4e0d\u5177\u5907\u5f02\u5e38\u5b89\u5168\u6027\uff0c\u5219\u6574\u4e2a\u7cfb\u7edf\u90fd\u4e0d\u5177\u5907\u5f02\u5e38\u5b89\u5168\u6027\u3002 \u6761\u6b3e30\uff1a\u900f\u5f7b\u4e86\u89e3inline\u7684\u91cc\u91cc\u5916\u5916 \u4f18\u70b9 inline \u51fd\u6570\u6ca1\u6709\u51fd\u6570\u8c03\u7528\u7684\u635f\u5931\uff08\u5982context\u5165\u6808\u7b49\uff09\uff0c\u800c\u4e14\u65b9\u4fbf\u7f16\u8bd1\u5668\u5bf9\u5b83\u6267\u884c\u8bed\u5883\u76f8\u5173\u6700\u4f18\u5316\u3002 \u53ea\u56e0\u8be5\u5e94\u8be5\u5bf9\u7a0b\u5e8f\u8c03\u7528\u6700\u591a\uff08\u8fd9\u79cd\u51fd\u6570\u5e94\u8be5\u6781\u81f4\u4f18\u5316\uff09\u3001\u6216\u662f\u5341\u5206\u5e73\u6de1\u65e0\u5947\u4e00\u5b9a\u8981\u8bbe\u4e3a inline \u7684\u51fd\u6570\u7533\u8bf7 inline\u3002 \u7f3a\u70b9 inline \u51fd\u6570\u7684\u89c2\u5ff5\u662f\uff0c\u5c06\u201c\u5bf9\u6b64\u51fd\u6570\u7684\u6bcf\u4e00\u4e2a\u8c03\u7528\u201d\u90fd\u4ee5\u51fd\u6570\u672c\u4f53\u66ff\u4ee3\u3002\u8fd9\u6837\u505a\u53ef\u80fd\u4f1a\u589e\u52a0\u76ee\u6807\u7801(object code)\u7684\u5927\u5c0f\u3002\u5728\u5185\u5b58\u6709\u9650\u7684\u673a\u5668\u4e0a\uff0c\u8fc7\u5ea6\u8ffd\u6c42inlining \u4f1a\u9020\u6210\u7a0b\u5e8f\u4f53\u79ef\u592a\u5927\u3002\u5373\u4f7f\u62e5\u6709\u865a\u5185\u5b58\uff0c inline \u9020\u6210\u7684\u4ee3\u7801\u81a8\u80c0\u4e5f\u4f1a\u5bfc\u81f4\u989d\u5916\u7684\u6362\u9875\u884c\u4e3a(paging)\u3002\u964d\u4f4e\u6307\u4ee4\u9ad8\u901f\u7f13\u5b58\u88c5\u7f6e\u7684\u51fb\u4e2d\u7387(instruction cache hit rate)\uff0c\u4ee5\u53ca\u4f34\u968f\u800c\u6765\u7684\u6548\u7387\u635f\u5931\u3002 inline \u51fd\u6570\u4e0d\u4f1a\u968f\u7740\u7a0b\u5e8f\u5347\u7ea7\u800c\u5347\u7ea7\u3002\u5982\u4e00\u4e2a\u5e93\u51fd\u6570\u6539\u53d8\u4e00\u4e2a inline \u51fd\u6570 f \uff0c\u5219\u6240\u6709\u5ba2\u6237\u7a0b\u5e8f\u90fd\u8981\u91cd\u65b0\u7f16\u8bd1\u3002\u5426\u5219\u4ec5\u9700\u91cd\u65b0\u8fde\u63a5\u5373\u53ef\u3002 \u4ece\u7a0b\u5e8f\u5f00\u53d1\u89d2\u5ea6\uff0c inline \u51fd\u6570\u7531\u4e8e\u5b9e\u9645\u4e0a\u4e0d\u5b58\u5728\u51fd\u6570\u4f53\uff0c\u6240\u4ee5\u96be\u4ee5\u8c03\u8bd5\uff08\u65e0\u6cd5\u6253\u65ad\u70b9\u7b49\uff09\u3002 inline \u51fd\u6570\u901a\u5e38\u4e00\u5b9a\u88ab\u7f6e\u4e8e\u5934\u6587\u4ef6\u5185\u3002\u56e0\u4e3a\u5927\u591a\u6570\u5efa\u7f6e\u73af\u5883(build environments)\u5728\u7f16\u8bd1\u8fc7\u7a0b\u4e2d\u8fdb\u884c inlining \u884c\u4e3a\u3002\u6240\u4ee5\u7f16\u8bd1\u5668\u9700\u8981\u77e5\u9053\u5b83\u957f\u4ec0\u4e48\u6837\u5b50\u3002 inline \u662f\u5bf9\u7f16\u8bd1\u5668\u7684\u4e00\u4e2a\u7533\u8bf7\uff0c\u6709\u9690\u5f0f\u548c\u663e\u793a\u4e24\u79cd\u65b9\u5f0f\uff1a \u9690\u5f0f\uff1a\u5c06\u51fd\u6570\u5b9a\u4e49\u4e8e class \u4f53\u5185\uff08\u800c\u975e\u5728 class \u5185\u58f0\u660e\u5728 class \u5916\u5b9a\u4e49\uff09\u3002 \u663e\u5f0f\uff1a\u5728\u51fd\u6570\u58f0\u660e\u5f0f\u524d\u52a0 inline \u3002 \u4f46\u8be5\u51fd\u6570\u5b9e\u9645\u4e0a\u4f1a\u4e0d\u4f1a\u88ab\u7f16\u8bd1\u4e3a\u4e00\u4e2a inline \u51fd\u6570\u5b9e\u9645\u4e0a\u53d6\u51b3\u4e8e\u7f16\u8bd1\u5668\u3002\u7f16\u8bd1\u5668\u4f1a\u62d2\u7edd inlining \u6cf0\u56fd\u590d\u6742\u7684\u51fd\u6570\uff08\u5982\u5e26\u6709\u5faa\u73af\u6216\u9012\u5f52\uff09\u3002\u800c\u6240\u6709 virtual \u51fd\u6570\u7684 inline \u7533\u8bf7\u90fd\u4f1a\u88ab\u62d2\u7edd\uff08\u56e0\u4e3a virtual \u51fd\u6570\u7684\u8c03\u7528\u662f\u5728\u8fd0\u884c\u671f\u95f4\u51b3\u5b9a\u7684\uff09\u3002 \u82e5\u7a0b\u5e8f\u8981\u53d6\u67d0\u4e2a inline \u51fd\u6570\u7684\u6307\u9488\uff0c\u5219\u7f16\u8bd1\u5668\u4f1a\u4e3a\u8fd9\u4e2a\u51fd\u6570\u751f\u6210\u4e00\u4efd outline \u7684\u672c\u4f53\u3002\u800c\u5728\u8c03\u7528\u5b83\u7684\u51fd\u6570\u4f53\u5185\u8fdb\u4e0d\u8fdb\u884c inlining \u53d6\u51b3\u4e8e\u7f16\u8bd1\u5668\u3002 \u6784\u9020\u548c\u6790\u6784\u51fd\u6570\u4e0d\u662f\u597d\u7684 inlining \u5bf9\u8c61\u3002\u56e0\u4e3a\u5f88\u96be\u786e\u5b9a\u7f16\u8bd1\u5668\u4f1a\u4e3a\u8fd9\u4e24\u4e2a\u51fd\u6570\u586b\u5145\u4ec0\u4e48\u5185\u5bb9\u3002\u800c\u4e14\u591a\u7ee7\u627f\u7684 inline \u51fd\u6570\u4e00\u5b9a\u4f1a\u9020\u6210\u5bf9\u8c61\u7801\u7684\u81a8\u80c0\u3002 \u6761\u6b3e31\uff1a\u5c06\u6587\u4ef6\u95f4\u7684\u7f16\u8bd1\u4f9d\u5b58\u5173\u7cfb\u964d\u81f3\u6700\u4f4e \u4ee5\u201c\u58f0\u660e\u7684\u4f9d\u5b58\u6027\u201d\u4ee3\u66ff\u201c\u5b9a\u4e49\u7684\u4f9d\u5b58\u6027\u201d\uff1a\u73b0\u5b9e\u4e2d\u8ba9\u5934\u6587\u4ef6\u5c3d\u53ef\u80fd\u81ea\u6211\u6ee1\u8db3\uff0c\u5426\u5219\u8ba9\u5b83\u4e0e\u5176\u4ed6\u6587\u4ef6\u5185\u7684\u58f0\u660e\u5f0f\uff08\u800c\u975e\u5b9a\u4e49\u5f0f\uff09\u76f8\u4f9d\u3002\u8fd9\u4e2a\u7b56\u7565\u5305\u542b\u4ee5\u4e0b\u5185\u5bb9\uff1a \u5982\u679c\u4f7f\u7528 object references \u6216 object pointers \u53ef\u4ee5\u5b8c\u6210\u4efb\u52a1\uff0c\u5c31\u4e0d\u8981\u4f7f\u7528 objects\u3002 \u6211\u4eec\u53ef\u4ee5\u53ea\u9760\u4e00\u4e2a\u7c7b\u578b\u58f0\u660e\u5f0f\u5c31\u5b9a\u4e49\u51fa\u6307\u5411\u8be5\u7c7b\u578b\u7684 references \u548c pointers\u3002\u5982\u679c\u5b9a\u4e49\u67d0\u7c7b\u578b\u7684 objects\uff0c \u5c31\u9700\u8981\u7528\u5230\u8be5\u7c7b\u578b\u7684\u5b9a\u4e49\u5f0f\u3002 \u5982 pimpl idiom \u8bbe\u8ba1\u6a21\u5f0f\u3002\u5c06\u63a5\u53e3\u7c7b\u9700\u8981\u7684\u6210\u5458\u53d8\u91cf\u5c01\u88c5\u5230\u4e00\u4e2a\u5b9e\u73b0\u7c7b(ClassImpl)\u5185\uff0c\u518d\u8ba9\u63a5\u53e3\u7c7b\u5185\u53ea\u542b\u4e00\u4e2a\u6307\u5411\u8be5\u5b9e\u73b0\u7c7b\u7684\u6307\u9488\u6210\u5458\u3002\u8fd9\u6837\u5c31\u5b9e\u73b0\u4e86\u201c\u63a5\u53e3\u4e0e\u5b9e\u73b0\u5206\u79bb\u201d\u3002 \u53e6\u4e00\u79cd\u65b9\u5f0f\u662f\u5728\u5934\u6587\u4ef6\u4e2d\u4ee5 interface class \u4ee3\u66ff class \u7684\u5177\u4f53\u5b9e\u73b0\u3002 \u5982\u679c\u53ef\u4ee5\u7684\u8bdd\uff0c\u5c3d\u91cf\u4ee5 class \u58f0\u660e\u5f0f\u66ff\u6362 class \u5b9a\u4e49\u5f0f\u3002 \u4e3a\u58f0\u660e\u5f0f\u548c\u5b9a\u4e49\u5f0f\u63d0\u4f9b\u4e0d\u540c\u7684\u5934\u6587\u4ef6\u3002 \u4e3a\u58f0\u660e\u5f0f\u63d0\u4f9b\u5355\u72ec\u7684\u5934\u6587\u4ef6\u800c\u975e\u5728\u4e0d\u540c\u5b9e\u73b0\u6587\u4ef6\u4e2d\u524d\u7f6e\u58f0\u660e\u82e5\u5e72\u51fd\u6570\u3002\u53ea\u542b\u5934\u6587\u4ef6\u7684\u6587\u4ef6\u540d\u5efa\u8bae\u4e3a\"<\u5e93\u540d>fwd.h\"\u3002\u8fd9\u79cd\u547d\u540d\u65b9\u5f0f\u6765\u6e90\u4e8e\u6807\u51c6\u5e93\u7684\"<iosfwd>\"\uff0c\u5b83\u5185\u542b iostream \u5404\u7ec4\u4ef6\u7684\u58f0\u660e\u5f0f\u3002 \u5b9a\u4e49\u5f0f\u5934\u6587\u4ef6\u4e00\u65b9\u9762\u4e3a\u5ba2\u6237\u5b9a\u4e49\u63a5\u53e3\uff0c\u53e6\u4e00\u65b9\u9762\u7528\u4e8e\u94fe\u63a5\u6e90\u6587\u4ef6\u3002 \u67d0\u4e9b\u5efa\u7f6e\u73af\u5883(build environments)\u5141\u8bb8\u5c06 template \u5b9a\u4e49\u5f0f\u653e\u5728\u201c\u975e\u5934\u6587\u4ef6\u201d\u5185\u3002\u8fd9\u6837\u5c31\u53ef\u4ee5\u5c06\u201c\u53ea\u542b\u58f0\u660e\u5f0f\u201d\u7684\u5934\u6587\u4ef6\u63d0\u4f9b\u7ed9 templates\u3002 \u6761\u6b3e32\uff1a\u786e\u5b9a\u4f60\u7684public\u7ee7\u627f\u5851\u6a21\u51fais-a\u5173\u7cfb \u516c\u5f00\u7ee7\u627f(public inheritance)\u610f\u5473\u7740\u201c\u662f\u4e00\u79cd(is a)\u201c\u7684\u5173\u7cfb\u3002\u82e5 Derived class D \u516c\u5f00\u7ee7\u627f\u4e86 Base class B\uff0c\u8fd9\u610f\u5473\u7740\u6bcf\u4e00\u4e2a\u7c7b\u578b D \u7684\u5bf9\u8c61\u540c\u65f6\u4e5f\u662f\u4e00\u4e2a\u7c7b\u578b B \u7684\u5bf9\u8c61\u3002\u53cd\u4e4b\u5219\u4e0d\u7136\u3002 \u5728\u8fdb\u884c\u62bd\u8c61\u65f6\u4e00\u5b9a\u8981\u8bbe\u8ba1\u597d\u4e0d\u540c\u57fa\u7c7b\u7684\u5f02\u540c\u3002\u5982\uff1a\u4f01\u9e45\u662f\u9e1f\uff0c\u4f01\u9e45\u4e0d\u4f1a\u98de\u3002\u90a3\u4e48\u82e5\u4f01\u9e45\u7c7b(Penguin)\u7ee7\u627f\u7684\u9e1f\u7c7b(Bird)\u4e0d\u5e94\u8be5\u6709\u98de\u884c\u7684\u63a5\u53e3\u3002\u5982\u679c\u9700\u8981\u5f3a\u8c03\u662f\u5426\u53ef\u4ee5\u98de\u884c\uff0c\u5e94\u5f53\u518d\u8bbe\u7f6e\u4e24\u4e2a\u4e2d\u95f4\u7c7b\uff1a\u4f1a\u98de\u7684\u9e1f \u548c \u4e0d\u4f1a\u98de\u7684\u9e1f\u7ee7\u627f\u81ea\u9e1f\u7c7b\u3002\u5e76\u8ba9\u201d\u71d5\u5b50\u201c\u548c\u201d\u4f01\u9e45\u201c\u5206\u522b\u7ee7\u627f\u81ea\u4e2d\u95f4\u7c7b\u3002 \u6761\u6b3e33\uff1a\u907f\u514d\u906e\u63a9\u7ee7\u627f\u800c\u6765\u7684\u540d\u79f0 \u5185\u5c42\u4f5c\u7528\u57df\u7684\u540d\u79f0\u4f1a\u906e\u853d\u5916\u56f4\u4f5c\u7528\u57df\u7684\u540d\u79f0\u3002 \u7f16\u8bd1\u5668\u770b\u5230\u540d\u79f0\u540e\uff0c\u5fc5\u987b\u4f30\u7b97\u5b83\u6307\u6d89(refer to)\u4ec0\u4e48\u4e1c\u897f\u3002\u7f16\u8bd1\u5668\u4f1a\u7531\u5185\u5230\u5916\u4f9d\u6b21\u67e5\u627e\u6bcf\u5c42\u4f5c\u7528\u57df\uff0c\u76f4\u5230\u627e\u5230\u8be5\u540d\u79f0\u4e3a\u6b62\u3002 Derived Class \u6210\u5458\u7684\u4f5c\u7528\u57df\u5728 Base Class \u4f5c\u7528\u57df\u4e4b\u5185\u3002 \u63a5\u4e0b\u6765\uff0c\u8ba9\u6211\u4eec\u8003\u8651\u4ee5\u4e0b\u60c5\u51b5: class Base { public : virtual void m1 () = 0 ; virtual void m1 ( int ); }; class Derived : public Base { public : virtual void m1 () override ; }; int main (){ Derived D ; D . m1 ( 3 ); //error: no matching function for call to \u2018Derived::m1(int) } \u8fd9\u662f\u56e0\u4e3a Derived class \u5bf9\u51fd\u6570 m1() \u7684\u91cd\u8f7d\u8986\u76d6\u4e86 Base class \u7684\u51fd\u6570\u540d\u3002\u800c\u7f16\u8bd1\u5668\u5728 Derived class scope \u5185\u627e\u4e0d\u5230\u5339\u914d\u7684\u51fd\u6570\u3002\u8fd9\u79cd\u60c5\u51b5\u6709\u4e24\u79cd\u89e3\u51b3\u65b9\u6848\uff1a 1. \u4f7f\u5916\u90e8\u4f5c\u7528\u57df\u540d\u79f0\u5bf9\u5185\u90e8\u4f5c\u7528\u57df\u53ef\u89c1 class Derived : public Base { public : using Base :: m1 ; virtual void m1 () override ; }; \u4f7f\u7528\u8f6c\u4ea4\u51fd\u6570(forwarding function) class Derived : public Base { public : virtual void m1 () override ; virtual void m1 ( int x ) override { Base :: m1 ( x ); } }; \u6761\u6b3e34\uff1a\u533a\u5206\u63a5\u53e3\u7ee7\u627f\u548c\u5b9e\u73b0\u7ee7\u627f \u516c\u5f00\u7ee7\u627f\u603b\u662f\u4f1a\u7ee7\u627f\u6210\u5458\u63a5\u53e3\u3002 \u58f0\u660e\u4e00\u4e2a pure virtual \u51fd\u6570\u7684\u76ee\u7684\u662f\u4e3a\u4e86\u8ba9 derived classes \u53ea\u7ee7\u627f\u51fd\u6570\u63a5\u53e3\u3002 \u58f0\u660e\u7b80\u6734\u7684 impure virtual \u51fd\u6570\u7684\u76ee\u7684\uff0c\u662f\u8ba9 derived classes \u7ee7\u627f\u8be5\u51fd\u6570\u7684\u63a5\u53e3\u548c\u7f3a\u7701\u5b9e\u73b0\u3002 \u4e3a\u4e86\u907f\u514d\u7f3a\u7701\u884c\u4e3a\u9020\u6210\u4e0d\u53ef\u9884\u77e5\u7684\u7ed3\u679c\uff0c\u53ef\u4ee5\u9009\u62e9\u5c06\u63a5\u53e3\u5b9a\u4e49\u4e3a pure virtual function\u3002\u5e76\u5c06\u7f3a\u7701\u5b9e\u73b0\u653e\u5728\u4e00\u4e2a protected \u4f5c\u7528\u57df\u5185\u3002\u6d3e\u751f\u7c7b\u9700\u8981\u8c03\u7528\u7f3a\u7701\u884c\u4e3a\uff0c\u5c31\u5fc5\u987b\u663e\u793a\u5730\u8c03\u7528\u7f3a\u7701\u5b9e\u73b0\u3002 \u5141\u8bb8\uff08\u5728\u7c7b\u5916\uff09\u5b9e\u73b0 pure virtual function\u3002\u4f46\u9700\u8981\u663e\u793a\u5730\u8c03\u7528\u8be5\u51fd\u6570\u3002\u53ef\u4ee5\u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\u8ba9\u6d3e\u751f\u7c7b\u663e\u793a\u5730\u8c03\u7528\u8be5\u51fd\u6570\u3002\u4f46\u8fd9\u79cd\u505a\u6cd5\u5c01\u88c5\u6027\u4e0d\u5982\u4e0a\u4e00\u79cd\uff08\u7f3a\u7701\u5b9e\u73b0\u516c\u5f00\u7ed9\u6d3e\u751f\u7c7b\u7684\u5ba2\u6237\u4e86\uff09\u3002 class Base { public : virtual void doSth () = 0 ; }; void Base::doSth (){ /* details */ } class Derived : public Base { virtual void doSth (){ Base :: doSth (); // explicit calling function // inlining calling function } } \u58f0\u660e non-virtual \u51fd\u6570\u7684\u76ee\u7684\u662f\u4e3a\u4e86\u4ee4 derived classes \u7ee7\u627f\u51fd\u6570\u7684\u63a5\u53e3\u53ca\u4e00\u4efd\u5f3a\u5236\u6027\u5b9e\u73b0\u3002 \u6761\u6b3e35\uff1a\u8003\u8651virtual\u51fd\u6570\u4ee5\u5916\u7684\u5176\u4ed6\u9009\u62e9 \u7531 Non-Virtual Interface(NVI) \u624b\u6cd5\u5b9e\u73b0 Template Method \u6a21\u5f0f NVI\uff1a\u4ee4\u5ba2\u6237\u901a\u8fc7 public non-virtual \u6210\u5458\u51fd\u6570\u95f4\u63a5\u8c03\u7528 private virtual \u51fd\u6570\u3002\u5b83\u662f Template Method \u8bbe\u8ba1\u6a21\u5f0f\u7684\u4e00\u4e2a\u72ec\u7279\u8868\u73b0\u5f62\u5f0f\u3002 \u8fd9\u79cd\u6d41\u6d3e\u4e3b\u5f20 virtual \u51fd\u6570\u5e94\u8be5\u51e0\u4e4e\u603b\u662f private\u3002\u4ed6\u4eec\u5efa\u8bae\uff0c\u8f83\u597d\u7684\u8bbe\u8ba1\u662f Base class \u4fdd\u7559\u4e00\u4efd non-virtual \u7684\u63a5\u53e3\uff0c \u5e76\u8c03\u7528\u5728 private/protected \u4f5c\u7528\u57df\u5185\u5b9e\u73b0\u7684 virtual \u51fd\u6570\u3002 class Base { public : void doSth (){ /* Do some pre-work */ realDoSth (); // Do the real work /* do some post-work */ } private : virtual void realDoSth (); }; NVI \u624b\u6cd5\u7684\u4e00\u4e2a\u4f18\u70b9\u662f\uff0c\u5b83\u5f3a\u5236\u505a\u4e86 pre-work \u548c post-work\uff08\u5982\u52a0\u9501\u3001\u8bb0\u5f55\u65e5\u5fd7\u7b49\uff09\u3002Derived class \u53ea\u9700\u8981\u6ce8\u610f\u5b9e\u73b0\u90a3\u4e9b\u771f\u6b63\u9700\u8981\u6539\u53d8\u7684\u4e8b\u60c5\u5373\u53ef\u3002 \u85c9\u7531 Function Pointers \u5b9e\u73b0 Strategy \u6a21\u5f0f \u7531\u4e00\u4e2a\u6307\u5411\u51fd\u6570\u7684\u6307\u9488\u5b8c\u6210\u4e0d\u540c\u5bf9\u8c61\u7684\u64cd\u4f5c\u3002 \u85c9\u7531 std::function \u7c7b\u5b8c\u6210 Strategy \u6a21\u5f0f std :: function < int ( const ClassType & ) > \u4e0a\u8ff0\u7c7b\u63a5\u53d7\u5e76\u4fdd\u5b58\u4e00\u5207\u6ee1\u8db3\u201c\u63a5\u6536\u4e00\u4e2a ClassType \u5f15\u7528\u5e76\u8fd4\u56de\u4e00\u4e2a int \u503c\u201d\u7684\u53ef\u8c03\u7528\u7269(callable entity)\u3002\u5305\u62ec\u51fd\u6570\u6307\u9488\u3001\u51fd\u6570\u5bf9\u8c61\u6216\u6210\u5458\u51fd\u6570\u6307\u9488\u3002 \u6761\u6b3e36\uff1a\u7edd\u4e0d\u91cd\u65b0\u5b9a\u4e49\u7ee7\u627f\u800c\u6765\u7684non-virtual\u51fd\u6570 non-virtual \u51fd\u6570\u662f\u9759\u6001\u7684\u3002\u6545\u800c\u65e0\u6cd5\u5e94\u7528\u51fd\u6570\u7684\u591a\u6001\u6027\u3002 non-virtual \u51fd\u6570\u4e00\u822c\u4e0d\u88ab\u8bbe\u7f6e\u4e3a\u53ef\u91cd\u8f7d\u7684\uff08\u5426\u5219\u5c31\u7528 virtual \u4e86\uff09 \u6761\u6b3e37\uff1a\u7edd\u4e0d\u91cd\u65b0\u5b9a\u4e49\u7ee7\u627f\u800c\u6765\u7684\u7f3a\u7701\u53c2\u6570\u503c virtual \u51fd\u6570\u662f\u52a8\u6001\u7ed1\u5b9a(dynamically bound)\uff0c\u800c\u7f3a\u7701\u53c2\u6570\u503c\u662f\u9759\u6001\u7ed1\u5b9a(statically bound)\u3002 class Base { public : enum Color { BLUE , GREEN , RED }; virtual void draw ( Color c = GREEN ){ cout << c << endl ; } }; class Derived : public Base { public : virtual void draw ( Color c = RED ){ cout << c << endl ; } }; int main (){ Base * pb = new Derived (); Derived * pd = new Derived (); pb -> draw (); pd -> draw (); } \u6267\u884c\u7ed3\u679c\u4e3a\uff1a 1 2 \u82e5\u60f3\u8ba9\u7c7b\u7684\u6240\u6709\u7ee7\u627f\u51fd\u6570\u90fd\u83b7\u5f97\u76f8\u540c\u7684\u7f3a\u7701\u503c\uff0c\u4e0d\u5e94\u5f53\u8ba9\u6bcf\u4e2a\u7ee7\u627f\u7c7b\u548c\u7ee7\u627f\u51fd\u6570\u90fd\u7ed9\u4e88\u540c\u6837\u7684\u9ed8\u8ba4\u53c2\u6570\u3002\u8fd9\u6837\u4e00\u65b9\u9762\u4f1a\u9020\u6210\u4ee3\u7801\u91cd\u590d\uff0c\u53e6\u4e00\u65b9\u9762\u82e5\u57fa\u7c7b\u9ed8\u8ba4\u53c2\u6570\u6709\u66f4\u6539\uff0c\u6bcf\u4e2a\u7ee7\u627f\u7c7b\u90fd\u8981\u76f8\u5e94\u5730\u6539\u53d8\u3002\u8fd9\u6837\u5f88\u5bb9\u6613\uff08\u7531\u4e8e\u758f\u5ffd\uff09\u9020\u6210\u4e0a\u9762\u6240\u793a\u7684\u95ee\u9898\u3002 \u8fd9\u79cd\u60c5\u51b5\u4e0b\u5e94\u5f53\u53c2\u8003 NVI \u8bbe\u8ba1\u6a21\u5f0f\u3002\u5c06\u9ed8\u8ba4\u503c\u5b9a\u4e49\u5728 non-virtual \u51fd\u6570\u5185\uff0c\u5e76\u5728 private virtual \u51fd\u6570\u5185\u6267\u884c\u771f\u6b63\u7684\u5de5\u4f5c\u3002 \u6761\u6b3e38\uff1a\u901a\u8fc7\u590d\u5408\u5851\u6a21\u51fahas-a\u6216\u201c\u6839\u636e\u67d0\u7269\u5b9e\u73b0\u51fa\u201d \u5f53\u67d0\u79cd\u7c7b\u578b\u7684\u5bf9\u8c61\u5185\u542b\u5b83\u79cd\u7c7b\u578b\u7684\u5bf9\u8c61\uff0c\u4fbf\u6784\u6210\u4e86\u590d\u5408(composition)\u5173\u7cfb\u3002\u8fd9\u662f\u4e00\u79cd \"has a\" \u6216 \"is implemented in terms of\"\uff08\u6839\u636e\u67d0\u7269\u5b9e\u73b0\u51fa\uff09 \u7684\u5173\u7cfb\u3002 \"has a\"\u548c\"is implemented in terms of\"\u7684\u533a\u522b\uff1a - \"has a\"\uff1a\u8be5\u7c7b\u542b\u6709\u7684\u5bf9\u8c61/\u4fe1\u606f\u3002\u5982\u7528\u6237\u7c7b\u5305\u542b Uid \u3001 name string \u7b49\u3002 - \"is implemented in terms of\"\uff1a\u8be5\u7c7b\u5b9e\u73b0\u7684\u5e95\u5c42\u7ed3\u6784\u3002\u5982\u4e00\u4e2a Stack \u7c7b\u5305\u542b\u4e86\u4e00\u4e2a private \u7684 std::vector \u3002 \u6761\u6b3e39\uff1a\u660e\u667a\u800c\u5ba1\u614e\u5730\u4f7f\u7528private\u7ee7\u627f private \u7ee7\u627f\u610f\u5473\u7740 implemented-in-terms-of\u3002 private \u7ee7\u627f\u610f\u5473\u7740\u53ea\u6709\u5b9e\u73b0\u90e8\u5206\u88ab\u7ee7\u627f\uff0c\u63a5\u53e3\u90e8\u5206\u88ab\u7565\u53bb\u3002\u5b83\u5728\u8f6f\u4ef6\u8bbe\u8ba1\u65b9\u9762\u65e0\u610f\u4e49\uff0c\u4ec5\u5728\u8f6f\u4ef6\u5b9e\u73b0\u5c42\u9762\u6709\u610f\u4e49\u3002 C++\u6807\u51c6\u4e0d\u5141\u8bb8\u7a7a\u7c7b\u5b58\u5728\uff0c\u6240\u4ee5\u7f16\u8bd1\u5668\uff08\u4e00\u822c\uff09\u4f1a\u4e3a\u7a7a\u7c7b\u7684\u5bf9\u8c61\u63d2\u5165\u4e00\u4e2a\u7a7a char \u5143\u7d20\u3002\u6545\u800c class Empty () {}; class Derived { private : int a ; Empty e ; } int main (){ Derived d ; int a ; cout << sizeof ( d ) == sizeof ( a ) << endl ; } \u8f93\u51fa\u4e3a 0 \u3002 \u800c\u5c06 Empty \u7c7b private \u7ee7\u627f\u540e\uff0c\u7f16\u8bd1\u5668\u4f1a\u5f00\u542f EBO(empty base optimization\uff1b\u7a7a\u767d\u57fa\u7c7b\u6700\u5c0f\u5316) \u4f18\u5316\uff0c\u4f7f Derived \u5bf9\u8c61\u4e2d\u7684 Empty \u5bf9\u8c61\u4e0d\u5360\u7a7a\u95f4\u3002 \u5f53\u4e24\u4e2a\u4e0d\u542b \"is a\" \u5173\u7cfb\u7684 classes\uff0c\u5176\u4e2d\u4e00\u4e2a\u9700\u8981\u8bbf\u95ee\u53e6\u4e00\u4e2a\u7c7b\u7684 protected \u6210\u5458\uff0c\u6216\u662f\u91cd\u5b9a\u4e49\u53e6\u4e00\u4e2a\u7c7b\u7684\u4e00\u6216\u591a\u4e2a virtual \u51fd\u6570\u3002\u6b64\u65f6\u5e94\u8003\u8651 private \u7ee7\u627f\u3002 \u4e00\u79cd\u590d\u5408\u4ee3\u66ff\u7ee7\u627f\u5b9e\u73b0\u91cd\u5b9a\u4e49virtual\u51fd\u6570\u7684\u65b9\u6cd5 class Base { public : virtual void print (); }; class Derived { public : void test (){ bd . print (); } private : class BaseDerived : public Base { public : virtual void print (){ // details } }; BaseDerived bd ; }; \u6761\u6b3e40\uff1a\u660e\u667a\u800c\u5ba1\u614e\u5730\u4f7f\u7528\u591a\u91cd\u7ee7\u627f(Multiple Inheritance, MI) \u591a\u91cd\u7ee7\u627f\u5373\u4e00\u4e2a\u6d3e\u751f\u7c7b\u7ee7\u627f\u4e86\u591a\u4e2a\u57fa\u7c7b\u3002 graph BT a[Derived Class] --> b[Base Class 1] a --> c[Base Class 2] \u4f7f\u7528\u591a\u91cd\u7ee7\u627f\u524d\u9700\u8981\u8003\u8651\u4ee5\u4e0b\u95ee\u9898\uff1a \u6b67\u4e49 class Base1 { public : void doSth (); }; class Base2 { private : void doSth (); }; class Derived : public Base1 , public Base2 { /*...*/ }; int main (){ Derived d ; d . doSth (); } C++ \u7f16\u8bd1\u5668\u5148\u89e3\u6790(resolving)\u6700\u4f73\u5339\u914d\u7684\u51fd\u6570\uff0c\u518d\u5224\u65ad\u8be5\u51fd\u6570\u7684\u53ef\u53d6\u7528\u6027\u3002\u56e0\u4e3a\u4e24\u4e2a\u51fd\u6570\u90fd\u662f public \u7ee7\u627f\uff0c\u6240\u4ee5\u4e24\u51fd\u6570\u7684\u4f18\u5148\u7ea7\u662f\u76f8\u540c\u7684\u3002\u7f16\u8bd1\u5668\u4f1a\u5728\u8fd9\u4e00\u6b65\u505c\u6b62\u5de5\u4f5c\uff08\u800c\u4e0d\u53bb\u89e3\u6790\u4e8c\u8005\u7684\u53ef\u53d6\u7528\u6027\uff09\u3002\u9664\u975e\u663e\u793a\u5730\u6307\u660e\u8981\u8c03\u7528\u7684\u51fd\u6570 d.Base1::doSth(); \u83f1\u5f62\u7ee7\u627f graph BT a[Derived class] --> b[Middle Class 1] a --> c[Middle Class 2] b --> d[Base Class] c --> d \u8003\u8651 Derived Class \u5185 Base Class \u5bf9\u8c61\u7684\u6570\u76ee\u3002\u7f3a\u7701\u60c5\u51b5\u4e0b\u662f\u4e24\u4e2a\u3002\u60f3\u8981\u72ec\u7acb\u5730\u7ee7\u627f Base Class \u5e94\u5f53\u4f7f\u7528 virtual \u7ee7\u627f\u3002 class Base { /*...*/ }; class Middle1 : virtual public Base { /*...*/ }; class Middle2 : virtual public Base { /*...*/ }; class Derived : public Middle1 , public Middle2 { /*...*/ }; \u4e00\u822c\u6765\u8bf4\uff0c public \u7ee7\u627f\u90fd\u5e94\u8be5\u662f virtual \u7684\u3002\u7136\u800c\uff0c\u8fd9\u79cd virtual \u7ee7\u627f\u4f1a\u5e26\u6765\u989d\u5916\u7684\u5f00\u9500\uff08\u7a7a\u95f4\u3001\u8bbf\u95ee\u901f\u5ea6\u7b49\uff09\u3002 virtual \u7ee7\u627f\u8fd8\u9700\u8981\u8003\u8651\u201d\u521d\u59cb\u5316\u201c\u89c4\u5219\u3002 virtual base class \u7684\u521d\u59cb\u5316\u8d23\u4efb\u662f\u7531 most derived class \u627f\u62c5\u7684\u3002\u8fd9\u610f\u5473\u7740\uff1a 1. classes \u82e5\u6d3e\u751f\u81ea virtual base classes \u800c\u9700\u8981\u521d\u59cb\u5316\uff0c\u5c31\u5fc5\u987b\u627e\u5230\u5b83\u7684 virtual bases\uff0c\u65e0\u8bba\u8ddd\u79bb\u591a\u8fdc\u3002 2. \u5f53\u4e00\u4e2a\u65b0\u7684 derived class \u52a0\u5165\u7ee7\u627f\u4f53\u7cfb\u4e2d\uff0c\u5b83\u5fc5\u987b\u627f\u62c5\u5176 virtual bases \u7684\u521d\u59cb\u5316\u8d23\u4efb\u3002 \u4e24\u70b9\u5fe0\u544a\uff1a 1. \u975e\u5fc5\u8981\u4e0d\u7528 virtual \u7ee7\u627f\u3002 2. \u5982\u679c\u5fc5\u987b\u4f7f\u7528 virtual bases\uff0c \u5c3d\u91cf\u4e0d\u8981\u5728\u91cc\u9762\u653e\u6570\u636e\u3002\u4ee5\u907f\u514d\u5e26\u6765\u521d\u59cb\u5316\u6216\u8d4b\u503c\u5e26\u6765\u7684\u989d\u5916\u95ee\u9898\u3002 \u6761\u6b3e41\uff1a\u4e86\u89e3\u9690\u5f0f\u63a5\u53e3\u548c\u7f16\u8bd1\u671f\u591a\u6001 \u9762\u5411\u5bf9\u8c61\u6a21\u5f0f\u603b\u4ee5\u663e\u5f0f\u63a5\u53e3(explicit interfaces)\u548c\u8fd0\u884c\u671f\u591a\u6001(runtime polymorphism)\u89e3\u51b3\u95ee\u9898\u3002 \u6a21\u677f\u7f16\u7a0b\u66f4\u4f9d\u8d56\u9690\u5f0f\u63a5\u53e3(implicit interfaces)\u548c\u7f16\u8bd1\u671f\u591a\u6001(compile-time polymorphism)\u3002 \u663e\u5f0f\u63a5\u53e3\uff1a\u901a\u5e38\u7531\u51fd\u6570\u7684\u7b7e\u540d\u5f0f\uff08\u4e5f\u5c31\u662f\u51fd\u6570\u540d\u79f0\u3001\u53c2\u6570\u7c7b\u578b\u3001\u8fd4\u56de\u7c7b\u578b\uff09\u6784\u6210\u3002 \u9690\u5f0f\u63a5\u53e3\uff1a\u7531\u6709\u6548\u8868\u8fbe\u5f0f(valid expression)\u7ec4\u6210\u3002 \u6761\u6b3e42\uff1a\u4e86\u89e3typename\u7684\u53cc\u91cd\u610f\u4e49 typename \u7684\u53cc\u91cd\u610f\u4e49\uff1a - \u4f5c\u4e3a\u6a21\u677f\u53c2\u6570\u7684\u7b7e\u540d\uff0c\u548c class \u6709\u7740\u76f8\u540c\u7684\u4f5c\u7528\u3002 - \u5728\u4ee3\u7801\u5757\u4e2d\uff0c\u7528\u4e8e\u663e\u793a\u5730\u58f0\u660e\u4e00\u4e2a\u5d4c\u5957\u4ece\u5c5e\u540d\u79f0(nested dependent name)\u3002 \u8003\u8651\u4ee5\u4e0b\u4ee3\u7801\uff1a template < typename T > void doSth ( const C & container ){ if ( container . size () > 2 ){ C :: const_iterator iter ( container . begin ()); ++ iter ; cout << * iter << endl ; } } \u4e0a\u8ff0\u4ee3\u7801\u5b9e\u9645\u4e0a\u4e0d\u88ab\u901a\u8fc7\u7f16\u8bd1\u3002\u56e0\u4e3a\u7f16\u8bd1\u5668\u4f1a\u9ed8\u8ba4\u5c06\u7c7b\u4f3c C::type \u8fd9\u6837\u7684\u5d4c\u5957\u4ece\u5c5e\u540d\u79f0\u89e3\u6790\u4e3a\u4e0d\u662f\u7c7b\u578b\uff08\u800c\u662f\u53d8\u91cf\u7b49\uff09\uff0c\u9664\u975e\u663e\u793a\u5730\u544a\u8bc9\u5b83\u3002\u56e0\u6b64\u9700\u8981\u5c06\u4e0a\u5f0f\u6539\u53d8\u4e3a\uff1a template < typename T > void doSth ( const C & container ){ // details typename C :: const_iterator iter ( container . begin ()); // details } typename \u7528\u4e8e\u663e\u793a\u5730\u58f0\u660e\u4e00\u4e2a\u5d4c\u5957\u4ece\u5c5e\u540d\u79f0(nested dependent name)\u3002\u7136\u800c\uff0c typename \u4e0d\u5e94\u51fa\u73b0\u5728 base classes list \u6216 member initialization list \u5185\u3002 \u5728 typedef \u7c7b\u578b\u540d\u65f6\uff0c\u9700\u8981\u663e\u793a\u5730\u58f0\u660e typename \uff0c\u4f8b\u5982 template < typename IterT > void workWithIterator ( IterT iter ){ typedef typename std :: iterator_traits < IterT >:: value_type value_type ; // details } \u6761\u6b3e43\uff1a\u5b66\u4e60\u5904\u7406\u6a21\u677f\u5316\u57fa\u7c7b\u5185\u7684\u540d\u79f0 \u6a21\u677f\u7ee7\u627f\u65f6\u65e0\u6cd5\u9690\u5f0f\u5730\u4f7f\u7528\u57fa\u7c7b\u6210\u5458\u65b9\u6cd5\u3002\u56e0\u4e3a\u7f16\u8bd1\u5668\u65e0\u6cd5\u6392\u9664\u57fa\u7c7b\u6a21\u677f\u7684\u67d0\u4e2a\u7279\u5316\u7248\u672c\u4e0d\u63d0\u4f9b\u548c\u4e00\u822c\u6027 template \u4e0d\u540c\u7684\u63a5\u53e3\u7684\u53ef\u80fd\u6027\u3002\u56e0\u6b64\u5b83\u5f80\u5f80\u62d2\u7edd\u5728 Templatized base classes\uff08\u6a21\u677f\u5316\u57fa\u7c7b\uff09\u5185\u5bfb\u627e\u7ee7\u627f\u800c\u6765\u7684\u540d\u79f0\u3002 \u6709\u4e09\u79cd\u65b9\u6cd5\u89e3\u51b3\u8fd9\u79cd\u95ee\u9898\uff1a \u4f7f\u7528 this \u6307\u9488\u8c03\u7528\u57fa\u7c7b\u6210\u5458\u51fd\u6570\u3002 \u4f7f\u7528 using \u8bed\u53e5\u63d0\u9192\u7f16\u8bd1\u5668\u5728\u57fa\u7c7b\u5185\u5bfb\u627e\u65b9\u6cd5\u3002 \u4f7f\u7528\u57fa\u7c7b\u4f5c\u7528\u57df\u663e\u5f0f\u5730\u8c03\u7528\u57fa\u7c7b\u6210\u5458\u51fd\u6570\u3002\u5982 Base::func() \u3002\u4e0d\u63a8\u8350\uff0c\u56e0\u4e3a\u8fd9\u4f1a\u9020\u6210\u67d0\u4e9b virtual \u51fd\u6570\u65e0\u6cd5 work\u3002 \u6761\u6b3e44\uff1a\u5c06\u4e0e\u53c2\u6570\u65e0\u5173\u7684\u4ee3\u7801\u62bd\u79bbtemplates \u4f7f\u7528 templates \u53ef\u80fd\u4f1a\u9020\u6210\u4ee3\u7801\u81a8\u80c0(code bloat)\uff1a\u76ee\u6807\u7801(object code)\u5e26\u7740\u91cd\u590d\uff08\u6216\u51e0\u4e4e\u91cd\u590d\uff09\u7684\u4ee3\u7801\u3001\u6570\u636e\u3002 \u9632\u6b62\u4ee3\u7801\u81a8\u80c0\u7684\u5de5\u5177\uff1a\u5171\u6027\u4e0e\u53d8\u6027\u5206\u6790(commonality and variability analysis)\u3002 \u4e0d\u4ec5\u975e\u7c7b\u578b\u6a21\u677f\u53c2\u6570(non-type template parameters)\u4f1a\u5e26\u6765\u81a8\u80c0\uff0c\u7c7b\u578b\u6a21\u677f\u53c2\u6570(type parameters)\u4e5f\u4f1a\u5e26\u6765\u81a8\u80c0\u2014\u2014\u5982\u5728\u67d0\u4e9b\u673a\u5668\u4e0a\uff0c int \u4e0e long \u5e95\u5c42\u5b9e\u73b0\u76f8\u540c\u3002\u67d0\u4e9b\u94fe\u63a5\u5668(linkers)\u4f1a\u5408\u5e76\u5b8c\u5168\u76f8\u540c\u7684\u5b9e\u73b0\u7801\uff0c\u4f46\u6709\u4e9b\u4e0d\u4f1a\u3002\u53e6\u4e00\u65b9\u9762\uff0c\u6307\u9488\u7684\u4e8c\u8fdb\u5236\u5e95\u5c42\u5b9e\u73b0\u662f\u76f8\u540c\u7684\uff0c\u4f46 templates \u4f1a\u4e3a\u6bcf\u4e2a\u6307\u9488\u8d4b\u4e88\u7279\u5316\u7248\u672c\u3002\u8fd9\u610f\u5473\u7740\u5f53\u4f60\u5b9e\u73b0\u67d0\u4e9b\u6210\u5458\u51fd\u6570\u4e14\u5b83\u4eec\u64cd\u4f5c\u5f3a\u7c7b\u578b\u6307\u9488(strongly typed pointers)\uff0c\u4f60\u5e94\u5f53\u8ba9\u5b83\u4eec\u8c03\u7528\u53e6\u4e00\u4e2a\u65e0\u7c7b\u578b\u6307\u9488(untyped pointers\uff0c\u5373 void * ) \u6765\u5b8c\u6210\u5b9e\u9645\u5de5\u4f5c\u3002 \u6761\u6b3e45\uff1a\u8fd0\u7528\u6210\u5458\u51fd\u6570\u6a21\u677f\u63a5\u53d7\u6240\u6709\u517c\u5bb9\u7c7b\u578b \u5bf9\u4e8e\u4e00\u4e2a\u8d44\u6e90\u7ba1\u7406\u7c7b SmartPtr<T> \u6765\u8bf4\uff0c\u5b83\u65e0\u6cd5\u652f\u6301\u6307\u9488\u5e94\u6709\u7684 covariance\u3002\u8fd9\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u901a\u8fc7\u6210\u5458\u51fd\u6570\u6a21\u677f\u6765\u5b9a\u4e49\u5176\u517c\u5bb9\u7c7b\u578b\u3002\u4ee5 std::shared_ptr<T> \u4e3a\u4f8b\uff0c\u5176\u6210\u5458\u51fd\u6570\u6a21\u677f\u5b9a\u4e49\u5982\u4e0b\uff1a template < class T > class shared_ptr { public : shared_ptr ( shared_ptr const & r ); //explicitly define its self-copy constructor template < class Y > shared_ptr ( shared_ptr < Y > const & r ) //generalized copy constructor : heldPtr ( r . get ()) { /*...*/ } template < class Y > explicit shared_ptr ( Y * p ); template < class Y > explicit shared_ptr ( weak_ptr < Y > const & r ); template < class Y > explicit shared_ptr ( unique_ptr < Y > & r ); template < class Y > shared_ptr & operator = ( shared_ptr < Y > const & r ); template < class Y > shared_ptr & operator = ( unique_ptr < Y > & r ); /*...*/ const T * get () const ; private : T * heldPtr ; /*...*/ } \u4e0a\u9762\u4ee3\u7801\u6709\u51e0\u4e2a\u6ce8\u610f\u70b9\uff1a - \u6a21\u677fcopy constructor \u65e0\u6cd5\u7279\u5316 self-copy constructor\u3002\u56e0\u6b64\u5982\u679c\u6709\u9700\u8981\u4ecd\u9700\u81ea\u884c\u5b9a\u4e49\u3002 - shared_ptr \u53ea\u6709 generalized copy constructor\uff0c\u8fd9\u610f\u5473\u7740\u53ea\u6709 shared_ptr \u7c7b\u578b\u9690\u5f0f\u8f6c\u6362\u4e3a\u53e6\u4e00\u4e2a shared_ptr \u662f\u5141\u8bb8\u7684\u3002\u5176\u5b83\u7c7b\u578b\uff08\u8f6c shared_ptr \uff09\u5219\u5fc5\u987b\u663e\u793a\u8f6c\u6362\u3002 - \u6210\u5458\u51fd\u6570\u901a\u8fc7 get() member function \u548c member initialized list \u6765\u5b9e\u9645\u6267\u884c\u6307\u9488\u7684 covariance\u3002\u8fd9\u6837\uff0c\u6307\u9488 covariance \u7684\u5408\u6cd5\u6027\u5c31\u7531\u7f16\u8bd1\u5668\u4fdd\u8bc1\u3002 - unique_ptr \u5e76\u975e const reference\u3002\u56e0\u4e3a\u5bf9 unique_ptr \u6267\u884c\u8f6c\u6362\u6216\u8d4b\u503c\uff0c\u5b83\u7684\u503c\u5b9e\u9645\u4e0a\u88ab\u6539\u53d8\u4e86\u3002 \u6761\u6b3e46\uff1a\u9700\u8981\u7c7b\u578b\u8f6c\u6362\u65f6\u8bf7\u4e3a\u6a21\u677f\u5b9a\u4e49\u975e\u6210\u5458\u51fd\u6570 \u8003\u8651\u6761\u6b3e24\u4e2d\u7684\u51fd\u6570\uff0c\u73b0\u5728\u8ba9\u6211\u4eec\u5c06\u5176\u53d8\u4e3a\u6a21\u677f\u3002 template < typename T > class Rational { public : Rational ( const T & numerator = 0 , const T & denominator = 1 ); const T numerator () const ; const T & denominator () const ; /*...*/ }; template < typename T > const Rational < T > operator * ( const Rational < T > & lhs , const Rational < T > & rhs ){ /*...*/ } \u7136\u800c\uff0c\u5f53\u6211\u4eec\u6267\u884c Rational < int > num = Rational < int > oneHalf ( 1 , 2 ) * 2 ; \u7f16\u8bd1\u5668\u4f1a\u62a5\u9519\u201c no match for \u2018operator*\u2019 (operand types are \u2018Rational<int>\u2019 and \u2018int\u2019) \u201d\u3002\u8fd9\u662f\u56e0\u4e3a\u7f16\u8bd1\u5668\u5728\u5b9e\u4f8b\u5316\u6a21\u677f\u65f6\u53ea\u4f1a\u5bfb\u627e\u4e00\u5c42 typename \u800c\u975e\u5d4c\u5957\u5730\u5bfb\u627e\u9690\u5f0f\u8f6c\u6362\u5173\u7cfb\u3002\u56e0\u6b64\uff0c\u7f16\u8bd1\u5668\u65e0\u6cd5\u627e\u5230\u540c\u65f6\u6ee1\u8db3 Rational<int> \u548c int \u4e24\u4e2a\u53c2\u6570\u7684\u51fd\u6570\u3002\u82e5\u6211\u4eec\u663e\u793a\u5730\uff0c\u5728\u6784\u9020\u51fa Rational \u7684\u4e00\u4efd\u5b9e\u4f8b\u65f6\u5c31\u58f0\u660e\u5bf9\u5e94\u7684\u51fd\u6570\u3002\u6bd4\u5982\u5c06\u4e4b\u58f0\u660e\u4e3a friend \u51fd\u6570\uff1a template < typename T > class Rational { friend const Rational operator * ( const Rational & lhs , const Rational & rhs ); public : Rational ( const T & numerator = 0 , const T & denominator = 1 ); const T numerator () const ; const T & denominator () const ; /*...*/ }; \u4e0a\u9762\u8fd9\u4e2a\u4ee3\u7801\u73b0\u5728\u53ef\u4ee5\u6210\u529f\u901a\u8fc7\u7f16\u8bd1\u4e86\u3002\u7136\u800c\uff0c\u5b83\u4ecd\u4f1a\u5728\u94fe\u63a5\u5668\u4e0a\u62a5\u9519\" undefined reference to `operator*(Rational<int> const&, Rational<int> const&)' \"\u3002\u56e0\u4e3a\u6211\u4eec\u4e0a\u9762\u53ea\u662f\u201c\u58f0\u660e\u201d\u4e86\u5b83\uff0c\u800c\u975e\u663e\u793a\u5730\u5b9a\u4e49\u4e86\u5b83\u3002\u65e2\u7136\u6211\u4eec\u58f0\u660e\u4e86\u5b83\uff0c\u5c31\u8981\u62c5\u8d1f\u5b9a\u4e49\u5b83\u7684\u8d23\u4efb\u3002\u6700\u7b80\u5355\u7684\u65b9\u6cd5\u662f\u5c06 operator* \u51fd\u6570\u5408\u5e76\u81f3 Rational \u672c\u4f53\u5185\u3002 template < typename T > class Rational { friend const Rational operator * ( const Rational & lhs , const Rational & rhs ){ return Rational < T > ( lhs . numerator () * rhs . numerator (), lhs . denominator () * rhs . denominator ()); } public : Rational ( const T & numerator = 0 , const T & denominator = 1 ); const T numerator () const ; const T & denominator () const ; /*...*/ }; \u8fd9\u91cc\u5c06\u51fd\u6570\u58f0\u660e\u4e3a friend \u662f\u6211\u4eec\u5728\u5bf9\u8c61\u5185\u58f0\u660e\u51fd\u6570\u7684\u552f\u4e00\u65b9\u5f0f\u3002\u540c\u65f6\uff0c\u5728\u5bf9\u8c61\u7ed3\u6784\u4f53\u5185\u5b9a\u4e49\u7684\u51fd\u6570\u90fd\u662f inline \u7684\u3002\u5bf9\u67d0\u4e9b\u5f88\u590d\u6742\u7684\u51fd\u6570\u800c\u8a00\uff0c\u5b9a\u4e49\u4e3a inline \u4f1a\u964d\u4f4e\u5176\u6267\u884c\u6548\u7387\u3002\u867d\u7136\u7f16\u8bd1\u5668\u4f1a\u81ea\u884c\u51b3\u5b9a\u662f\u5426\u63a5\u53d7 inline \u7533\u8bf7\u3002\u4f46\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4e0b\u9762\u7684\u65b9\u5f0f\u663e\u793a\u5730\u8ba9\u5176\u4e0d\u662f\u4e00\u4e2a inline \u51fd\u6570\u2014\u2014\u5373\u5c06\u771f\u6b63\u7684\u64cd\u4f5c\u653e\u5728\u53e6\u4e00\u4e2a\u6a21\u677f\u51fd\u6570\u5185\uff0c\u5e76\u5728 friend \u51fd\u6570\u5185\u8c03\u7528\u8fd9\u4e2a\u51fd\u6570\uff1a template < typename T > class Rational { friend const Rational operator * ( const Rational & lhs , const Rational & rhs ){ return doMultiple ( lhs , rhs ); } /*...*/ }; template < typename T > const Rational < T > doMultiple ( const Rational & lhs , const Rational & rhs ){ return Rational < T > ( lhs . numerator * rhs . numerator , lhs . denominator * rhs . denominator ); } \u8fd9\u91cc\uff0c\u8d1f\u8d23\u63a8\u65ad T \u7684\u7c7b\u578b\u662f\u7531 friend \u51fd\u6570\u6765\u5b9e\u73b0\u7684\u3002\u63a5\u7740\uff0c\u5b83\u7528\u8fd9\u4e2a\u7c7b\u578b\u5b9e\u4f8b\u5316\u5e76\u8c03\u7528\u7c7b\u5916\u58f0\u660e\u7684\u51fd\u6570\u3002 \u6761\u6b3e47\uff1a\u8bf7\u4f7f\u7528traits Classes\u8868\u73b0\u7c7b\u578b\u4fe1\u606f \u8fd9\u4e00\u7ae0\u5efa\u8bae\u7ed3\u5408\u4e66\u672c\u51fa\u793a\u7684\u4f8b\u5b50\u7406\u89e3\u3002 type traits\uff1a\u7c7b\u578b\u8403\u53d6\u3002\u7528\u4e8e\u786e\u5b9a\u6570\u636e\u7c7b\u578b\u3002 \u5982\u4f55\u8bbe\u8ba1\u5e76\u5b9e\u73b0 traits class\uff1a - \u786e\u8ba4\u82e5\u5e72\u4f60\u5b66\u4e60\u6211\u5c06\u6765\u53ef\u53d6\u5f97\u7684\u7c7b\u578b\u76f8\u5173\u4fe1\u606f - \u4e3a\u8be5\u4fe1\u606f\u9009\u62e9\u4e00\u4e2a\u540d\u79f0\uff08\u4f8b\u5982 iterator_category \uff09 - \u63d0\u4f9b\u4e00\u4e2a template \u548c\u4e00\u7ec4\u7279\u5316\u7248\u672c\uff0c\u5185\u542b\u4f60\u5e0c\u671b\u652f\u6301\u7684\u7c7b\u578b\u76f8\u5173\u4fe1\u606f\u3002 - \u5efa\u7acb\u4e00\u7ec4\u91cd\u8f7d\u51fd\u6570\u6216\u51fd\u6570\u6a21\u677f\uff0c\u5f7c\u6b64\u95f4\u7684\u5dee\u5f02\u53ea\u5728\u4e8e\u5404\u81ea\u7684 traits \u53c2\u6570\u3002\u4ee4\u6bcf\u4e2a\u51fd\u6570\u5b9e\u73b0\u7801\u4e0e\u5176\u63a5\u53d7\u7684 traits \u4fe1\u606f\u76f8\u543b\u5408\u3002 - \u5efa\u7acb\u4e00\u4e2a\u63a7\u5236\u51fd\u6570\u6216\u51fd\u6570\u6a21\u677f\uff0c\u5b83\u8c03\u7528\u4e0a\u8ff0\u90a3\u4e9b\u91cd\u8f7d\u51fd\u6570\u5e76\u4f20\u9012 traits class \u6240\u63d0\u4f9b\u7684\u4fe1\u606f\u3002 \u6761\u6b3e48\uff1a\u8ba4\u8bc6template\u5143\u7f16\u7a0b Template Metaprogramming(TMP, \u6a21\u677f\u5143\u7f16\u7a0b)\u662f\u7f16\u5199 Template-based C++ \u7a0b\u5e8f\u5e76\u6267\u884c\u4e8e\u7f16\u8bd1\u671f\u7684\u8fc7\u7a0b\u3002\u662f\u4ee5 C++ \u5199\u6210\u3001\u6267\u884c\u4e8e C++ \u7f16\u8bd1\u5668\u5185\u7684\u7a0b\u5e8f\u3002\u4e00\u65e6 TMP \u7a0b\u5e8f\u7ed3\u675f\u6267\u884c\uff0c\u5176\u8f93\u51fa\uff0c\u4e5f\u5c31\u662f\u4ece templates \u91cc\u5177\u73b0\u51fa\u6765\u7684\u82e5\u5e72 C++ \u6e90\u7801\uff0c\u4fbf\u4f1a\u4e00\u5982\u5f80\u5e38\u5730\u88ab\u7f16\u8bd1\u3002 TMP\u7684\u4f5c\u7528\u5982\u4e0b\uff1a 1. \u5b83\u8ba9\u67d0\u4e9b\u4e8b\u60c5\u66f4\u52a0\u5bb9\u6613\u3002 2. \u5b83\u5c06\u5f88\u591a\u8fd0\u884c\u671f\u5de5\u4f5c\u8f6c\u79fb\u5230\u7f16\u8bd1\u671f\u3002\u8fd9\u5c06\u5bfc\u81f4\u4e0b\u9762\u7684\u7ed3\u679c\uff1a 1. \u67d0\u4e9b\u9519\u8bef\u539f\u672c\u5728\u8fd0\u884c\u671f\u624d\u80fd\u68c0\u6d4b\u5230\uff0c\u73b0\u5728\u5728\u7f16\u8bd1\u671f\u5c31\u80fd\u627e\u5230\u3002 2. \u4f7f\u7528 TMP \u7684 C++ \u7a0b\u5e8f\u53ef\u80fd\u5728\u6bcf\u4e00\u65b9\u9762\u90fd\u66f4\u9ad8\u6548\uff1a\u8f83\u5c0f\u7684\u53ef\u6267\u884c\u6587\u4ef6\u3001\u8f83\u77ed\u7684\u8fd0\u884c\u671f\u3001\u8f83\u5c11\u7684\u5185\u5b58\u9700\u6c42\u3002 3. \u7f16\u8bd1\u65f6\u95f4\u5927\u5927\u52a0\u957f\u3002 TMP \u5df2\u88ab\u8bc1\u5b9e\u662f\u56fe\u7075\u5b8c\u5907\u7684\u3002\u53ef\u4ee5\u4f7f\u7528 TMP \u58f0\u660e\u53d8\u91cf\u3001\u6267\u884c\u5faa\u73af\u3001\u7f16\u5199\u53ca\u8c03\u7528\u51fd\u6570\u2026\u2026\u4f46\u8fd9\u4e9b\u6784\u4ef6\u548c \u201d\u6b63\u5e38\u7684\u201c C++ \u5bf9\u5e94\u7269\u6709\u6240\u4e0d\u540c\u3002\u4f8b\u5982 TMP \u6ca1\u6709\u771f\u6b63\u7684\u5faa\u73af\u6784\u4ef6\uff0c\u6240\u4ee5\u5faa\u73af\u6548\u679c\u85c9\u7531\u9012\u5f52(recursion)\u5b8c\u6210\u3002 \u4e14 TMP \u7684\u9012\u5f52\u5e76\u4e0d\u57fa\u4e8e\u9012\u5f52\u51fd\u6570\u7684\u8c03\u7528\uff0c\u800c\u662f\u57fa\u4e8e\u9012\u5f52\u6a21\u677f\u7684\u5177\u73b0\u5316(recursive template instantiation)\u3002\u5982\u4e0b\u9762\u8fd9\u4e2a\u8ba1\u7b97\u9636\u4e58\u7684 TMP \u51fd\u6570 template < unsigned n > struct Factorial { enum { value = n * Factional < n -1 >:: value }; }; template <> struct Factorial < 0 > { enum { value = 1 }; }; int main (){ std :: cout << Factorial < 5 >:: value ; // print 120 std :: cout << Factorial < 10 >:: value ; // print 3628800 } \u9700\u8981\u6ce8\u610f\uff0c\u4e0a\u9762\u7684\u9636\u4e58\u503c\u5b9e\u9645\u4e0a\u5728\u7f16\u8bd1\u671f\u5c31\u88ab\u8ba1\u7b97\u51fa\u6765\u5e76\u88ab\u7279\u5316\u6210 struct object \u4e86\u3002\u56e0\u800c\u6211\u4eec\u5728\u8fd0\u884c\u671f\u5c31\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u7ed3\u679c\u3002 TMP \u5e94\u7528\u573a\u666f\uff1a - \u65e9\u671f\u9519\u8bef\u68c0\u6d4b\uff0c\u4f8b\u5982\u786e\u5b9a\u5ea6\u91cf\u5355\u4f4d\u662f\u5426\u6b63\u786e\u3002 - \u4f18\u5316\u77e9\u9635\u8fd0\u7b97\u3002 - \u53ef\u4ee5\u751f\u6210\u5ba2\u6237\u5b9a\u5236\u8bbe\u8ba1\u6a21\u5f0f(custom design pattern)\u5b9e\u73b0\u54c1\u3002 \u6761\u6b3e49\uff1a\u4e86\u89e3new-handler\u7684\u884c\u4e3a \u5f53 operator new \u629b\u51fa\u4e00\u4e2a\u5f02\u5e38\u4ee5\u53cd\u6620\u4e00\u4e2a\u672a\u83b7\u5f97\u6ee1\u8db3\u7684\u5185\u5b58\u9700\u6c42\u4e4b\u524d\uff0c\u5b83\u4f1a\u4e0d\u65ad\u8c03\u7528\u4e00\u4e2a\u6240\u8c13\u7684 new_handler \u51fd\u6570\uff0c\u7528\u6765\u8fdb\u884c\u9519\u8bef\u5904\u7406\uff08\u7ed3\u675f\u8fdb\u7a0b\u6216\u91ca\u653e\u8d44\u6e90\uff09\uff0c\u76f4\u5230\u627e\u5230\u8db3\u591f\u7684\u5185\u5b58\u6216\u7ed3\u675f\u8be5\u8fdb\u7a0b\u3002 \u5ba2\u6237\u9700\u8981\u8c03\u7528\u4e00\u4e2a\u58f0\u660e\u4e8e\u6807\u51c6\u5e93 <new> \u7684\u5e93\u51fd\u6570 set_new_handler \u6765\u5b9a\u4e49\u8fd9\u4e2a\u9519\u8bef\u5904\u7406\u51fd\u6570\u3002 set_new_handler \u51fd\u6570\u58f0\u660e\u5982\u4e0b\uff1a namespace std { typedef void ( * new_handler )(); new_handler set_new_handler ( new_handler p ) throw (); } \u5176\u4e2d new_handler \u662f\u4e2a typedef \uff0c\u5b9a\u4e49\u51fa\u4e00\u4e2a\u6307\u9488\u6307\u5411\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u65e0\u9700\u53c2\u6570\u4e5f\u4e0d\u53cd\u56de\u4efb\u4f55\u4e1c\u897f\u3002 set_new_handler \u5219\u662f\u201c\u83b7\u5f97\u4e00\u4e2a new_handler \u5e76\u8fd4\u56de\u4e00\u4e2a new_handler \u201d\u7684\u51fd\u6570\u3002\u58f0\u660e\u5f0f\u672b\u7aef\u7684 throw() \u662f\u4e00\u4efd\u5f02\u5e38\u660e\u7ec6\uff0c\u8868\u660e\u8be5\u51fd\u6570\u4e0d\u4f1a\u629b\u51fa\u5f02\u5e38\u3002 \u4e00\u4e2a\u4f8b\u5b50\u5982\u4e0b\u6240\u793a\uff1a void outOfMem (){ std :: cerr << \"Unable to satisfy request for memory \\n \" ; std :: abort ; } int main (){ std :: set_new_handler ( outOfMem ); int * Test = new int [ 100000000L ]; } \u4e00\u4e2a\u8bbe\u8ba1\u826f\u597d\u7684 new_handler \u51fd\u6570\u9700\u8981\u505a\u5230\u4ee5\u4e0b\u4e8b\u60c5\uff1a - \u8ba9\u66f4\u591a\u5185\u5b58\u53ef\u88ab\u4f7f\u7528\u3002 \u5b9e\u73b0\u8be5\u65b9\u6cd5\u7684\u4e00\u4e2a\u9014\u5f84\u662f\uff0c\u7a0b\u5e8f\u4e00\u5f00\u59cb\u5c31\u7533\u8bf7\u4e00\u5927\u5757\u5185\u5b58\uff0c\u5728 new_handler \u51fd\u6570\u7b2c\u4e00\u6b21\u88ab\u8c03\u7528\u65f6\u5c06\u5b83\u4eec\u91ca\u8fd8\u7ed9\u7a0b\u5e8f\u4f7f\u7528\u3002 - \u5b89\u88c5\u53e6\u4e00\u4e2a new_handler \u3002 \u82e5\u5f53\u4e0b new_handler \u51fd\u6570\u65e0\u6cd5\u83b7\u53d6\u66f4\u591a\u5185\u5b58\uff0c\u5219\u8ba9\u5b83\u5b89\u88c5\u53e6\u4e00\u4e2a new_handler \u51fd\u6570\u3002\u4e0b\u6b21\u5f53 operator new \u8c03\u7528 new_handler \u65f6\uff0c\u5c06\u4f1a\u8c03\u7528\u6700\u65b0\u7684\u90a3\u4e2a\u3002\u505a\u6cd5\u4e4b\u4e00\u662f\u4ee4 new_handler \u51fd\u6570\u4fee\u6539\u4f1a\u5f71\u54cd\u5176\u884c\u4e3a\u7684 static \u3001 namespace \u6216 global \u6570\u636e\u3002 - \u5378\u9664 new_handler \u3002 \u5373\u5c06 nullptr \u4f20\u7ed9 set_new_handler \u51fd\u6570\u3002\u4e00\u65e6 operator new \u83b7\u5f97 nullptr \uff0c\u5b83\u5c06\u8f93\u51fa\u62a5\u9519\u4fe1\u606f\u3002 - \u4e0d\u8fd4\u56de\u3002 \u901a\u5e38\u8c03\u7528 abort \u6216 exist\u3002 \u6761\u6b3e50\uff1a\u4e86\u89e3new\u548cdelete\u7684\u5408\u7406\u66ff\u6362\u65f6\u673a \u66ff\u6362 operator new \u548c operator delete \u7684\u7406\u7531\uff1a - \u5ba2\u5236\u5316\u6765\u68c0\u6d4b\u8fd0\u7528\u4e0a\u7684\u9519\u8bef\u3002 - \u4e3a\u4e86\u5f3a\u5316\u6548\u80fd\u3002\u6839\u636e\u751f\u4ea7\u7ebf\u8fdb\u884c\u6700\u4f18\u64cd\u4f5c\u3002 - \u6536\u96c6\u4f7f\u7528\u4e0a\u7684\u7edf\u8ba1\u6570\u636e\u3002 - \u4e3a\u4e86\u964d\u4f4e\u7f3a\u7701\u5185\u5b58\u7ba1\u7406\u5668\u5e26\u6765\u7684\u7a7a\u95f4\u989d\u5916\u5f00\u9500\u3002 - \u4e3a\u4e86\u5f25\u8865\u7f3a\u7701\u5206\u914d\u5668\u4e2d\u7684\u975e\u6700\u4f73\u9f50\u4f4d(suboptimal alignment)\u3002 - \u4e3a\u4e86\u5c06\u76f8\u5173\u5bf9\u8c61\u6210\u7c07\u96c6\u4e2d\u3002 - \u4e3a\u4e86\u83b7\u5f97\u975e\u4f20\u7edf\u884c\u4e3a\u3002 \u6761\u6b3e51\uff1a\u7f16\u5199new\u548cdelete\u65f6\u9700\u56fa\u5b88\u5e38\u89c4 C++\u6807\u51c6\u8981\u6c42\uff0c\u5373\u4f7f\u662f\u7533\u8bf7\u4e00\u4e2a\u7a7a\u5185\u5b58\uff0c\u4e5f\u8981\u8fd4\u56de\u5730\u5740\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u4e00\u822c\u4f1a\u9009\u62e9\u8fd4\u56de\u4e00\u4e2a\u5927\u5c0f\u4e3a1\u7684\u5185\u5b58\u5730\u5740\u3002 operator new \u5185\u542b\u4e00\u4e2a\u65e0\u7a77\u5faa\u73af\uff0c\u5728\u5176\u4e2d\u5c1d\u8bd5\u5206\u914d\u5185\u5b58\u3002\u82e5\u5b83\u65e0\u6cd5\u6ee1\u8db3\u5185\u5b58\u9700\u6c42\uff0c\u5e94\u5f53\u8c03\u7528 new-handler \u3002 operator new \u5f80\u5f80\u4f1a\u9762\u4e34\u7ee7\u627f\u95ee\u9898\uff0c\u4e14\u88ab\u7ee7\u627f\u7684\u5b9e\u73b0\u65b9\u5f0f\u5f80\u5f80\u4e0d\u662f\u6700\u4f18\u8bbe\u8ba1\u3002\u56e0\u6b64\uff0c\u81ea\u5b9a\u4e49\u7684 operator new \u5e94\u5f53\u5904\u7406\u201c\u4e0d\u540c\u4e8e\u6b63\u786e\u5927\u5c0f\u7684\u5185\u5b58\u7533\u8bf7\u201d\u3002\u4e00\u822c\u7684\u5904\u7406\u65b9\u5f0f\u662f\u4ee4\u6807\u51c6\u7684 operator new \u5904\u7406\u5b83\u4eec\u3002 operator delete \u5e94\u5f53\u4fdd\u8bc1\u5bf9 nullptr \u4e0d\u505a\u4efb\u4f55\u4e8b\uff08\u56e0\u4e3aC++\u6807\u51c6\u4fdd\u8bc1 delete nullptr \u4e0d\u4f1a\u62a5\u9519\uff09\u3002 \u6761\u6b3e52\uff1a\u5199\u4e86placement New\u4e5f\u8981\u5199placement Delete placement new \u662f\u6307\u9664\u4e86\u5fc5\u987b\u7684 size_t \u53c2\u6570\u5916\u8fd8\u6709\u5176\u5b83\u989d\u5916\u53c2\u6570\u7684 operator new \u91cd\u8f7d\u3002\u4f8b\u5982\uff1a class Widget { public : static void * operator new ( std :: size_t size , std :: ostream & logStream ) throw ( std :: alloc ); /*...*/ } int main (){ Widget * pw = new ( std :: cerr ) Widget ; } \u7136\u800c\uff0c\u82e5\u6211\u4eec\u6210\u529f\u4e3a Widget \u5206\u914d\u5185\u5b58\uff0c\u5374\u5728\u6784\u9020\u65f6\u671f\u51fa\u9519\uff0c\u7f16\u8bd1\u5668\u5c31\u4f1a\u5bfb\u627e\u5bf9\u5e94\u7248\u672c\u7684 delete \u6765\u91ca\u653e\u8be5\u5185\u5b58\u3002\u5426\u5219\u5c31\u4f1a\uff08\u4ec0\u4e48\u90fd\u4e0d\u5e72\uff09\u9020\u6210\u5185\u5b58\u6cc4\u6f0f\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u5fc5\u987b\u5728\u58f0\u660e placement new \u7684\u540c\u65f6\u58f0\u660e placement delete\u3002\u4e0d\u8fc7\uff0c\u5728\u6211\u4eec\u83b7\u5f97 Widget \u6307\u9488\u6210\u529f\u540edelete\u5b83\uff0c\u7f16\u8bd1\u5668\u8c03\u7528\u7684\u4ecd\u7136\u662f\u65e0\u989d\u5916\u53c2\u6570\u7684 operator delete \u3002 \u5176\u6b21\uff0c\u6210\u5458\u51fd\u6570\u7684\u540d\u79f0\u4f1a\u63a9\u76d6\u5176\u5916\u56f4\u4f5c\u7528\u57df\uff08global scope\u3001base class\u2018 scope\u7b49\uff09\uff0c\u6240\u4ee5\u6211\u4eec\u5e94\u5f53\u4f7f\u7528using\u58f0\u660e\u5f0f\u53d6\u5f97\u6807\u51c6\u5f62\u5f0f\u3002\u4e00\u4e2a\u7b80\u5355\u7684\u65b9\u6cd5\u662f\uff0c\u5efa\u7acb\u4e00\u4e2a base class\uff0c\u62e5\u6709\u6240\u6709\u6b63\u5e38\u5f62\u5f0f\u7684 new \u548c delete\uff1a class StandardNewDeleteForms { public : // normal forms static void * operator new ( std :: size_ t size ) throw ( std :: bad_alloc ) { return :: operator new ( size ); } static void operator delete ( void * pMemory ) throw () { :: operator delete ( pMemory ); } // placement forms static void * operator new ( std :: size_ t size , void * ptr ) throw () { return :: operator new ( size , ptr ); } static void operator delete ( void * pMemory , void * ptr ) throw () { :: operator delete ( pMemory , ptr ); } // nothrow forms static void * operator new ( std :: size_ t size , const std :: nothrow_t & nt ) throw () { return :: operator new ( size , nt ); } static void operator delete ( void * pMemory , const std :: nothrow_t & ) throw () { :: operator delete ( pMemory ); } } class Widget : public StandardNewDeleteForms { public : // three base forms is visible and callable now using StandardNewDeleteForms :: operator new ; using StandardNewDeleteForms :: operator delete ; // personal form static void * operator new ( std :: size_t size , std :: ostream & logStream ) throw ( std :: bad_alloc ); static void operator delete ( std :: size_t size , std :: ostream & logStream ) throw (); } \u6761\u6b3e53\uff1a\u4e0d\u8981\u8f7b\u5ffd\u7f16\u8bd1\u5668\u7684\u8b66\u544a \u52aa\u529b\u5728\u6700\u9ad8\u7ea7\u522b\u4e0b\u4e89\u53d6\u65e0\u8b66\u544a\u3002 \u5728\u786e\u5b9a\u5ffd\u7565\u67d0\u8b66\u544a\u65f6\uff0c\u786e\u4fdd\u81ea\u5df1\u4e86\u89e3\u8be5\u8b66\u544a\u7684\u771f\u5b9e\u610f\u4e49\u548c\u610f\u56fe\u3002 \u6761\u6b3e54\uff1a\u8ba9\u81ea\u5df1\u719f\u6089\u5305\u62ecTR1\u5728\u5185\u7684\u6807\u51c6\u7a0b\u5e8f\u5e93 \u843d\u540e\u65f6\u4ee3\uff0c\u4e0d\u4e88\u8d58\u8ff0\u3002 \u6761\u6b3e55\uff1a\u8ba9\u81ea\u5df1\u719f\u6089Boost Boost\u5e93\u7279\u70b9\uff1a 1. \u4e0eC++\u6807\u51c6\u59d4\u5458\u4f1a\u6709\u6df1\u539a\u8054\u7cfb\u548c\u5f71\u54cd\u529b\u3002\u662f\u4e4b\u540eC++\u6807\u51c6\u5e93\u7684\u201d\u5907\u9009\u5e93\u201c\u3002 2. \u5165 Boost \u5e93\u7684\u8fc7\u7a0b\u662f\u4e25\u683c\u7684\u516c\u5f00\u540c\u884c\u4e92\u5ba1(public peer review)\u3002","title":"Effective C++"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#01c","text":"C++\u662f\u4e2a\u591a\u91cd\u6cdb\u578b\u7f16\u7a0b\u8bed\u8a00(multi-paradigm programming language)\uff1a \u8fc7\u7a0b\u5f62\u5f0f(procedural) \u9762\u5411\u5bf9\u8c61\u5f62\u5f0f(object-oriented) \u51fd\u6570\u5f62\u5f0f(functional) \u6cdb\u578b\u5f62\u5f0f(generic) \u5143\u7f16\u7a0b\u5f62\u5f0f(meta-programming) C++\u7684\u6b21\u8bed\u8a00(sub-language)\uff1a C\uff1a \u533a\u5757(blocks)\u3001\u8bed\u53e5(statements)\u3001\u9884\u5904\u7406\u5668(preprocessor)\u3001\u5185\u7f6e\u6570\u636e\u7c7b\u578b(built-in data type)\u3001\u6570\u7ec4(arrays)\u3001\u6307\u9488(pointers)\u3002 \u5c40\u9650\uff1a\u7f3a\u4e4f\u6a21\u677f(templates)\u3001\u5f02\u5e38(exceptions)\u3001\u91cd\u8f7d(overloading)\u2026\u2026 Object-Oriented C++\uff1a classes\u3001\u5c01\u88c5(encapsulation)\u3001\u7ee7\u627f(inheritance)\u3001\u591a\u6001(polymorphism)\u3001virtual\u51fd\u6570(\u52a8\u6001\u7ed1\u5b9a)\u2026\u2026 Template C++\uff1a \u6cdb\u578b\u7f16\u7a0b(generic programming)\u90e8\u5206\u3002 \u65b0\u7684\u7f16\u7a0b\u8303\u5f0f(programming paradigm)\uff1atemplate meta-programming(TMP\uff0c\u6a21\u677f\u5143\u7f16\u7a0b)\u3002 STL\uff1a \u5bb9\u5668(containers)\u3001\u8fed\u4ee3\u5668(iterators)\u3001\u7b97\u6cd5(algorithms)\u3001\u51fd\u6570\u5bf9\u8c61(function objects) C++\u7684\u9ad8\u6548\u7f16\u7a0b\u53d6\u51b3\u4e8e\u6240\u4f7f\u7528\u7684\u8303\u5f0f\u3002","title":"\u6761\u6b3e01\uff1a\u89c6C++\u4e3a\u4e00\u4e2a\u8bed\u8a00\u8054\u90a6"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#02constenuminlinedefine","text":"\u5c3d\u91cf\u4ee5\u7f16\u8bd1\u5668\u66ff\u6362\u9884\u5904\u7406\u5668\u3002 \u7528\u5e38\u91cf\u66ff\u6362\u5b8f\u3002\u9632\u6b62\u8be5\u540d\u79f0\u672a\u8bb0\u5165\u8bb0\u53f7\u8868(symbol table)\u5185\u3002 \u7279\u6b8a\u60c5\u51b5\uff1a \u5b9a\u4e49\u5e38\u91cf\u6307\u9488(constant pointers)\uff1a\u7531\u4e8e\u5e38\u91cf\u5b9a\u4e49\u901a\u5e38\u88ab\u653e\u5728\u5934\u6587\u4ef6\u5185\uff0c\u56e0\u6b64\u6709\u5fc5\u8981\u5c06\u6307\u9488\uff08\u672c\u8eab\uff09\u58f0\u660e\u4e3a const \uff0c\u5373\u9876\u5c42const\u3002 class\u7684\u4e13\u5c5e\u5e38\u91cf\uff1a\u4e3a\u4e86\u7ea6\u675f\u5176\u4f5c\u7528\u57df(scope)\uff0c\u5fc5\u987b\u5c06\u5176\u4f5c\u4e3a\u4e00\u4e2a\u7c7b\u6210\u5458 (member)\u3002\u4e3a\u4e86\u4fdd\u8bc1\u6539\u53d8\u91cf\u81f3\u591a\u53ea\u6709\u4e00\u4efd\u5b9e\u4f53\uff0c\u5fc5\u987b\u5c06\u5176\u5b9a\u4e49\u4e3a static \u6210\u5458\u3002 enum: \u7c7b\u4f3c #define \uff0c\u5bf9\u5176\u53d6\u5730\u5740\u662f\u975e\u6cd5\u7684 \u7f16\u8bd1\u5668\u4e0d\u4f1a\u4e3a\u5b83\u5206\u914d\u989d\u5916\u50a8\u5b58\u7a7a\u95f4 \u662ftemplate meta-programming \u7684\u57fa\u7840\u6280\u672f \u7528template inline function\u6765\u83b7\u53d6\u5b8f\u7684\u6548\u7387\uff08\u65e0\u9700\u8c03\u7528\u51fd\u6570\u7684\u5f00\u9500\uff09\u548c\u4e00\u822c\u51fd\u6570\u7684\u6240\u6709\u53ef\u9884\u6599\u884c\u4e3a\u548c\u7c7b\u578b\u5b89\u5168\u6027\u3002\u5982\uff1a // Macro implementation, with a lot unexpected results #define CALL_WITH_MAX(a,b) f((a) > (b)) ? (a) : (b)) // template inline function implementation template < typename T > inline void callWithMax ( const T & a , const T & b ){ f ( a > b ? a : b ); }","title":"\u6761\u6b3e02\uff1a\u5c3d\u91cf\u4ee5const\uff0cenum\uff0cinline\u66ff\u6362#define"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#03const","text":"char greeting [] = \"Hello\" ; char * p = greeting ; //non-const pointer, non-const data const char * p = greeting ; //non-const pointer, const data char * const p = greeting ; //const pointer, non-const data const char * const p = greeting ; //const pointer, const data \u5176\u533a\u522b\u5728\u4e8e const \u51fa\u73b0\u4e8e * \u7684\u5de6\u8fb9\u8fd8\u662f\u53f3\u8fb9\u3002 \u7531\u4e8eSTL\u8fed\u4ee3\u5668\u7531\u6307\u9488\u5851\u6a21\u51fa\u6765\uff0c\u6240\u4ee5\u58f0\u660e\u8fed\u4ee3\u5668\u4e3a const \u76f8\u5f53\u4e8e\u5c06\u6307\u9488\u58f0\u660e\u4e3a const \uff08\u5373 T* const \u4e00\u6837\uff09\u3002\u5982\u679c\u60f3\u8ba9\u8fed\u4ee3\u5668\u6307\u5411\u7684\u4e1c\u897f\u4e0d\u53ef\u6539\u52a8\uff0c\u5e94\u4f7f\u7528 const_iterator \u5728\u51fd\u6570\u58f0\u660e\u5f0f\u5185\uff0c const \u53ef\u4ee5\u548c\u51fd\u6570\u8fd4\u56de\u503c\u3001\u5404\u53c2\u6570\u3001\u51fd\u6570\u81ea\u8eab\uff08\u5982\u679c\u662f\u6210\u5458\u51fd\u6570\uff09\u4ea7\u751f\u5173\u8054\u3002 \u51fd\u6570\u8fd4\u56de\u503c class Rational { /*details*/ }; const Rational operator * ( const Rational & lhs , const Rational & rhs ); // To provide from the below situation Rational a , b , c ; if ( a * b = c ); // It is a mistake on comparison. And the compiler will return an error \u53c2\u6570\uff1a\u9632\u6b62\u8bef\u4fee\u6539\u3002\u5982\u6307\u9488\u6216\u5f15\u7528\u53c2\u6570\u3002 \u6210\u5458\u51fd\u6570 \u597d\u5904\uff1a \u4f7fclass\u63a5\u53e3\u5bb9\u6613\u88ab\u7406\u89e3\u3002\u53ef\u4ee5\u5f97\u77e5\u54ea\u4e2a\u51fd\u6570\u53ef\u4ee5\u6539\u52a8\u5bf9\u8c61\uff0c\u54ea\u4e2a\u51fd\u6570\u4e0d\u53ef\u4ee5\u3002 \u4f7f\u201c\u64cd\u4f5cconst\u5bf9\u8c61\u201d\u6210\u4e3a\u53ef\u80fd\u3002 \u7528\u6cd5\uff1a \u4e24\u4e2a\u6210\u5458\u51fd\u6570\u82e5\u4ec5\u662f\u5e38\u91cf\u6027(constness)\u4e0d\u540c\uff0c\u53ef\u4ee5\u88ab\u91cd\u8f7d class TextBlock { public : //details const char & operator []( std :: size_t position ) const { return text [ position ]; } char & operator []( std :: size_t position ){ return text [ position ]; } private : std :: string text ; } int main (){ TextBlock tb ( \"Hello\" ); std :: cout << tb [ 0 ]; // non-const TextBlock::operator[] const TextBlock ctb ( \"World\" ); std :: cout << ctb [ 0 ]; // const TextBlock::operator[] tb [ 0 ] = \"W\" ; // valid ctb [ 0 ] = \"H\" ; // invalid } \u4e3a\u4ee3\u7801\u590d\u7528\uff0c\u5e94\u4f7f\u7528non-const\u6210\u5458\u8c03\u7528const\u6210\u5458\u800c\u975e\u76f8\u53cd\u3002\u56e0\u4e3anon-const\u65b9\u6cd5\u4e0d\u627f\u8bfa\u4e0d\u6539\u53d8\u5bf9\u8c61\u53c2\u6570\u3002\u6545\u800cconst\u6210\u5458\u8c03\u7528non-const\u6210\u5458\u6709\u98ce\u9669\u3002\u5982\u4e0a\u9762\u7684\u4ee3\u7801\u8bfe\u6539\u4e3a\uff1a class TextBlock { public : //details const char & operator []( std :: size_t position ) const { return text [ position ]; } char & operator []( std :: size_t position ){ return const_cast < char &> ( // turn to non-const static_cast < const TextBlock &> ( * this ) // To call the const function [ position ]; ) } private : std :: string text ; } \u82e5\u5bf9\u4e8econst\u5bf9\u8c61\u5185\u53ef\u63a5\u53d7\u4fee\u6539\u7684\u6210\u5458\uff08\u9664static\u6210\u5458\u5916\uff09\uff0c\u5e94\u7528 mutable \u4fee\u9970\u3002","title":"\u6761\u6b3e03\uff1a\u5c3d\u53ef\u80fd\u4f7f\u7528const"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#04","text":"\u4e0d\u8981\u6df7\u6dc6\u8d4b\u503c(assignment)\u548c\u521d\u59cb\u5316(initialization)\u3002\u521d\u59cb\u5316\u5728\u8c03\u7528\u6784\u9020\u51fd\u6570\u9636\u6bb5\uff0c\u65e9\u4e8e\u8d4b\u503c\u3002 \u7528\u6210\u5458\u521d\u59cb\u5217(member initialization list)\u66ff\u6362\u8d4b\u503c\u52a8\u4f5c\uff1a class Test { Test ( int aValue , char bValue , std :: string & strValue ) : a ( aValue ), b ( bValue ), str ( strValue ) {} private : int a ; char b ; std :: string str ; } \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0cC++\u6807\u51c6\u6309\u7167\u58f0\u660e\u4f4d\u7f6e\u4ece\u524d\u5230\u540e\u7684\u65b9\u5f0f\u521d\u59cb\u5316\u6210\u5458\u3002\u56e0\u6b64\uff0c\u5982\u679c\u4f60\u60f3\u7528\u524d\u4e00\u4e2a\u6210\u5458\u6765\u521d\u59cb\u5316\u540e\u4e00\u4e2a\u6210\u5458\uff08\u4e00\u822c\u4e0d\u63a8\u8350\uff09\uff0c\u4f60\u9700\u8981\u5728\u540e\u4e00\u4e2a\u6210\u5458\u4e4b\u524d\u5b9a\u4e49\u524d\u4e00\u4e2a\u6210\u5458\u3002\u800c\u5404\u6210\u5458\u5728\u6210\u5458\u521d\u59cb\u5217\u4e2d\u7684\u987a\u5e8f\u5e76\u4e0d\u5f71\u54cd\u521d\u59cb\u5316\u987a\u5e8f\u3002\u4e5f\u56e0\u6b64\u5efa\u8bae\u4f60\u4f7f\u7528\u58f0\u660e\u987a\u5e8f\u6765\u5199\u6210\u5458\u521d\u59cb\u5217\u3002 \u4f7f\u7528\u6210\u5458\u521d\u59cb\u5217\u65f6\u5e94\u5f53\u5217\u51fa\u6240\u6709\u6210\u5458\u53d8\u91cf\uff0c\u4ee5\u514d\u5fd8\u8bb0\u521d\u59cb\u5316\u8fdb\u800c\u5bfc\u81f4ub\u3002 const \u548c reference \u6210\u5458\u53d8\u91cf\u53ea\u80fd\u88ab\u521d\u59cb\u5316\uff0c\u4e0d\u80fd\u88ab\u8d4b\u503c\u3002\u6545\u800c\u603b\u662f\u63a8\u8350\u4f7f\u7528\u6210\u5458\u521d\u59cb\u5217\u3002 \u5982\u679c\u7c7b\u6709\u591a\u4e2a\u6784\u9020\u51fd\u6570\uff0c\u53ef\u4ee5\u5c06\u90a3\u4e9b\u201c\u8d4b\u503c\u8868\u73b0\u50cf\u521d\u59cb\u5316\u4e00\u6837\u597d\u201d\u7684\u53d8\u91cf\u79fb\u5230\u5355\u72ec\u7684\u51fd\u6570\u4e2d\uff0c\u5e76\u5728\u6bcf\u4e2a\u6784\u9020\u51fd\u6570\u7684\u51fd\u6570\u4f53\u5185\u8c03\u7528\u5b83\u4eec\uff0c\u4ee5\u907f\u514d\u5197\u4f59\u91cd\u590d\u7684\u6210\u5458\u521d\u59cb\u5217\u3002 \u5bf9\u4e8e non-local static \u53d8\u91cf\uff0c\u82e5\u5b83\u4eec\u5728\u4e0d\u540c\u7f16\u8bd1\u5355\u5143\u5185\u5b9a\u4e49\uff08\u5982\u5728\u4e0d\u540c\u7684file\uff0c\u6700\u7ec8\u88ab #include fileName \u8fdb\u4e00\u4e2a\u6e90\u6587\u4ef6\uff09\u3002\u82e5\u5176\u4e2d\u4e00\u4e2a non-local static \u53d8\u91cf\u4f7f\u7528\u53e6\u4e00\u4e2a non-local static \u53d8\u91cf\u521d\u59cb\u5316\uff0c\u5219\u540e\u8005\u53ef\u80fd\u672a\u88ab\u521d\u59cb\u5316\uff0c\u8fdb\u800c\u5bfc\u81f4ub\u3002\u5bf9\u6b64\u89e3\u51b3\u65b9\u6cd5\u662f\u5c06\u6bcf\u4e2a non-local static \u53d8\u91cf\u653e\u5728\u81ea\u5df1\u7684\u4e13\u5c5e\u51fd\u6570(reference-returning function)\u5185\uff08\u7528 local static \u53d8\u91cf\u5c06\u5176\u66ff\u6362\uff0c\u5e76\u8fd4\u56de\u8be5\u53d8\u91cf\u7684\u5f15\u7528\uff09\u3002\u4f8b\u5982\uff1a class BaseClass { // details; } BaseClass & bc (){ static BaseClass bco ; return bco ; } \u8fd9\u6837\uff0c\u6211\u4eec\u901a\u8fc7\u63a5\u53e3 bc() \u8c03\u7528\u8fd9\u4e2a\u9759\u6001\u5bf9\u8c61\u3002\u82e5\u8be5\u53d8\u91cf\u5c1a\u672a\u521d\u59cb\u5316\uff0c\u5b83\u4f1a\u5728\u8fd4\u56de\u521d\u503c\u524d\u5b8c\u6210\u521d\u59cb\u5316\uff0c\u53cd\u4e4b\u5219\u4e0d\u4f1a\u6709\u8be5\u5f00\u9500\u3002\u82e5\u662f\u5f15\u7528\u6587\u4ef6\u672a\u8c03\u7528\u8be5\u63a5\u53e3\uff0c\u5219\u6839\u672c\u4e0d\u4f1a\u5b58\u5728\u6784\u9020\u548c\u6790\u6784\u4ee3\u4ef7\u3002 \u4f46 non-const static \u5bf9\u8c61\u5728\u591a\u7ebf\u7a0b\u73af\u5883\u4e0b\u90fd\u4f1a\u6709\u4e0d\u786e\u5b9a\u6027\u3002\u8be5\u95ee\u9898\u7684\u89e3\u51b3\u65b9\u6cd5\u4e4b\u4e00\u662f\uff1a\u5728\u7a0b\u5e8f\u7684\u5355\u7ebf\u7a0b\u542f\u52a8\u9636\u6bb5(single-threaded startup portion)\u624b\u52a8\u8c03\u7528\u6240\u6709 reference-returning function\u3002\u8fd9\u53ef\u6d88\u9664\u4e0e\u521d\u59cb\u5316\u6709\u5173\u7684\u201c\u7ade\u901f\u5f62\u5f0f(race conditions)\u201d","title":"\u6761\u6b3e04\uff1a\u786e\u5b9a\u5bf9\u8c61\u88ab\u4f7f\u7528\u524d\u5df2\u5148\u88ab\u521d\u59cb\u5316"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#05c","text":"default \u6784\u9020/\u6790\u6784\u51fd\u6570\uff1a \u8c03\u7528 base class \u548c non-static \u53d8\u91cf\u7684\u6784\u9020/\u6790\u6784\u51fd\u6570\u3002 \u7f16\u8bd1\u5668\u4ea7\u751f\u7684\u6790\u6784\u51fd\u6570\u662f non-virtual \u7684\uff0c\u9664\u975e\u8be5\u51fd\u6570\u7684 base class \u6709\u58f0\u660e virtual \u7684\u6790\u6784\u51fd\u6570\u3002\u8fd9\u79cd\u60c5\u51b5\u4e0b\u8be5\u51fd\u6570\u7684\u865a\u5c5e\u6027(virtualness)\u4e3b\u8981\u6765\u81ea base class\u3002 default copy\u51fd\u6570\u901a\u8fc7\u8d4b\u503c\u5185\u7f6e\u7c7b\u578b\u5e76\u8c03\u7528\u5176\u4ed6 non-static \u6210\u5458\u7684 copy \u51fd\u6570\u751f\u6210\u3002\u56e0\u6b64\u7f16\u8bd1\u5668\u4f1a\u62d2\u7edd\u4e3a\u4ee5\u4e0b\u4e09\u79cd\u60c5\u51b5\u751f\u6210 copy \u51fd\u6570\uff08\u800c\u5fc5\u987b\u81ea\u884c\u5b9a\u4e49\uff09\uff1a \u5185\u542b reference \u6210\u5458\u3002C++\u6807\u51c6\u4e0d\u5141\u8bb8 reference \u53d8\u91cf\u6307\u5411\u65b0\u7684\u5143\u7d20\u3002 \u5185\u542b const \u6210\u5458\u3002C++\u6807\u51c6\u4e0d\u5141\u8bb8\u6539\u53d8 const \u53d8\u91cf\u7684\u503c\u3002 \u5185\u542b\u67d0\u4e2a\u6210\u5458\u53d8\u91cf\uff0c\u901a\u8fc7 ClassMember::ClassMember(ClassMember &) = delete; \u8bed\u53e5\u6216\u5c06 copy \u8bed\u53e5\u7f6e\u4e8e private scope \u5185\uff0c\u4ee5\u6b64\u62d2\u7edd copy \u64cd\u4f5c\u3002 \u53e6\u5916\u4e00\u4e2aC++\u9ed8\u8ba4\u51fd\u6570\u7684\u95ee\u9898\u8be6\u89c1\u6211\u8fd9\u4e2a\u7ecf\u9a8c\u8d34\uff1a C++\u7684 0/3/5 \u89c4\u5219","title":"\u6761\u6b3e05\uff1a\u4e86\u89e3C++\u9ed8\u8ba4\u7f16\u5199\u5e76\u8c03\u7528\u54ea\u4e9b\u51fd\u6570"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#06","text":"\u5bf9\u4e8e\u7c7b\u5185\u4e0d\u9700\u8981\u7684\u81ea\u52a8\u751f\u6210\u51fd\u6570\uff0c\u5e94\u5f53\u660e\u786e\u544a\u77e5\u4e0d\u9700\u8981\uff0c\u5982\u4ee5\u4e0b\u8bed\u6cd5\uff1a class ClassTest { public : ClassTest () = default ; ~ ClassText () = default ; // keyword delete explicitly denote that you don't need a copy function ClassTest ( const ClassText & ) = delete ; } \u4f46\u5bf9\u4e8e C++11 \u4ee5\u524d\u7684\u6807\u51c6\uff0c\u6ca1\u6709\u5b9e\u73b0\u7528\u4e8e\u963b\u6b62\u81ea\u52a8\u751f\u6210\u51fd\u6570\u7684 delete \u5173\u952e\u8bcd\uff0c\u5927\u5bb6\u4e00\u822c\u901a\u8fc7\u5c06\u5176\u58f0\u660e\u5728 private scope\u91cc\u5e76\u4e0d\u53bb\u5b9a\u4e49\u5b83\u6765\u8fbe\u5230\u8fd9\u4e2a\u6548\u679c\u3002 class ClassTest { public : ClassTest () { /*details*/ } ~ ClassText () { /*details*/ } private : ClassTest ( const ClassText & ); } \u8fd9\u6837\uff0c\u7c7b\u5916\u65b9\u6cd5\u5c31\u65e0\u6cd5\u8c03\u7528\u8be5\u51fd\u6570\u3002\u800c\u7c7b\u5185\u6210\u5458\u6216\u53cb\u5143\u5c1d\u8bd5\u8c03\u7528\u5b83\u65f6\u5c31\u4f1a\u9047\u5230\u94fe\u63a5\u5668\u9519\u8bef\u3002\u4f60\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u5c06\u94fe\u63a5\u5668\u9519\u8bef\u8f6c\u5316\u4e3a\u7f16\u8bd1\u5668\u9519\u8bef\uff1a class BaseClass { public : BaseClass () {} ~ BaseClass () {} private : BaseClass ( const BaseClass & ); } class ClassTest : public BaseClass { //details } \u8fd9\u6837\uff0c\u5728\u7f16\u8bd1\u5668\u5c1d\u8bd5\u4e3a ClassTest \u7c7b\u81ea\u52a8\u751f\u6210 copy \u64cd\u4f5c\u65f6\uff0c\u7531\u4e8e\u65e0\u6cd5\u8c03\u7528 BaseClass \u7684 copy \u51fd\u6570\uff0c\u5c31\u4e0d\u4f1a\u4e3a\u8be5\u7c7b\u751f\u6210 copy \u51fd\u6570\u3002\u4f46\u8fd9\u79cd\u65b9\u6cd5\u53ef\u80fd\u9020\u6210\u591a\u91cd\u7ee7\u627f\u3002","title":"\u6761\u6b3e06\uff1a\u82e5\u4e0d\u60f3\u4f7f\u7528\u7f16\u8bd1\u5668\u81ea\u52a8\u751f\u6210\u7684\u51fd\u6570\uff0c\u5c31\u8be5\u660e\u786e\u62d2\u7edd"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#07virtual","text":"\u82e5 class \u610f\u56fe\u88ab\u5f53\u4f5c\u4e00\u4e2a \u5e26\u591a\u6001\u6027\u8d28\u7684 base class \u4f7f\u7528\uff0c\u5e94\u5f53\u6309\u7167\u9700\u6c42\u4e3a\u5176\u5b9a\u5236 virtual \u6790\u6784\u51fd\u6570\u3002 \u82e5\u7c7b\u5b58\u5728\u81f3\u5c11\u4e00\u4e2avirtual\u51fd\u6570\uff0c\u518d\u4e3a\u5176\u5b9a\u5236 virtual \u6790\u6784\u51fd\u6570\uff0c\u5426\u5219\u4e0d\u8981\u5b9a\u4e49 virtual \u51fd\u6570\u3002 virtual\u51fd\u6570\u4f1a\u5e26\u6765\u989d\u5916\u7684 vtpr(virtual table pointer)\u7684\u5f00\u9500\uff0c\u5e76\u4f1a\u4e27\u5931\u548c\u5176\u4ed6\u8bed\u8a00\uff08\u5982C\uff09\u5185\u7684\u76f8\u540c\u58f0\u660e\u4e00\u6837\u7684\u7ed3\u6784\uff0c\u4ece\u800c\u4e27\u5931\u53ef\u79fb\u690d\u6027\u3002 \u5e94\u5f53\u7528 final \u5173\u952e\u8bcd\u62d2\u7edd\u7c7b\u88ab\u7ee7\u627f\u6216\u7279\u5b9a\u865a\u51fd\u6570\u88ab\u91cd\u5199\u3002","title":"\u6761\u6b3e07\uff1a\u4e3a\u591a\u6001\u57fa\u7c7b\u58f0\u660evirtual\u6790\u6784\u51fd\u6570"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#08","text":"\u5bf9\u4e8e\u6790\u6784\u51fd\u6570\u5185\u9020\u6210\u7684\u5f02\u5e38\uff0c\u82e5\u9009\u62e9\u7f6e\u4e4b\u4e0d\u7406\uff0c\u5219\u5f88\u53ef\u80fd\u9020\u6210ub\u3002\u4e00\u822c\u800c\u8a00\u6709\u4e09\u79cd\u89e3\u51b3\u65b9\u5f0f\uff1a \u82e5\u629b\u51fa\u5f02\u5e38\u5219\u7ed3\u675f\u7a0b\u5e8f\u3002\u901a\u5e38\u901a\u8fc7\u8c03\u7528 std::abort \u5b8c\u6210\u3002 \u541e\u4e0b\u5f02\u5e38\u3002 \u91cd\u65b0\u8bbe\u8ba1\u63a5\u53e3\u548c\u7c7b\uff0c\u5c06\u53ef\u80fd\u9020\u6210\u5f02\u5e38\u7684\u884c\u4e3a\u79fb\u51fa\u6790\u6784\u51fd\u6570\u3002","title":"\u6761\u6b3e08\uff1a\u522b\u8ba9\u5f02\u5e38\u9003\u79bb\u6790\u6784\u51fd\u6570"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#09virtual","text":"base class \u6784\u9020\u671f\u95f4\u5176 virtual \u51fd\u6570\u7edd\u4e0d\u4f1a\u4e0b\u964d\u5230 derived classes \u9636\u5c42\u3002\u8be5 virtual \u51fd\u6570\u4ecd\u7136\u4f1a\u6267\u884c base class \u91cc\u5b9a\u4e49\u7684\u5b9e\u4f8b\u3002 \u6839\u672c\u539f\u56e0\uff1a\u5728 derived class \u7684 base class \u6784\u9020\u671f\u95f4\uff0c\u5bf9\u8c61\u7684\u7c7b\u578b\u662f base class \u800c\u975e derived class\u3002","title":"\u6761\u6b3e09\uff1a\u7edd\u4e0d\u518d\u6784\u9020\u548c\u6790\u6784\u8fc7\u7a0b\u4e2d\u8c03\u7528virtual\u51fd\u6570"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#10operatorreference-to-this","text":"\u7531\u4e8eC++\u652f\u6301\u8d4b\u503c\u8fde\u9501\u5f62\u5f0f\uff0c\u4e14\u8d4b\u503c\u91c7\u7528\u53f3\u7ed3\u5408\u5f8b\u3002 int x , y , z ; x = y = z = 15 ; // the above sentence is interpreted as the below style x = ( y = ( z = 15 )); \u4e3a\u4e86\u5b9e\u73b0\u8fde\u9501\u8d4b\u503c\uff0c\u8d4b\u503c\u64cd\u4f5c\u7b26\u5fc5\u987b\u8fd4\u56de\u4e00\u4e2a reference \u5b9e\u53c2\u3002 class Test { public : //details Test & operator ( const Test & rhs ){ //details return * this ; } }","title":"\u6761\u6b3e10\uff1a\u4ee4operator=\u8fd4\u56de\u4e00\u4e2areference To *this"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#11operator","text":"\u81ea\u8d4b\u503c\u5373\u5bf9\u8c61\u8d4b\u503c\u7ed9\u81ea\u5df1\uff0c\u4e00\u822c\u76f4\u63a5\u6216\u95f4\u63a5\u5730\u53d1\u751f\u4e8e\u4ee5\u4e0b\u60c5\u51b5\uff1a w = w ; a [ i ] = a [ j ]; //when i == j * px = * py ; //when px == py \u5982\u679c\u5bf9\u8c61\u81ea\u884c\u7ba1\u7406\u8d44\u6e90\uff0c\u4e14\u4e0d\u786e\u5b9a\u5176 copy \u884c\u4e3a\u662f\u5b89\u5168\u7684\uff08\u5982\u53ef\u80fd\u5728\u505c\u6b62\u4f7f\u7528\u8d44\u6e90\u524d\u610f\u5916\u5730\u91ca\u653e\u4e86\u5b83\uff09\uff0c\u5c31\u53ef\u80fd\u9020\u6210\u96be\u4ee5 debug \u7684 ub\u3002 \u5728\u8bbe\u8ba1 copy \u884c\u4e3a\u65f6\uff0c\u5e94\u5173\u6ce8\u8be5\u884c\u4e3a\u662f\u4e0d\u662f \u201c\u81ea\u8d4b\u503c\u5b89\u5168\u201d \u548c \u201c\u5f02\u5e38\u5b89\u5168\u201d \u7684\u3002\u4e14\u4e00\u822c\u800c\u8a00\uff0c\u201c\u5f02\u5e38\u5b89\u5168\u201d\u7684 copy \u884c\u4e3a\u5f80\u5f80\u4e5f\u662f\u201c\u81ea\u8d4b\u503c\u5b89\u5168\u201d\u7684\uff0c\u56e0\u6b64\u6709\u8bb8\u591a\u4eba\u90fd\u81f4\u529b\u4e8e\u5b9e\u73b0 \u201c\u5f02\u5e38\u5b89\u5168\u6027\u201d(exception safety)\u4e0a\u3002\u4e0b\u9762\u662f\"\u81ea\u8d4b\u503c\u5b89\u5168\"\u548c\"\u5f02\u5e38\u5b89\u5168\"\u7684\u4e24\u4e2a\u4f8b\u5b50\uff1a class Widget { public : Widget & operator = ( const Widget & rhs ); private : int * pb ; } // self-assignment safety but exception unsafety Widget & Widget :: operator = ( const Widget & rhs ){ if ( this == & rhs ) return * this ; //identity test delete pb ; pb = new int ( * rhs . pb ); //exception unsafety, new operation possibly fails return * this ; } //exception safety and self-assignment safety Widget & Widget :: operator = ( const Widget & rhs ){ int * temp = pb ; pb = new int ( * rhs . pb ); //pb still points to its origin value if new operation fails delete temp ; return * this ; } //Another way satisfies exception safety and self-assignment safety Widget & Widget :: operator = ( const Widget & rhs ){ Widget temp ( rhs ); swap ( temp ); return * this ; }","title":"\u6761\u6b3e11\uff1a\u5728operator=\u4e2d\u5904\u7406\u201c\u81ea\u6211\u8d4b\u503c\u201d"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#12","text":"\u82e5\u7c7b\u6dfb\u52a0\u4e86\u65b0\u7684\u53d8\u91cf\uff0c\u4e14\u4f60\u81ea\u5b9a\u4e49\u4e86 copy(copy \u548c copy-assignment) \u51fd\u6570\uff0c\u4f60\u5c31\u8981\u4fee\u6539\u5b83\u4eec\u3002\u4f60\u9700\u8981\u786e\u4fdd\uff1a \u590d\u5236\u6240\u6709\u7684 local \u6210\u5458\u53d8\u91cf\u3002 \u8c03\u7528\u6240\u6709 base classes \u5185\u7684\u9002\u5f53\u7684 copying \u51fd\u6570\u3002 \u4e0d\u8be5\u4ee4 copy-assignment \u64cd\u4f5c\u7b26\u8c03\u7528 copy \u6784\u9020\u51fd\u6570\uff0c\u6216\u662f\u76f8\u53cd\u3002\u66ff\u4ee3\u65b9\u6848\u662f\u5efa\u7acb\u4e00\u4e2a private \u7684 init \u51fd\u6570\u4f9b\u4e8c\u8005\u8c03\u7528\u3002","title":"\u6761\u6b3e12\uff1a\u590d\u5236\u5bf9\u8c61\u65f6\u52ff\u5fd8\u5176\u6bcf\u4e00\u4e2a\u6210\u5206"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#13","text":"\u5c06\u8d44\u6e90\u653e\u8fdb\u5bf9\u8c61\u5185\uff0c\u8ba9\u5bf9\u8c61\u5728\u7ed3\u675f\u751f\u547d\u5468\u671f\u540e\u6790\u6784\u5b83\u4eec\u3002 \u7528\u667a\u80fd\u6307\u9488\u6765\u7ba1\u7406 heap-based \u8d44\u6e90\u3002\u4f46\u8981\u6ce8\u610f\uff0c \u667a\u80fd\u6307\u9488\u4e0d\u652f\u6301 contravariance \uff0c\u56e0\u6b64\u5728\u8003\u8651\u9762\u5411\u5bf9\u8c61\u7684\u591a\u6001\u5c5e\u6027\u65f6\u8981\u8fdb\u884c\u53d6\u820d\u3002 \u8d44\u6e90\u53d6\u5f97\u7684\u65f6\u673a\u4fbf\u662f\u521d\u59cb\u5316\u7684\u65f6\u673a(Resource Acquisition Is Initialization; RAII)","title":"\u6761\u6b3e13\uff1a\u4ee5\u5bf9\u8c61\u7ba1\u7406\u8d44\u6e90"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#14copying","text":"\u4e24\u79cd\u65b9\u6cd5\u907f\u514d\u8d44\u6e90\u7ba1\u7406\u7c7b\u7684 copying \u884c\u4e3a\u5bfc\u81f4\u7684 bug\uff08\u5982\u591a\u6b21delete\uff09\uff1a \u7981\u6b62\u590d\u5236 \u5bf9\u5e95\u5c42\u8d44\u6e90\u4f7f\u7528\u201c\u5f15\u7528\u8ba1\u6570\u6cd5\u201d\uff1a \u5185\u542b std::shared_ptr \u6210\u5458\u53d8\u91cf\u3002\u4f46\u8981\u6ce8\u610f std::shared_ptr \u7684\u7f3a\u7701\u884c\u4e3a\uff1a\u5f53\u5f15\u7528\u6b21\u6570\u4e3a\u96f6\u65f6\u5220\u9664\u5176\u6240\u6307\u7269\u3002 \u53ef\u4ee5\u901a\u8fc7\u81ea\u5b9a\u4e49 std::shared_ptr \u7684\u201c\u5220\u9664\u5668\u201d(deleter)\u7684\u65b9\u5f0f\u6765\u81ea\u5b9a\u4e49\u201c\u5f15\u7528\u8ba1\u6570\u5668\u7f6e0\u65f6\u201d\u7684\u884c\u4e3a\u3002\u5220\u9664\u5668\u51fd\u6570\u6307\u9488\u662f std::shared_ptr \u7684\u7b2c\u4e8c\u4e2a\u53c2\u6570\uff08\u53ef\u7f3a\u7701\uff09\u3002 \u4e24\u79cd\u65b9\u6cd5\u6765\u786e\u4fdd\u5b89\u5168\u5730 copy \u5e95\u5c42\u8d44\u6e90\uff1a \u590d\u5236\u5e95\u90e8\u8d44\u6e90\u3002 \u8f6c\u79fb\u5e95\u90e8\u8d44\u6e90\u7684\u6240\u6709\u6743\u3002","title":"\u6761\u6b3e14\uff1a\u5728\u8d44\u6e90\u7ba1\u7406\u7c7b\u4e2d\u5c0f\u5fc3copying\u884c\u4e3a"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#15","text":"\u663e\u5f0f\u8f6c\u6362\uff1a\u901a\u8fc7 get() \u7b49\u63a5\u53e3\u8fd4\u56de\u7c7b\u7ba1\u7406\u7684\u539f\u59cb\u6307\u9488\uff08\u7684\u590d\u4ef6\uff09\u3002 \u9690\u5f0f\u8f6c\u6362\uff1a\u91cd\u8f7d\u64cd\u4f5c\u7b26\uff0c\u81f3\u5c11\u5305\u62ec\u6307\u9488\u53d6\u503c(pointer dereferencing)\u64cd\u4f5c\u7b26( operator-> \u548c operator* )","title":"\u6761\u6b3e15\uff1a\u5728\u8d44\u6e90\u7ba1\u7406\u7c7b\u4e2d\u63d0\u4f9b\u5bf9\u539f\u59cb\u8d44\u6e90\u7684\u8bbf\u95ee"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#16newdelete","text":"std :: string * StrPtr = new std :: string ( \"Hello World\" ); delete StrPtr ; std :: string * StrArrayPtr = new std :: string [ 100 ]; delete [] StrArrayPtr ; \u5bf9\u4e8e\u6307\u5411\u5143\u7d20\u548c\u6307\u5411\u6570\u7ec4\u7684\u6307\u9488\u6709\u4e0d\u540c\u7684 delete \u903b\u8f91\u3002\u9700\u8981\u683c\u5916\u6ce8\u610f\u4e24\u4ef6\u4e8b\uff1a \u5f53\u4f60\u7684 class \u542b\u6709\u4e00\u4e2a\u6307\u9488\u6307\u5411\u52a8\u6001\u5185\u5b58\uff0c\u4e14\u63d0\u4f9b\u591a\u4e2a\u6784\u9020\u51fd\u6570\u65f6\uff0c\u9700\u8981\u683c\u5916\u6ce8\u610f\u8be5\u89c4\u5219\u3002 \u4f7f\u7528 typedef \u65f6\u5fc5\u987b\u8bf4\u6e05\u695a\uff0c\u5f53\u7a0b\u5e8f\u5458\u4ee5 new \u6765\u521b\u5efa\u5bf9\u8c61\u65f6\uff0c\u8be5\u4ee5\u54ea\u79cd delete \u5f62\u5f0f\u5220\u9664\u5b83\u3002","title":"\u6761\u6b3e16\uff1a\u6210\u5bf9\u4f7f\u7528new\u548cdelete\u65f6\u8981\u91c7\u53d6\u76f8\u540c\u5f62\u5f0f"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#17-newed","text":"class Widget ; int priority (); // executable sentence void processWidget ( std :: shared_ptr < Widget > ( new Widget ), priority ()); \u5bf9\u4e8e\u4e0a\u9762\u7684\u6267\u884c\u8bed\u53e5\uff0c\u7f16\u8bd1\u5668\u4fdd\u8bc1\uff1a new Widget \u5728\u521b\u5efa std::shared_ptr \u4e4b\u524d\u5b8c\u6210\u3002\u4f46\u6267\u884c\u5e76\u8fd4\u56de priority() \u7684\u987a\u5e8f\u4e0d\u786e\u5b9a\u3002\u8fd9\u6837\uff0c\u5047\u5982 priority() \u7684\u6267\u884c\u987a\u5e8f\u5728 new Widget \u548c std::shared_ptr \u4e4b\u95f4\uff0c\u4e14\u5728\u6267\u884c\u8fc7\u7a0b\u4e2d\u53d1\u751f\u5f02\u5e38\u3002\u5c31\u4f1a\u5bfc\u81f4 new Widget \u7684\u8fd9\u5757\u5185\u5b58\u6cc4\u6f0f\u3002 \u6b63\u786e\u65b9\u5f0f\u662f\u5c06\u5efa\u7acb\u667a\u80fd\u6307\u9488\u8bed\u53e5\u653e\u5728\u72ec\u7acb\u8bed\u53e5\u4e2d\u3002\u8fd9\u6837\u7f16\u8bd1\u5668\u603b\u4fdd\u8bc1\u5728\u4e0b\u4e00\u6761\u72ec\u7acb\u8bed\u53e5\u6267\u884c\u524d\u6267\u884c\u5168\u90e8\u8be5\u72ec\u7acb\u8bed\u53e5\u7684\u64cd\u4f5c\u3002 std :: shared_ptr < Widget > pw ( new Widget ); processWidget ( pw , priority ());","title":"\u6761\u6b3e17\uff1a\u4ee5\u72ec\u7acb\u8bed\u53e5\u5c06 Newed \u5bf9\u8c61\u7f6e\u5165\u667a\u80fd\u6307\u9488"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#18","text":"\u7406\u60f3\u4e0a\uff0c\u5982\u679c\u5ba2\u6237\u4f01\u56fe\u4f7f\u7528\u67d0\u4e2a\u63a5\u53e3\u800c\u5374\u6ca1\u6709\u83b7\u5f97\u4ed6\u6240\u9884\u671f\u7684\u884c\u4e3a\uff0c\u8fd9\u4e2a\u4ee3\u7801\u4e0d\u8be5\u901a\u8fc7\u7f16\u8bd1\uff1b\u5982\u679c\u4ee3\u7801\u901a\u8fc7\u4e86\u7f16\u8bd1\uff0c\u5b83\u7684\u4f5c\u4e3a\u5c31\u8be5\u662f\u5ba2\u6237\u6240\u60f3\u8981\u7684\u3002","title":"\u6761\u6b3e18\uff1a\u8ba9\u63a5\u53e3\u5bb9\u6613\u88ab\u6b63\u786e\u4f7f\u7528\uff0c\u4e0d\u6613\u88ab\u8bef\u7528"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#type-system","text":"class Date { public : Data ( int month , int day , int year ); // details } \u8fd9\u662f\u4e0d\u826f\u7684\u8bbe\u8ba1\uff0c\u53ef\u80fd\u4f1a\u9020\u6210\u9519\u8bef\u4f20\u53c2\u3002\u6211\u4eec\u53ef\u4ee5\u5f15\u5165\u5916\u8986\u7c7b\u578b(wrapper types)\u6765\u533a\u522b\u5e74\u6708\u65e5\uff1a struct Day { explicit Day ( int d ) : day ( d ) {} private : int day ; } struct Month { explicit Month ( int m ) : month ( m ) {} private : int month ; } struct Year { explicit Year ( int y ) : year ( y ) {} private : int year ; } class Date { public : Date ( const Month & m , const Day & d , const Year & y ); //details } // executable sentence Date ( Month ( 6 ), Day ( 4 ), Year ( 1989 )); \u4e00\u65e6\u5df2\u7ecf\u5b9a\u4e49\u4e86\u6b63\u786e\u7684\u7c7b\u578b\uff0c\u5728\u6b64\u57fa\u7840\u4e0a\u9650\u5236\u5176\u503c\u4e5f\u662f\u5408\u7406\u7684\uff0c\u5982\u8003\u8651\u5230\u4e00\u5e74\u53ea\u670912\u4e2a\u6708\uff0c\u6708\u4efd\u63a5\u53e3\u53ef\u4ee5\u5982\u4e0b\u8bbe\u8ba1\uff1a class Month { public : static Month Jan () { return Month ( 1 ); } static Month Feb () { return Month ( 2 ); } //... static Month Dec () { return Month ( 12 ); } private : explicit Month ( int m ) : month ( m ) {} int month ; } Date ( Month :: Jun (), Day ( 4 ), Year ( 1989 ));","title":"\u5728\u53c2\u6570\u8bbe\u8ba1\u4e0a\uff0c\u53ef\u4ee5\u5f15\u5165\u7c7b\u578b\u7cfb\u7edf(type system)\u6765\u963b\u6b62\u9519\u8bef\u4f20\u53c2\u3002\u5982\u8bbe\u8ba1\u201c\u65e5\u5386\u201d\u63a5\u53e3\uff1a"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#_1","text":"\u5e38\u89c1\u7684\u9650\u5236\u662f\u52a0\u4e0a const \u3002","title":"\u9650\u5236\u7c7b\u578b\u5185\u4ec0\u4e48\u4e8b\u53ef\u4ee5\u505a\uff0c\u4ec0\u4e48\u4e8b\u4e0d\u53ef\u4ee5\u505a"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#_2","text":"\u9664\u975e\u6709\u597d\u7406\u7531\uff0c\u5426\u5219\u5c3d\u91cf\u8ba9\u4f60\u7684 types \u7684\u884c\u4e3a\u548c\u7cfb\u7edf\u5185\u7f6e types \u7684\u884c\u4e3a\u4e00\u81f4\u3002 \u5bf9\u76f8\u540c\u529f\u80fd\u63d0\u4f9b\u76f8\u540c\u7684\u63a5\u53e3\u3002\uff08\u5982 STL \u5bb9\u5668\u7684 size() \u6210\u5458\u51fd\u6570\uff09","title":"\u5c3d\u91cf\u63d0\u4f9b\u4e00\u81f4\u6027\u7684\u63a5\u53e3"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#_3","text":"\u5982\u679c\u7c7b\u7684\u8bbe\u8ba1\u8981\u6c42\u5ba2\u6237\u5fc5\u987b\u505a\u67d0\u4e9b\u4e8b\u60c5\uff0c\u5ba2\u6237\u6709\u53ef\u80fd\u4f1a\u5fd8\u8bb0\u53bb\u505a\u5b83\u3002\u6bd4\u5982\u5f53\u7c7b\u8fd4\u56de\u4e00\u4e2a\u6307\u9488\u65f6\uff0c\u5ba2\u6237\u53ef\u80fd\u4f1a\u5fd8\u8bb0\u91ca\u653e\u5b83\uff0c\u9020\u6210\u5185\u5b58\u6cc4\u6f0f\u3002\u89e3\u51b3\u65b9\u6cd5\u662f\u5c06\u5b83\u5c01\u88c5\u6210\u4e00\u4e2a std::shared_ptr \u8fd4\u56de\u7ed9\u5ba2\u6237\u3002 \u5982\u679c\u8fd9\u4efd\u8d44\u6e90\u9700\u8981\u7279\u522b\u7684\u6790\u6784\u5668\u6765\u6790\u6784\uff0c\u4e5f\u5e94\u5f53\u5c06\u8fd9\u4e2a\u6790\u6784\u5668\u4f5c\u4e3a\u7b2c\u4e8c\u4e2a\u53c2\u6570\u4f20\u7ed9 std::shared_ptr \u8fd4\u56de\u7ed9\u5ba2\u6237\u3002","title":"\u907f\u514d\u8ba9\u5ba2\u6237\u53bb\u505a\u67d0\u4e9b\u4e8b\u60c5"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#19classtype","text":"\u597d\u7684 type \u6709\u81ea\u7136\u7684\u8bed\u6cd5\uff0c\u76f4\u89c2\u7684\u8bed\u4e49\uff0c\u4ee5\u53ca\u4e00\u6216\u591a\u4e2a\u9ad8\u6548\u5b9e\u73b0\u54c1\u3002 \u5728\uff08\u50cf\u8bbe\u8ba1 type \u4e00\u6837\uff09\u8bbe\u8ba1 class \u65f6\u9700\u8981\u56de\u7b54\u4ee5\u4e0b\u95ee\u9898\uff1a \u65b0 type \u7684\u5bf9\u8c61\u5e94\u8be5\u5982\u4f55\u88ab\u521b\u5efa\u548c\u9500\u6bc1\uff1f \u8fd9\u4f1a\u5f71\u54cd\u5230\u4f60\u7684 class \u7684\u6784\u9020\u51fd\u6570\u3001\u6790\u6784\u51fd\u6570\u53ca\u5185\u5b58\u5206\u914d\u548c\u91ca\u653e\u51fd\u6570( operator new \u3001 operator new[] \u3001 operator delete \u3001 operator delete[] ) \u5bf9\u8c61\u7684\u521d\u59cb\u5316\u548c\u5bf9\u8c61\u7684\u8d4b\u503c\u8be5\u6709\u4ec0\u4e48\u6837\u7684\u5dee\u522b\uff1f \u51b3\u5b9a\u4e86\u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c(assignment)\u64cd\u4f5c\u7b26\u7684\u884c\u4e3a\u3002 \u65b0 type \u7684\u5bf9\u8c61\u5982\u679c\u88ab passed by value\uff08\u4ee5\u503c\u4f20\u9012\uff09\uff0c\u610f\u5473\u7740\u4ec0\u4e48\uff1f copy \u6784\u9020\u51fd\u6570\u7528\u6765\u5b9a\u4e49\u4e00\u4e2a type \u7684 pass-by-value \u8be5\u5982\u4f55\u5b9e\u73b0\u3002 \u4ec0\u4e48\u662f\u65b0 type \u7684 \u201c\u5408\u6cd5\u503c\u201d\uff1f \u51b3\u5b9a\u4e86\u4f60\u7684 class \u5fc5\u987b\u7ef4\u62a4\u7684\u7ea6\u675f\u6761\u4ef6(invariants)\u3002 \u51b3\u5b9a\u4e86\u6210\u5458\u51fd\u6570\uff08\u5c24\u5176\u662f\u6784\u9020\u51fd\u6570\u3001\u8d4b\u503c\u64cd\u4f5c\u7b26\u548c\"setter\"\u51fd\u6570\uff09\u5fc5\u987b\u8fdb\u884c\u7684\u9519\u8bef\u68c0\u67e5\u5de5\u4f5c\u3002 \u5f71\u54cd\u51fd\u6570\u629b\u51fa\u7684\u5f02\u5e38\uff0c\u4ee5\u53ca\uff08\u6781\u5c11\u88ab\u4f7f\u7528\u7684\uff09\u51fd\u6570\u5f02\u5e38\u660e\u7ec6\u5217(exception specifications) \u4f60\u7684\u65b0 type \u9700\u8981\u914d\u5408\u67d0\u4e2a\u7ee7\u627f\u56fe\u7cfb(inheritance graph)\u5417\uff1f \u5982\u679c\u4f60\u7684 class \u7ee7\u627f\u81ea\u65e2\u6709 classes\uff0c \u5c31\u4f1a\u53d7\u5230\u5b83\u4eec\u7684\u7ea6\u675f\uff0c\u7279\u522b\u4f1a\u53d7\u5230\u5176\u51fd\u6570\u662f\u5426\u4e3a virtual \u7684\u5f71\u54cd \u5982\u679c\u4f60\u5141\u8bb8\u5176\u4ed6 classes \u7ee7\u627f\u4f60\u7684 class\uff08\u5426\u5219\u7684\u8bdd\u53ef\u4ee5\u58f0\u660e\u4e3a final \uff09\uff0c\u5c31\u4f1a\u5f71\u54cd\u4f60\u6240\u58f0\u660e\u7684\u51fd\u6570\u2014\u2014\u5c24\u5176\u662f\u6790\u6784\u51fd\u6570\u2014\u2014\u662f\u5426\u4e3a virtual\u3002 \u4f60\u7684\u65b0 type \u9700\u8981\u4ec0\u4e48\u6837\u7684\u8f6c\u6362\uff1f \u82e5\u5141\u8bb8\u9690\u5f0f\u8f6c\u6362\uff0c\u9700\u8981\u5b9a\u4e49\u7c7b\u578b\u8f6c\u6362\u51fd\u6570\uff08 Class1::operator Class2() \uff09\u6216\u5728 Class2 \u5185\u5199\u4e00\u4e2a non-explicit-one-argument\uff08\u53ef\u88ab\u5355\u4e00\u5b9e\u53c2\u8c03\u7528\uff09\u7684\u6784\u9020\u51fd\u6570\uff08\u5e76\u4ee5 Class1 \u4e3a\u53c2\uff09\u3002 \u82e5\u53ea\u5141\u8bb8\u663e\u793a\u8f6c\u6362\uff0c\u5219\u9700\u5b9a\u4e49\u8f6c\u6362\u51fd\u6570\u3002 \u4ec0\u4e48\u6837\u7684\u64cd\u4f5c\u7b26\u548c\u51fd\u6570\u5bf9\u6b64\u65b0 type \u800c\u8a00\u662f\u5408\u7406\u7684\uff1f \u4ec0\u4e48\u6837\u7684\u6807\u51c6\u51fd\u6570\u5e94\u8be5\u9a73\u56de\uff1f \u8fd9\u4e9b\u51fd\u6570\u5fc5\u987b\u58f0\u660e\u4e3a private\u3002 \u8c01\u8be5\u53d6\u7528\u65b0 type \u7684\u6210\u5458\uff1f \u51b3\u5b9a\u4e86\u6210\u5458\u7684 scope\u3002 \u51b3\u5b9a\u4e86\u5176\u4ed6\u7c7b/\u51fd\u6570\u5e94\u4e0d\u5e94\u8be5\u4f5c\u4e3a\u53cb\u5143\u3002 \u4ec0\u4e48\u662f\u65b0 type \u7684\u201c\u672a\u58f0\u660e\u63a5\u53e3(undeclared interface)\u201d\uff1f \u9700\u8981\u56de\u7b54\u5b83\u5bf9\u6548\u7387\u3001\u5f02\u5e38\u5b89\u5168\u6027\u4ee5\u53ca\u8d44\u6e90\u8fd0\u7528\uff08\u4f8b\u5982\u591a\u4efb\u52a1\u9501\u5b9a\u548c\u52a8\u6001\u5185\u5b58\uff09\u63d0\u4f9b\u4f55\u79cd\u4fdd\u8bc1\uff1f\u8fd9\u4e9b\u95ee\u9898\u4f1a\u4e3a\u5b9e\u73b0\u4ee3\u7801\u6dfb\u52a0\u7ea6\u675f\u6761\u4ef6\u3002 \u4f60\u7684\u65b0 type \u6709\u591a\u4e48\u4e00\u822c\u5316\uff1f \u5982\u679c\u4f60\u9700\u8981\u5b9a\u4e49\u4e00\u7cfb\u5217 types\uff0c\u6216\u8bb8\u4f60\u9700\u8981\u5b9a\u4e49\u4e00\u4e2a class template\u3002 \u4f60\u771f\u7684\u9700\u8981\u4e00\u4e2a\u65b0 type \u5417\uff1f","title":"\u6761\u6b3e19\uff1a\u8bbe\u8ba1class\u72b9\u5982\u8bbe\u8ba1type"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#20pass-by-lvalue-referencepass-by-lvalue-reference-to-constpass-by-value","text":"\u7531\u4e8e pass-by-value \u65b9\u5f0f\u4f20\u9012\u7684\u662f\u53c2\u6570\u7684\u526f\u672c\u3002\u6240\u4ee5\u5bf9\u67d0\u4e9b\u7c7b\u578b\u800c\u8a00\uff0c\u901a\u8fc7pass-by-value\u4f20\u9012\u4f1a\u9020\u6210\u989d\u5916\u7684\u6784\u9020\u548c\u6790\u6784\u5f00\u9500\u3002\u800c\u4ee5\u5f15\u7528\u65b9\u5f0f\u4f20\u53c2\uff08\u4ec5\u4f20\u6307\u9488\u7684\u526f\u672c\uff09\u5219\u4f1a\u964d\u4f4e\u8fd9\u4e9b\u5f00\u9500\u3002 by-reference \u4f20\u9012\u53ef\u4ee5\u907f\u514d slicing\uff08\u5bf9\u8c61\u5207\u5272\uff09\u95ee\u9898\u3002\u5982\u4e3a\u4e00\u4e2a\u63a5\u53d7 base class \u7684 by-value \u548c by-reference \u51fd\u6570\u4f20\u9012\u4e00\u4e2a derived class \u53c2\u6570\u3002\u524d\u8005\u53ea\u4f1a\u8c03\u7528 base class \u7684 copy \u51fd\u6570\u5e76\u83b7\u5f97 base class \u7684\u4e00\u4e2a\u526f\u672c\u3002\u800c\u540e\u8005\u5b9e\u9645\u6307\u5411\u4e00\u4e2a derived class \u5219\u53ef\u4ee5\u5e94\u7528 covariance\u3002\u8fd9\u4f1a\u5f71\u54cd\u5230\u8c03\u7528 virtual \u51fd\u6570\u7684\u903b\u8f91\u3002 \u7531\u4e8e\u5f15\u7528\u5b9e\u9645\u4e0a\u662f\u6307\u9488\u7684\u4e00\u79cd\u5c01\u88c5\uff0c\u6240\u4ee5\u5b83\u7684\u5f00\u9500\u4f1a\u7a0d\u5927\u4e8e\u7f16\u8bd1\u5668\u5185\u7f6e\u7c7b\u578b\u548cSTL\u7684\u8fed\u4ee3\u5668\u548c\u51fd\u6570\u5bf9\u8c61\u3002\u8fd9\u4e9b types \u90fd\u662f\u4e60\u60ef\u4e0a\u88ab\u8bbe\u8ba1\u4e3a passed-by-value \u7684\u3002 \u9664\u4e86\u4e0a\u8ff0 types \u5916\uff0c\u4e0d\u5efa\u8bae\u5c06\u5c0f types \u8bbe\u8ba1\u4e3a passed-by-value\u3002\u539f\u56e0\u6709\u4e8c\uff1a \u67d0\u4e9b\u7f16\u8bd1\u5668\u5728\u5bf9\u5f85\u201c\u5185\u7f6e\u7c7b\u578b\u201d\u548c\u201c\u7528\u6237\u81ea\u5b9a\u4e49\u7c7b\u578b\u201d\u7684\u6001\u5ea6\u622a\u7136\u4e0d\u540c\uff0c\u7eb5\u4f7f\u4e24\u8005\u6709\u76f8\u540c\u7684\u5e95\u5c42\u63cf\u8ff0(underlying representation)\u3002\u5982\u7f16\u8bd1\u5668\u4f1a\u5c06 double \u53d8\u91cf\u653e\u8fdb\u7f13\u5b58\u5668\u5185\uff0c\u5374\u62d2\u7edd\u5c06\u53ea\u542b\u4e00\u4e2a double \u6210\u5458\u53d8\u91cf\u7684\u5bf9\u8c61\u653e\u8fdb\u7f13\u5b58\u5668\u5185\uff08\u800c\u8fd9\u5b9e\u9645\u4e0a\u589e\u52a0\u4e86\u590d\u5236\u548c\u53d6\u503c\u7684\u5f00\u9500\uff09\u3002 \u7528\u6237\u81ea\u5b9a\u4e49 types \u7684\u5927\u5c0f\u662f\u4f1a\u6539\u53d8\u7684\u3002 pass-by-reference-to-const \u53ef\u4ee5\u6307\u5411 rvalue\u3002","title":"\u6761\u6b3e20\uff1a\u5b81\u4ee5pass-by-lvalue-reference\u548cpass-by-lvalue-reference-to-const\u66ff\u6362pass-by-value"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#21reference","text":"\u51fd\u6570\u521b\u5efa\u65b0\u5bf9\u8c61\u6709\u4e24\u79cd\u9014\u5f84\uff1a\u5728 Stack \u6216\u5728 Heap \u4e0a\u3002 \u51fd\u6570\u5185\u521b\u9020\u7684 local \u5bf9\u8c61\u5728 Stack \u5185\uff0c\u5176\u751f\u547d\u5468\u671f\u968f\u7740\u51fd\u6570\u7684\u7ed3\u675f\u800c\u7ed3\u675f\u3002 \u901a\u8fc7 new \u65b9\u6cd5\u83b7\u5f97\u7684\u5bf9\u8c61\u5728 Heap \u5185\uff0c\u9700\u8981\u624b\u52a8\uff08\u6216\u7528\u8d44\u6e90\u7ba1\u7406\u7c7b\uff09\u7ba1\u7406\u5176\u751f\u547d\u5468\u671f\u3002 \u82e5\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u5bf9\u8c61\u7684\u5f15\u7528\uff1a \u82e5\u8be5\u5bf9\u8c61\u5efa\u7acb\u5728 Stack \u4e0a\uff0c\u8fd4\u56de\u7684\u5f15\u7528\u5219\u4f1a\u6307\u5411\u4e00\u4e2a\u5df2\u6790\u6784\u7684\u5bf9\u8c61\u3002\u8fd9\u4f1a\u5bfc\u81f4ub\u3002 \u82e5\u8be5\u5bf9\u8c61\u5efa\u7acb\u5728 Heap \u4e0a\uff0c\u5ba2\u6237\u5f88\u6709\u53ef\u80fd\u4f1a\u5fd8\u8bb0\uff0c\u751a\u81f3\u6839\u672c\u610f\u8bc6\u4e0d\u5230\u8981\u91ca\u653e\u5b83\u4eec\u3002 \u82e5\u8fd4\u56de\u8be5\u7c7b\u7684 static \u5bf9\u8c61\u7684\u5f15\u7528\uff0c\u5219\u4f1a\u53d1\u751f\u591a\u7ebf\u7a0b\u5b89\u5168\u6027\u3001\u540c\u4e00\u8bed\u53e5\u5185\u6267\u884c\u9020\u6210\u7684ub\u95ee\u9898\u3002\uff08\u8fd9\u79cd\u4f8b\u5b50\u5f88\u96be\u4e0d\u8ba9\u8bfb\u8005\u53d1\u7b11\uff0c\u8111\u6d1e\u679c\u7136\u4e0d\u4e00\u822c\uff09 \u5efa\u7acb\u4e0a\u8ff0\u5bf9\u8c61\u672c\u8eab\u4e5f\u8981\u4ed8\u51fa\u6784\u9020\u51fd\u6570\u7684\u4ee3\u4ef7\u3002","title":"\u6761\u6b3e21\uff1a\u5fc5\u987b\u8fd4\u56de\u5bf9\u8c61\u65f6\uff0c\u522b\u5984\u60f3\u8fd4\u56de\u5176reference"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#22private","text":"","title":"\u6761\u6b3e22\uff1a\u5c06\u6210\u5458\u53d8\u91cf\u58f0\u660e\u4e3aprivate"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#_4","text":"\u5982\u679c\u6210\u5458\u53d8\u91cf\u90fd\u662f private \u7684\uff0c\u90a3\u4e48 public \u63a5\u53e3\u5185\u6bcf\u6837\u4e1c\u897f\u90fd\u662f\u51fd\u6570\u3002\u8fd9\u6837\u53ef\u4ee5\u65b9\u4fbf\u5ba2\u6237\u8bb0\u5fc6\uff08\u63a5\u53e3\u662f\u5426\u4e3a\u51fd\u6570\uff09\u548c\u4f7f\u7528\u3002","title":"\u8bed\u6cd5\u4e00\u81f4\u6027"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#_5","text":"\u901a\u8fc7\"getter\"\u548c\"setter\"\u51fd\u6570\u63d0\u4f9b\u5bf9\u6210\u5458\u53d8\u91cf\u7684\u201c\u4e0d\u51c6\u8bbf\u95ee\u201d\u3001\u201c\u53ea\u8bfb\u8bbf\u95ee\u201d\u3001\u201c\u8bfb\u5199\u8bbf\u95ee\u201d\u751a\u81f3\u201c\u53ea\u5199\u8bbf\u95ee\u201d\u3002 \u53ef\u4ee5\u63d0\u4f9b\u66f4\u597d\u7684\u5c01\u88c5\u6027\u3002\u5ba2\u6237\u65e0\u9700\u77e5\u6653\u7c7b\u5185\u90e8\u7684\u7ec6\u8282\uff0c\u6216\u662f\u67d0\u4e2a\u53d8\u91cf\u7684\u5177\u4f53\u529f\u80fd\u3002\u7531\u5b9e\u73b0\u8005\u4fdd\u8bc1\u6210\u5458\u53d8\u91cf\u88ab\u6b63\u786e\u4f7f\u7528\u3002 \u901a\u8fc7\u51fd\u6570\u8bbf\u95ee\u6210\u5458\u53d8\u91cf\u53ef\u4ee5\u786e\u4fdd class \u7684\u7ea6\u675f\u6761\u4ef6\u4fdd\u6301\u6709\u6548\uff0c\u4e14\u4f5c\u8005\u4fdd\u7559\u4e86\u65e5\u540e\u53d8\u66f4\u7684\u6743\u5229\u3002 \u9690\u85cf\u6210\u5458\u53d8\u91cf\u53ef\u4ee5\u4e3a\u53ef\u80fd\u7684\u5b9e\u73b0\u63d0\u4f9b\u5f39\u6027\uff0c\u4e0d\u5fc5\u53d7\u5230 public \u6210\u5458\u53d8\u91cf\u53ef\u80fd\u53d7\u5230\u7684\u675f\u7f1a\uff08\u5982\u53ef\u80fd\u6539\u53d8\u5ba2\u6237\u7801\uff09\u3002 \u6210\u5458\u53d8\u91cf\u7684\u5c01\u88c5\u6027\u4e0e\u201c\u6210\u5458\u53d8\u91cf\u7684\u5185\u5bb9\u6539\u53d8\u65f6\u6240\u7834\u574f\u7684\u4ee3\u7801\u6570\u91cf\u201d\u6210\u53cd\u6bd4\u3002\u6545\u800c protected \u4f5c\u7528\u57df\u540c\u6837\u4f1a\u53d7\u5230\u5176 derived class \u7684\u675f\u7f1a\u3002 \u6240\u4ee5\uff0c\u53ea\u6709\u4e24\u79cd\u8bbf\u95ee\u6743\u9650\uff1aprivate\uff08\u63d0\u4f9b\u5c01\u88c5\uff09\u548c\u5176\u4ed6\uff08\u4e0d\u63d0\u4f9b\u5c01\u88c5\uff09\u3002","title":"\u51fd\u6570\u53ef\u4ee5\u63d0\u4f9b\u5bf9\u6210\u5458\u53d8\u91cf\u66f4\u7cbe\u786e\u7684\u63a7\u5236"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#23non-membernon-friendmember","text":"\u63a8\u5d07\u5c01\u88c5\u7684\u539f\u56e0\uff1a\u5b83\u4f7f\u6211\u4eec\u80fd\u591f\u6539\u53d8\u4e8b\u7269\u800c\u53ea\u5f71\u54cd\u6709\u9650\u5ba2\u6237\u3002 \u5bf9 class \u6765\u8bf4\uff0c\u90a3\u4e9b\u53ef\u4ee5\u5b8c\u5168\u8c03\u7528 public \u63a5\u53e3\u5b8c\u6210\u7684\u529f\u80fd\uff0cmember\u51fd\u6570\u7684\u5c01\u88c5\u6027\u6bd4 non-member \u548c non-friend \u51fd\u6570\u7684\u5c01\u88c5\u6027\u8981\u4f4e\uff1a \u5982\u4e0a\u4e00\u6761\u6240\u8bf4\uff0c\u51fd\u6570\u7684\u5c01\u88c5\u6027\u53ef\u4e0e\u80fd\u8bbf\u95ee\u5b83\uff08\u6539\u53d8\u5185\u5bb9\u540e\u53ef\u80fd\u4f1a\u8feb\u5bb3\uff09\u7684\u4ee3\u7801\u7684\u6570\u91cf\u6210\u53cd\u6bd4\u3002non-member \u548c non-friend \u51fd\u6570\u4e0d\u4f1a\u964d\u4f4e class \u7684\u5c01\u88c5\u6027\uff08\u4e0d\u4f1a\u6709\u8bbf\u95ee private \u53d8\u91cf\u7684\u9690\u5fe7\uff09\u3002 \u5bf9\u4e8e Java\u3001C# \u800c\u8a00\uff0c\u8be5 class \u7684 non-member \u51fd\u6570\u53ef\u4ee5\u662f\u5176\u4ed6\u7c7b\u7684 member \u51fd\u6570\uff0c\u5982\u53ef\u80fd\u662f\u53e6\u4e00\u4e2a\u5de5\u5177\u51fd\u6570\u7684 static member function\u3002\u5bf9\u4e8e C++\u6765\u8bf4\uff0c\u8f83\u81ea\u7136\u7684\u505a\u6cd5\u662f\u8ba9\u8fd9\u4e2a non-member \u51fd\u6570\u4f4d\u4e8e\u548c class \u6240\u5728\u7684\u540c\u4e00\u4e2a namespace \u5185\u3002 \u4e0a\u8ff0\u505a\u6cd5\u7684\u597d\u5904\u5728\u4e8e\uff0cnamespace \u53ef\u4ee5\u8de8\u8d8a\u591a\u4e2a\u6587\u4ef6\uff0c\u800c classes \u4e0d\u80fd\u3002\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5c06\u4e0d\u540c\u7c7b\u578b\u7684 non-member \u548c non-friend \u51fd\u6570\u58f0\u660e\u5728\u4e0d\u540c\u5934\u6587\u4ef6\u5185\uff08\u5f53\u7136\uff0c\u58f0\u660e\u5728\u548c class \u76f8\u540c\u7684 namespace \u5185\uff09\u3002\u5141\u8bb8\u5ba2\u6237\u53ea\u5bf9\u4ed6\u4eec\u6240\u7528\u7684\u90a3\u4e00\u5c0f\u90e8\u5206\u7cfb\u7edf\u5f62\u6210\u7f16\u8bd1\u76f8\u4f9d\u3002 \u58f0\u660e\u5728 namespace \u5185\u540c\u6837\u65b9\u4fbf\u4e86\u5ba2\u6237\u6839\u636e\u9700\u6c42\u6269\u5c55\u8fd9\u4e9b non-member \u548c non-friend \u51fd\u6570\u3002","title":"\u6761\u6b3e23\uff1a\u5b81\u4ee5non-member\u3001non-friend\u66ff\u6362member\u51fd\u6570"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#24non-member","text":"\u53ea\u6709\u5f53\u53c2\u6570\u88ab\u5217\u4e8e\u53c2\u6570\u5217(parameter list)\u5185\uff0c\u8fd9\u4e2a\u53c2\u6570\u624d\u662f\u9690\u5f0f\u7c7b\u578b\u8f6c\u6362\u7684\u5408\u683c\u53c2\u4e0e\u8005\u3002 \u5047\u8bbe\u6211\u4eec\u8bbe\u8ba1\u4e00\u4e2a\u6709\u7406\u6570\u7c7b\uff0c\u5141\u8bb8 non-explicit \u8f6c\u6362\uff1a class Rational { public : Rational ( int numerator = 0 , int denominator = 1 ); // permit int2Ration transformation int numerator () const ; int denominator () const ; private : //details } \u82e5\u6211\u4eec\u91c7\u7528 member function of operator* \uff0c\u4ee3\u7801\u5982\u4e0b\uff1a class Rational { public : const Rational operator * ( const Rational & ); } const Rational Rational :: operator * ( const Rational & rhs ){ //details } int main (){ Rational oneQuarter ( 1 , 4 ); Rational result ; result = oneQuarter * 2 ; //valid, equal to Rational(2,1) * oneQuarter /** * The below way is invalid. * Cause the compiler called `2.operator*(const Rational &)` and failed. */ result = 2 * oneQuarter ; } \u7efc\u4e0a\uff0c\u4e3a\u4e86\u8ba9\u9690\u5f0f\u8f6c\u6362\u5bf9\u64cd\u4f5c\u7b26\uff08\u6216\u51fd\u6570\u4e24\u53c2\u6570\uff09\u90fd\u751f\u6548\uff0c\u5e94\u8be5\u5c06\u5176\u5b9a\u4e49\u4e3a\u4e00\u4e2a non-member \u7684\u51fd\u6570\u3002 const Rational operator * ( const Rational & lhs , const Rational & rhs ){ return Rational ( lhs . numerator * rhs . numerator , lhs . denominator * rhs . denominator ); } \u8fd9\u4e00\u8bbe\u8ba1\u5b88\u5219\u5728 Object-Oriented \u8bbe\u8ba1\u8303\u5f0f\u4e2d\u6709\u6548\u3002\u4f46\u5728 Template C++ \u8bbe\u8ba1\u4e2d\u5219\u8981\u8003\u8651\u65b0\u7684\u4e89\u8bae\u548c\u89e3\u6cd5\u3002\u8fd9\u4e9b\u4f1a\u5728\u7b2c46\u6761\u5efa\u8bae\u4e2d\u6307\u51fa\u3002","title":"\u6761\u6b3e24\uff1a\u82e5\u6240\u6709\u53c2\u6570\u7686\u9700\u8981\u7c7b\u578b\u8f6c\u6362\uff0c\u8bf7\u4ee5\u6b64\u91c7\u7528non-member\u51fd\u6570"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#25swap","text":"swap\u51fd\u6570\u662f\u5f02\u5e38\u5b89\u5168\u6027\u7f16\u7a0b(exception-safety programming)\u7684\u810a\u67f1\uff0c\u4e5f\u662f\u7528\u6765\u5904\u7406\u81ea\u8d4b\u503c\u53ef\u80fd\u6027\u7684\u4e00\u4e2a\u5e38\u89c1\u673a\u5236\u3002 \u7f3a\u7701\u60c5\u51b5\u4e0b swap \u52a8\u4f5c\u53ef\u7531\u6807\u51c6\u5e93\u63d0\u4f9b\u7684 swap \u7b97\u6cd5\u5b8c\u6210\uff0c\u5176\u5178\u578b\u5b9e\u73b0\u5982\u4e0b\uff08\u975e\u5e38non-economical\uff09 namespace std { template < typename T > void swap ( T & a , T & b ){ T temp ( a ); a = b ; b = temp ; } } \u8fd9\u79cd swap \u7b97\u6cd5\u5728\u7279\u6b8a\u6761\u4ef6\uff0c\u5982pimpl(pointer to implementation)\u65f6\uff0c\u662f\u4f4e\u6548\u7684\u3002\u8fd9\u65f6\u5019\u5c31\u9700\u8981\u4f60\u81ea\u5df1\u8bbe\u8ba1\u4e00\u4e2a swap \u51fd\u6570\uff08\u4ea4\u6362\u6307\u9488\u6765\u53d6\u7f14\u590d\u5236\u548c\u8d4b\u503c\u51fd\u6570\u7684\u5f00\u9500\uff09\u3002 \u4e3a\u4e86\u907f\u514d\u589e\u52a0\u989d\u5916\u7684 friend \u51fd\u6570\uff0c\u53ef\u4ee5\u5728\u7c7b\u5185\u5b9e\u73b0\u4e00\u4e2a public \u7684 swap \u51fd\u6570\uff0c\u968f\u540e\u5728\u7c7b\u5916\u7684\u7279\u5316 non-member swap function \u4e2d\u8c03\u7528\u5b83\u3002 \u4f60\u53ef\u4ee5\u901a\u8fc7\u4e3a std::swap() \u51fd\u6570\u63d0\u4f9b\u7279\u5316\u7248\u672c\u6765\u63d0\u9192\u7f16\u8bd1\u5668\u8c03\u7528\u5f00\u9500\u66f4\u5c0f\u7684\u90a3\u4e2a\uff1a class Widget { public : // details void swap ( Widget & rhs ) { /* details */ } private : // details } namespace std { template <> swap < Widget > ( Widget & a , Widget & b ){ a . swap ( b ); } } C++\u53ea\u5141\u8bb8\u5bf9 class templates \u504f\u7279\u5316\uff0c\u5728 function templates \u4e0a\u4e0d\u80fd\u504f\u7279\u5316\u3002\u8fd9\u79cd\u60c5\u51b5\u4e0b\u6211\u4eec\u5c06\u7279\u5316 swap \u51fd\u6570\u5b9a\u4e49\u5728\u4e0e\u7c7b\u76f8\u540c\u7684 namespace \u5185\u3002 namespace WidgetNS { template < typename T > class Widget { /*details*/ } } // The below type is invalid // error: non-class, non-variable partial specialization \u2018swap<Widget<T> >\u2019 is not allowed namespace std { template < typename T > swap < Widget < T >> ( Widget < T > & lhs , Widget < T > & rhs ){ lhs . swap ( rhs ); } } /** * The below type is valid * And the compiler will call WidgetNS::swap first * when you declare `using namespace std` and `WidgetNS` at the same time */ namespace WidgetNS { template < typename T > void swap ( Widget < T > & lhs , Widget < T > & rhs ) { lhs . swap ( rhs ); } } \u5982\u679c\u4f60\u8c03\u7528 swap\uff0c \u8bf7\u786e\u4fdd\u5305\u542b\u4e00\u4e2a using std::swap \u58f0\u660e\u5f0f\uff0c\u8ba9 std::swap \u5728\u51fd\u6570\u5185\u53ef\u89c1\u3002\u4ee5\u4fbf\u5728\u627e\u4e0d\u5230\u7279\u5316\u7248\u672c\u65f6\u53ef\u4ee5\u8c03\u7528\u8be5\u7f3a\u7701\u51fd\u6570\u3002 \u8fd9\u6837\uff0c\u5728\u4f60\u5e0c\u671b\u8c03\u7528\u7279\u5316\u7248\u672c\uff0c\u5426\u5219\u8c03\u7528 std \u5185\u7684\u7f3a\u7701\u7248\u672c\u65f6\u5e94\u5f53\u8fd9\u6837\u505a\uff1a template < typename T > void doSomething ( T & lhs , T & rhs ){ using std :: swap ; //details swap ( lhs , rhs ); //details } \u7531\u4e8e swap \u7684\u4e00\u4e2a\u5e94\u7528\u65f6\u5e2e\u52a9 classes\uff08\u548c class templates\uff09\u63d0\u4f9b\u5f3a\u70c8\u7684\u5f02\u5e38\u5b89\u5168\u6027(exception-safety)\u4fdd\u969c\u3002\u6240\u4ee5\u5bf9\u6b64\u7684\u4e00\u4e2a\u5047\u8bbe\u662f\uff1a\u4f5c\u4e3a\u6210\u5458\u51fd\u6570\u548c\u7c7b\u7684\u7279\u5316swap\u7edd\u4e0d\u629b\u51fa\u5f02\u5e38\u3002\u8fd9\u4e00\u7279\u6027\u5f80\u5f80\u548c swap \u51fd\u6570\u7684\u9ad8\u6548\u6027\u76f8\u5173\u8054\u3002\u56e0\u4e3a\u9ad8\u6548\u7387\u7684 swap \u51fd\u6570\u51e0\u4e4e\u603b\u662f\u57fa\u4e8e\u5bf9\u5185\u7f6e\u7c7b\u578b\u7684\u64cd\u4f5c\uff0c\u800c\u8fd9\u90e8\u5206\u64cd\u4f5c\u7edd\u4e0d\u4f1a\u629b\u51fa\u5f02\u5e38\u3002 \u4f46\u6807\u51c6\u5e93\u63d0\u4f9b\u7684 std::swap \u51fd\u6570\u7531\u4e8e\u8c03\u7528\u4e86\u590d\u5236\u548c\u8d4b\u503c\u64cd\u4f5c\u7b26\u51fd\u6570\u2014\u2014\u4e00\u822c\u60c5\u51b5\u4e0b\u8fd9\u4e24\u4e2a\u51fd\u6570\u90fd\u5141\u8bb8\u629b\u51fa\u5f02\u5e38\u2014\u2014\u4e0d\u4fdd\u8bc1\u5b83\u662f\u5f02\u5e38\u5b89\u5168\u7684\u3002","title":"\u6761\u6b3e25\uff1a\u8003\u8651\u5199\u51fa\u4e00\u4e2a\u4e0d\u629b\u51fa\u5f02\u5e38\u7684swap\u51fd\u6570"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#26","text":"\u6700\u597d\u5ef6\u540e\u53d8\u91cf\u5b9a\u4e49\u5f0f\u7684\u51fa\u73b0\u65f6\u95f4\uff0c\u76f4\u5230\u4f60\u771f\u7684\u9700\u8981\u5b83\u3002\u5426\u5219\u96be\u514d\u627f\u62c5\u591a\u4f59\u7684\u6784\u9020\u548c\u6790\u6784\u6210\u672c\u3002 \u5728\u5bf9\u8c61\u6784\u9020\u65f6\u671f\u5c31\u5e94\u8be5\u7ed9\u5b83\u4e00\u4e2a\u6709\u610f\u4e49\u7684\u521d\u503c\u800c\u975edefault\u6784\u9020\u51fd\u6570\u3002","title":"\u6761\u6b3e26\uff1a\u5c3d\u53ef\u80fd\u5ef6\u540e\u53d8\u91cf\u5b9a\u4e49\u5f0f\u7684\u51fa\u73b0\u65f6\u95f4"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#_6","text":"\u6210\u672c\uff1a \u5faa\u73af\u4e4b\u5916\uff1a1\u4e2a\u6784\u9020\u51fd\u6570 + 1\u4e2a\u6790\u6784\u51fd\u6570 + n\u4e2a\u8d4b\u503c\u64cd\u4f5c \u5faa\u73af\u4e4b\u5185\uff1an\u4e2a\u6784\u9020\u51fd\u6570 + n\u4e2a\u6790\u6784\u51fd\u6570 \u53ef\u7ef4\u62a4\u6027\uff1a \u5b9a\u4e49\u4e8e\u5faa\u73af\u4e4b\u5916\u7684\u53d8\u91cf\u4f5c\u7528\u57df\u66f4\u5927\uff0c\u6709\u65f6\u53ef\u80fd\u5bf9\u7a0b\u5e8f\u7684\u53ef\u7406\u89e3\u6027\u548c\u6613\u7ef4\u62a4\u6027\u9020\u6210\u51b2\u7a81\u3002 \u56e0\u6b64\u4e00\u822c\u60c5\u51b5\u4e0b\u63a8\u8350\u5b9a\u4e49\u5728\u5faa\u73af\u4e4b\u5185\uff0c\u9664\u975e\uff1a \u4f60\u77e5\u9053\u8d4b\u503c\u6210\u672c\u6bd4\u201c\u6784\u9020+\u6790\u6784\u201d\u6210\u672c\u4f4e\uff1b \u4f60\u6b63\u5728\u5904\u7406\u4ee3\u7801\u4e2d\u6548\u7387\u9ad8\u5ea6\u654f\u611f(performance-sensitive)\u7684\u90e8\u5206\u3002","title":"\u5728\u5faa\u73af\u4e2d\uff0c\u5c06\u53d8\u91cf\u58f0\u660e\u5728\u5faa\u73af\u4e4b\u5185\u8fd8\u662f\u4e4b\u5916"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#27","text":"C++\u89c4\u5219\u7684\u8bbe\u8ba1\u76ee\u6807\u4e4b\u4e00\u662f\uff1a\u4fdd\u8bc1\u201c\u7c7b\u578b\u9519\u8bef\u201d\u7edd\u4e0d\u53ef\u80fd\u53d1\u751f.\u7136\u800c\u8f6c\u578b(cast)\u7834\u574f\u4e86\u7c7b\u578b\u7cfb\u7edf(type system)\u3002\u76f8\u8f83C\u3001C#\u548cJava\uff0cC++\u7684\u8f6c\u578b\u66f4\u52a0\u5371\u9669\u3002 \u65e7\u5f0f\u8f6c\u578b(C-style casts)\uff1a ( T ) expression ; T ( expression ); C++\u63d0\u4f9b\u56db\u79cd\u65b0\u5f0f\u8f6c\u578b(C+-style casts)\uff1a const_cast < T > ( expression ); dynamic_cast < T > ( expression ); reinterpret_cast < T > ( expression ); static_cast < T > ( expression ); const_cast\uff1a\u7528\u4e8e\u5c06\u5bf9\u8c61\u7684\u5e38\u91cf\u6027\u8f6c\u9664(cast away the constness)\u3002 dynamic_cast\uff1a\u7528\u4e8e\u6267\u884c\u201c\u5b89\u5168\u5411\u4e0b\u8f6c\u578b\u201c(safe downcasting)\uff0c\u5b83\u5224\u65ad\u6307\u5411\u57fa\u7c7b\u7684\u6307\u9488\u662f\u5426\u5c5e\u4e8e\u4e00\u4e2a\u5b8c\u6574\u7684\u6d3e\u751f\u7c7b\uff0c\u5e76\u51b3\u5b9a\u662f\u5426\u8fdb\u884c\u7c7b\u578b\u8f6c\u6362\u3002\u5b83\u662f\u552f\u4e00\u65e0\u6cd5\u7531 C-style casts \u6267\u884c\u7684\u52a8\u4f5c\uff0c\u4e5f\u662f\u552f\u4e00\u53ef\u80fd\u8017\u8d39\u91cd\u5927\u8fd0\u884c\u6210\u672c\u7684\u8f6c\u578b\u52a8\u4f5c\u3002 reinterpret_cast\uff1a\u6267\u884c\u4f4e\u7ea7\u8f6c\u578b\uff0c\u5b9e\u9645\u52a8\u4f5c\uff08\u53ca\u7ed3\u679c\uff09\u53ef\u80fd\u53d6\u51b3\u4e8e\u7f16\u8bd1\u5668\u3002\u8fd9\u610f\u5473\u7740\u5b83\u4e0d\u53ef\u79fb\u690d\u3002\u5982\u5c06\u4e00\u4e2a pointer to int \u8f6c\u578b\u4e3a\u4e00\u4e2a int \u3002 static_cast\uff1a\u7528\u4e8e\u5f3a\u8feb\u9690\u5f0f\u8f6c\u6362(implicit conversions)\u3002 \u65b0\u5f0f\u8f6c\u578b\u7684\u4f18\u70b9\uff1a \u5f88\u5bb9\u6613\u5728\u4ee3\u7801\u4e2d\u88ab\u8fa8\u8bc6\u51fa\u6765\uff0c\u56e0\u6b64\u53ef\u4ee5\u7b80\u5316\u201d\u627e\u51fa\u7c7b\u578b\u7cfb\u7edf\u5728\u54ea\u4e2a\u5730\u70b9\u88ab\u7834\u574f\u201c\u7684\u8fc7\u7a0b \u5404\u8f6c\u578b\u52a8\u4f5c\u7684\u76ee\u6807\u7a84\u5316\uff0c\u7f16\u8bd1\u5668\u53ef\u80fd\u8bca\u65ad\u51fa\u9519\u8bef\u7684\u8fd0\u7528\u3002 \u7c7b\u578b\u8f6c\u6362\u5e76\u975e\u4e0d\u7528\u505a\u4efb\u4f55\u5de5\u4f5c\uff0c\u5982 int \u5411 double \u7c7b\u578b\u8f6c\u6362\u65f6\u9700\u8981\u66f4\u6539\u7f16\u7801\u65b9\u5f0f\u3002\u800c\u5728\u67d0\u4e9b\u65f6\u5019\u5219\u4f1a\u6d89\u53ca\u5230\u7f16\u8bd1\u5668\u7684\u5177\u4f53\u5b9e\u73b0\u7ec6\u8282(\u800c\u6709\u6240\u4e0d\u540c)\uff1a class Base { /*...*/ }; class Derived : public Base { /*...*/ }; Derived d ; Base * pb = & d ; \u5728\u4e0a\u8ff0\u4ee3\u7801\u4e2d\uff0c pb \u6240\u6307\u7684\u503c\u5e76\u4e0d\u4e00\u5b9a\u7b49\u4e8e &d \uff0c\u800c\u662f\u52a0\u4e0a\u4e86\u4e00\u4e2a\u504f\u79fb\u91cf\uff08\u60f3\u60f3\u4ec0\u4e48\u60c5\u51b5\u4e0b\u4f1a\u51fa\u73b0\u8fd9\u79cd\u60c5\u51b5\uff09\u3002\u8fd9\u4e00\u5b9e\u73b0\u65b9\u5f0f\u7531\u7f16\u8bd1\u5668\u5b9e\u73b0\u7684\u4e0d\u540c\u800c\u4e0d\u540c\u3002\u6240\u4ee5\u4e00\u822c\u60c5\u51b5\u4e0b\u6211\u4eec\u8981\u907f\u514d\u505a\u51fa\u201d\u5bf9\u8c61\u5728 C++ \u4e2d\u5982\u4f55\u5e03\u5c40\u201c\u7684\u5047\u8bbe\uff0c\u4e5f\u4e0d\u5e94\u8be5\u4ee5\u6b64\u5047\u8bbe\u4e3a\u57fa\u7840\u6267\u884c\u4efb\u4f55\u8f6c\u578b\u52a8\u4f5c\u3002 \u5bf9\u4e8evirtual\u51fd\u6570\uff0cderived classes \u901a\u8fc7\u8f6c\u578b\u6765\u8c03\u7528 base class \u7684\u51fd\u6570\u5b9e\u9645\u4e0a\u662f\u884c\u4e0d\u901a\u7684\u3002\u56e0\u4e3a\u6307\u9488\u6240\u6307\u7684\u5bf9\u8c61\u5b9e\u9645\u4e0a\u6ca1\u6709\u5dee\u522b\u3002\u5982\u679c\u60f3\u8981\u8c03\u7528 base class \u7684\u51fd\u6570\uff0c\u9700\u8981\u8fd9\u6837\u58f0\u660e\uff1a class Derived : public Base { public : virtual void ChangeSth (){ Base :: ChangeSth (); /*...*/ } /*...*/ } dynamic_cast \u7684\u8bb8\u591a\u5b9e\u73b0\u7248\u672c\u6267\u884c\u901f\u5ea6\u76f8\u5f53\u6162\uff0c\u5728\u6df1\u5ea6\u7ee7\u627f\u6216\u591a\u91cd\u7ee7\u627f\u65f6\u8fd9\u79cd\u6210\u672c\u5f00\u9500\u5c24\u751a\u3002\u6709\u4e24\u79cd\u505a\u6cd5\u53ef\u4ee5\u907f\u514d\u591a\u6b21\u4f7f\u7528 dynamic_cast \u5e26\u6765\u7684\u5927\u91cf\u5f00\u9500\uff1a \u4f7f\u7528\u5bb9\u5668\u5e76\u5728\u5176\u4e2d\u5b58\u50a8\u76f4\u63a5\u6307\u5411 derived class \u5bf9\u8c61\u7684\u6307\u9488\uff08\u901a\u5e38\u662f\u667a\u80fd\u6307\u9488\uff09\u3002\u5982\u6b64\u4fbf\u6d88\u9664\u4e86\u201c\u901a\u8fc7 base class \u63a5\u53e3\u5904\u7406\u5bf9\u8c61\u201d\u7684\u9700\u8981\u3002 \u4f46\u8fd9\u79cd\u65b9\u6cd5\u65e0\u6cd5\u7528\u4e00\u4e2a\u5bb9\u5668\u50a8\u5b58\u6307\u9488\u6307\u5411\u6240\u6709\u53ef\u80fd\u7684\u6d3e\u751f\u7c7b\u3002\u6216\u9700\u8981\u591a\u4e2a\u5bb9\u5668\uff0c\u4e14\u90fd\u5fc5\u987b\u5177\u5907\u7c7b\u578b\u5b89\u5168\u6027(type-safe)\u3002 \u5728 base class \u5185\u5b9a\u4e49 virtual \u63a5\u53e3\u3002\u8ba9\u6d3e\u751f\u7c7b\u7ee7\u627f\u800c\u975e\u8986\u76d6\u63a5\u53e3\u3002 \u6b64\u5916\uff0c\u4e00\u5b9a\u8981\u675c\u7edd\u8fde\u4e32 dynamic_cast \uff0c\u6bd4\u65b9\u8bf4\u5728\u6bcf\u4e2a if \u5206\u652f\u5185\u90fd\u8c03\u7528 dynamic_cast \u3002\u8fd9\u79cd\u505a\u6cd5\u603b\u5e94\u8be5\u7528 virtual \u51fd\u6570\u4ee3\u66ff\u4e4b\u3002","title":"\u6761\u6b3e27\uff1a\u5c3d\u91cf\u5c11\u505a\u8f6c\u578b\u52a8\u4f5c"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#28handles","text":"","title":"\u6761\u6b3e28\uff1a\u907f\u514d\u8fd4\u56dehandles\u6307\u5411\u5bf9\u8c61\u5185\u90e8\u6210\u5206"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#_7","text":"\u6210\u5458\u53d8\u91cf\u7684\u5c01\u88c5\u6027\u6700\u591a\u53ea\u7b49\u4e8e\u201c\u8fd4\u56de\u5176 reference\u201d\u7684\u51fd\u6570\u7684\u8bbf\u95ee\u7ea7\u522b\u3002 \u82e5 const \u6210\u5458\u51fd\u6570\u4f20\u51fa\u4e00\u4e2a reference\uff0c\u4e14\u540e\u8005\u6240\u6307\u6570\u636e\u4e0e\u5bf9\u8c61\u81ea\u8eab\u6709\u5173\u8054\uff0c\u800c\u5b83\u53c8\u88ab\u50a8\u5b58\u4e8e\u5bf9\u8c61\u4e4b\u5916\uff08\u5982\u5bf9\u8c61\u7684\u4e00\u4e2a\u6307\u9488\u6210\u5458\u53d8\u91cf\u6240\u6307\u7684\u503c\u7684reference\uff09\uff0c\u90a3\u4e48\u8fd9\u4e2a\u51fd\u6570\u7684\u8c03\u7528\u8005\u53ef\u4ee5\u4fee\u6539\u90a3\u4e2a\u6570\u636e\u3002 references\u3001pointers \u548c iterators \u90fd\u662f handles\u3002\u51fd\u6570\u8fd4\u56de\u5b83\u4eec\u90fd\u53ef\u80fd\u964d\u4f4e\u5bf9\u8c61\u5c01\u88c5\u6027\uff0c\u4e5f\u53ef\u80fd\u9020\u6210\u201c\u8c03\u7528 const \u6210\u5458\u51fd\u6570\u5374\u9020\u6210\u5bf9\u8c61\u72b6\u6001\u88ab\u66f4\u6539\u201d\u7684\u95ee\u9898\u3002","title":"\u5f71\u54cd\u5bf9\u8c61\u5c01\u88c5\u6027"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#dangling-handles","text":"\u5982\u4fdd\u7559\u4e00\u4e2ahandle\u8d85\u8fc7\u5b83\u7684\u5bf9\u8c61\u7684\u751f\u547d\u5468\u671f\u2026\u2026","title":"\u9020\u6210 Dangling Handles"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#29","text":"","title":"\u6761\u6b3e29\uff1a\u4e3a\u201c\u5f02\u5e38\u5b89\u5168\u201d\u800c\u52aa\u529b\u662f\u503c\u5f97\u7684"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#_8","text":"\u5f53\u5f02\u5e38\u88ab\u629b\u51fa\u65f6\uff0c\u5e26\u6709\u5f02\u5e38\u5b89\u5168\u6027\u7684\u51fd\u6570\u4f1a\uff1a \u4e0d\u6cc4\u9732\u4efb\u4f55\u8d44\u6e90\uff1a\u4ee5\u5bf9\u8c61\u65b9\u6cd5\u7ba1\u7406\u8d44\u6e90\u3002 \u4e0d\u5141\u8bb8\u6570\u636e\u7834\u574f\u3002","title":"\u5f02\u5e38\u5b89\u5168\u6027\u7684\u4e24\u4e2a\u6761\u4ef6"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#exception-safe-functions","text":"\u57fa\u672c\u627f\u8bfa\uff1a\u82e5\u5f02\u5e38\u88ab\u629b\u51fa\uff0c\u7a0b\u5e8f\u5185\u7684\u4efb\u4f55\u4e8b\u7269\u4ecd\u7136\u4fdd\u6301\u5728\u6709\u6548\u72b6\u6001\u4e0b\u3002\u6ca1\u6709\u4efb\u4f55\u5bf9\u8c61\u6216\u6570\u636e\u7ed3\u6784\u4f1a\u56e0\u6b64\u88ab\u7834\u574f\uff08\u5982\u6240\u6709\u7684 class \u7ea6\u675f\u90fd\u7ee7\u7eed\u83b7\u5f97\u6ee1\u8db3\uff0c\u6216\u6240\u6709\u5bf9\u8c61\u7684\u6307\u9488\u90fd\u4e0d\u7a7a\u60ac\uff09\u3002\u4f46\u7a0b\u5e8f\u7684\u73b0\u5b9e\u72b6\u6001(exact state)\u6050\u6015\u4e0d\u53ef\u9884\u6599\u3002\u5982\u629b\u51fa\u5f02\u5e38\u540e\u5bf9\u8c61\u53d8\u6210\u7f3a\u7701\u503c\u3002\u987e\u5ba2\u53ef\u80fd\u5fc5\u987b\u8c03\u7528\u67d0\u4e2a\u6210\u5458\u51fd\u6570\u624d\u77e5\u9053\u5bf9\u8c61\u5b9e\u9645\u4e0a\u53d8\u6210\u4e86\u4ec0\u4e48\uff08\u5c3d\u7ba1\u5bf9\u8c61\u4f9d\u7136\u662f\u5408\u6cd5\u7684\uff09\u3002 \u5f3a\u70c8\u4fdd\u8bc1\uff1a\u5982\u679c\u5f02\u5e38\u88ab\u629b\u51fa\uff0c\u7a0b\u5e8f\u72b6\u6001\u4e0d\u6539\u53d8\u3002\u8c03\u7528\u8fd9\u6837\u7684\u51fd\u6570\u6709\u4e24\u79cd\u7ed3\u679c\uff1a\u51fd\u6570\u6267\u884c\u5b8c\u5168\u6210\u529f\uff1b\u6216\u662f\u629b\u51fa\u5f02\u5e38\u540e\u7a0b\u5e8f\u4f1a\u56de\u590d\u5230\u201c\u8c03\u7528\u51fd\u6570\u4e4b\u524d\u201d\u7684\u72b6\u6001\u3002 \u4e0d\u629b\u63b7(nothrow)\u4fdd\u8bc1\uff1a\u627f\u8bfa\u7edd\u4e0d\u629b\u51fa\u5f02\u5e38\uff0c\u56e0\u4e3a\u5b83\u4eec\u603b\u662f\u80fd\u591f\u5b8c\u6210\u5b83\u4eec\u539f\u5148\u627f\u8bfa\u7684\u529f\u80fd\u3002\u4f5c\u7528\u4e8e\u5185\u7f6e\u7c7b\u578b\uff08\u5982 int \uff0c\u6307\u9488\u7b49\u7b49\uff09\u8eab\u4e0a\u7684\u6240\u6709\u64cd\u4f5c\u90fd\u63d0\u4f9b nothrow \u4fdd\u8bc1\u3002\u8fd9\u662f\u5f02\u5e38\u5b89\u5168\u4ee3\u7801(Exception-safe code)\u4e2d\u4e00\u4e2a\u5fc5\u4e0d\u53ef\u5c11\u7684\u5173\u952e\u57fa\u7840\u6750\u6599\u3002","title":"\u5f02\u5e38\u5b89\u5168\u51fd\u6570(Exception-safe functions)\u63d0\u4f9b\u4ee5\u4e0b\u4e09\u4e2a\u4fdd\u8bc1\u4e4b\u4e00"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#_9","text":"\u4e00\u79cd\u63d0\u4f9b \u5f3a\u70c8\u4fdd\u8bc1 \u7684\u65b9\u5f0f\u662f copy and swap\uff1a\u4e3a\u4f60\u6253\u7b97\u4fee\u6539\u7684\u5bf9\u8c61\uff08\u539f\u4ef6\uff09\u505a\u51fa\u4e00\u4e2a\u526f\u672c\uff0c\u7136\u540e\u5728\u526f\u672c\u4e0a\u505a\u4e00\u5207\u5fc5\u8981\u4fee\u6539\u3002\u82e5\u4efb\u4f55\u4fee\u6539\u52a8\u4f5c\u629b\u51fa\u5f02\u5e38\uff0c\u539f\u5bf9\u8c61\u4ecd\u7136\u4fdd\u6301\u672a\u6539\u53d8\u72b6\u6001\u3002\u5f85\u6240\u6709\u6539\u53d8\u90fd\u6210\u529f\u540e\uff0c\u518d\u5c06\u4fee\u6539\u8fc7\u7684\u90a3\u4e2a\u526f\u672c\u548c\u539f\u5bf9\u8c61\u5728\u4e00\u4e2a\u4e0d\u629b\u51fa\u5f02\u5e38\u7684\u64cd\u4f5c\u4e2d\u7f6e\u6362(swap)\u3002\uff08\u53ef\u53c2\u7167\u6761\u6b3e25\uff09 \u5b9e\u73b0\u4e0a\u901a\u5e38\u662f\u5c06\u6240\u6709\u201c\u96b6\u5c5e\u5bf9\u8c61\u7684\u6570\u636e\u201d\u4ece\u539f\u5bf9\u8c61\u653e\u8fdb\u53e6\u4e00\u4e2a\u5bf9\u8c61\uff08\u4e00\u822c\u4e3a struct \uff0c\u56e0\u4e3a\u6570\u636e\u7684\u5c01\u88c5\u6027\u5df2\u7ecf\u7531 private scope \u4fdd\u8bc1\u4e86\u3002\u5c06\u6570\u636e\u653e\u5728 struct \u5185\u6709\u52a9\u4e8e\u7c7b\u6210\u5458\u65b9\u6cd5\u76f4\u63a5\u8c03\u7528\u5b83\u4eec\uff09\u5185\uff0c\u7136\u540e\u8d4b\u4e88\u539f\u5bf9\u8c61\u4e00\u4e2a\u6307\u9488\uff0c\u6307\u5411\u90a3\u4e2a\u5b9e\u73b0\u5bf9\u8c61(implement object)\u3002\u8fd9\u79cd\u624b\u6cd5\u5e38\u88ab\u79f0\u4e3a pimpl idiom\u3002","title":"\u5bf9\u5f3a\u70c8\u4fdd\u8bc1\u7684\u8ba8\u8bba"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#side-effects","text":"\u8fd9\u79cd copy-and-swap \u7b56\u7565\u662f\u5bf9\u5bf9\u8c61\u72b6\u6001\u505a\u51fa\u201c\u5168\u6709\u6216\u5168\u65e0\u201d\u6539\u53d8\u7684\u4e00\u4e2a\u5f88\u597d\u529e\u6cd5\uff0c\u4f46\u4e00\u822c\u800c\u8a00\u5b83\u5e76\u4e0d\u4fdd\u8bc1\u6574\u4e2a\u51fd\u6570\u6709\u5f3a\u70c8\u7684\u5f02\u5e38\u5b89\u5168\u6027\u3002\u8003\u8651\u4e00\u4e2a\u4f7f\u7528 copy-and-swap \u7b56\u7565\u7684\u51fd\u6570 someFuc \uff0c \u4f46\u8be5\u51fd\u6570\u5185\u8fd8\u5305\u62ec\u5bf9\u53e6\u5916\u4e24\u4e2a\u51fd\u6570 f1 \u548c f2 \u7684\u8c03\u7528\u3002\u5176\u4e2d f1 \u548c f2 \u51fd\u6570\u7ba1\u7406\u4e00\u90e8\u5206 non-local data\uff1a void someFuc (){ /*\u5bf9 local \u72b6\u6001\u505a\u4e00\u4efd\u526f\u672c*/ f1 (); f2 (); /*\u5c06\u4fee\u6539\u540e\u7684\u72b6\u6001\u7f6e\u6362\u8fc7\u6765*/ } \u5982\u679c f1 \u548c f2 \u7684\u5f02\u5e38\u5b89\u5168\u6027\u6bd4\u201c\u5f3a\u70c8\u4fdd\u8bc1\u201d\u4f4e\uff0c\u5c31\u5f88\u96be\u8ba9 someFuc \u6210\u4e3a\u201c\u5f3a\u70c8\u5f02\u5e38\u5b89\u5168\u201d\u3002 \u5373\u4f7f f1 \u548c f2 \u90fd\u662f\u201c\u5f3a\u70c8\u4fdd\u8bc1\u201d\u7684\uff0c\u6211\u4eec\u4ecd\u7136\u4e0d\u80fd\u4fdd\u8bc1 someFuc \u7684\u5f02\u5e38\u5b89\u5168\u6027\u3002\u4f8b\u5982 f1 \u6b63\u5e38\u6267\u884c\uff08\u5df2\u7ecf\u6539\u53d8\u4e86\u7a0b\u5e8f\u72b6\u6001\uff09\u4f46 f2 \u629b\u51fa\u5f02\u5e38\u3002","title":"\u8fde\u5e26\u5f71\u54cd(side effects)"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#_10","text":"copy \u548c swap \u52a8\u4f5c\u4f1a\u8017\u8d39\u53ef\u80fd\u65e0\u6cd5\uff08\u6216\u4e0d\u613f\uff09\u4ed8\u51fa\u7684\u8d44\u6e90\u3002 \u5f53\u201c\u5f3a\u70c8\u4fdd\u8bc1\u201d\u4e0d\u5207\u5b9e\u9645\u65f6\uff0c\u5fc5\u987b\u63d0\u4f9b\u201c\u57fa\u672c\u4fdd\u8bc1\u201d\u3002\u5426\u5219\uff0c\u5f53\u7cfb\u7edf\u91cc\u6709\u4e00\u4e2a\u51fd\u6570\u4e0d\u5177\u5907\u5f02\u5e38\u5b89\u5168\u6027\uff0c\u5219\u6574\u4e2a\u7cfb\u7edf\u90fd\u4e0d\u5177\u5907\u5f02\u5e38\u5b89\u5168\u6027\u3002","title":"\u6548\u7387"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#30inline","text":"","title":"\u6761\u6b3e30\uff1a\u900f\u5f7b\u4e86\u89e3inline\u7684\u91cc\u91cc\u5916\u5916"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#_11","text":"inline \u51fd\u6570\u6ca1\u6709\u51fd\u6570\u8c03\u7528\u7684\u635f\u5931\uff08\u5982context\u5165\u6808\u7b49\uff09\uff0c\u800c\u4e14\u65b9\u4fbf\u7f16\u8bd1\u5668\u5bf9\u5b83\u6267\u884c\u8bed\u5883\u76f8\u5173\u6700\u4f18\u5316\u3002 \u53ea\u56e0\u8be5\u5e94\u8be5\u5bf9\u7a0b\u5e8f\u8c03\u7528\u6700\u591a\uff08\u8fd9\u79cd\u51fd\u6570\u5e94\u8be5\u6781\u81f4\u4f18\u5316\uff09\u3001\u6216\u662f\u5341\u5206\u5e73\u6de1\u65e0\u5947\u4e00\u5b9a\u8981\u8bbe\u4e3a inline \u7684\u51fd\u6570\u7533\u8bf7 inline\u3002","title":"\u4f18\u70b9"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#_12","text":"inline \u51fd\u6570\u7684\u89c2\u5ff5\u662f\uff0c\u5c06\u201c\u5bf9\u6b64\u51fd\u6570\u7684\u6bcf\u4e00\u4e2a\u8c03\u7528\u201d\u90fd\u4ee5\u51fd\u6570\u672c\u4f53\u66ff\u4ee3\u3002\u8fd9\u6837\u505a\u53ef\u80fd\u4f1a\u589e\u52a0\u76ee\u6807\u7801(object code)\u7684\u5927\u5c0f\u3002\u5728\u5185\u5b58\u6709\u9650\u7684\u673a\u5668\u4e0a\uff0c\u8fc7\u5ea6\u8ffd\u6c42inlining \u4f1a\u9020\u6210\u7a0b\u5e8f\u4f53\u79ef\u592a\u5927\u3002\u5373\u4f7f\u62e5\u6709\u865a\u5185\u5b58\uff0c inline \u9020\u6210\u7684\u4ee3\u7801\u81a8\u80c0\u4e5f\u4f1a\u5bfc\u81f4\u989d\u5916\u7684\u6362\u9875\u884c\u4e3a(paging)\u3002\u964d\u4f4e\u6307\u4ee4\u9ad8\u901f\u7f13\u5b58\u88c5\u7f6e\u7684\u51fb\u4e2d\u7387(instruction cache hit rate)\uff0c\u4ee5\u53ca\u4f34\u968f\u800c\u6765\u7684\u6548\u7387\u635f\u5931\u3002 inline \u51fd\u6570\u4e0d\u4f1a\u968f\u7740\u7a0b\u5e8f\u5347\u7ea7\u800c\u5347\u7ea7\u3002\u5982\u4e00\u4e2a\u5e93\u51fd\u6570\u6539\u53d8\u4e00\u4e2a inline \u51fd\u6570 f \uff0c\u5219\u6240\u6709\u5ba2\u6237\u7a0b\u5e8f\u90fd\u8981\u91cd\u65b0\u7f16\u8bd1\u3002\u5426\u5219\u4ec5\u9700\u91cd\u65b0\u8fde\u63a5\u5373\u53ef\u3002 \u4ece\u7a0b\u5e8f\u5f00\u53d1\u89d2\u5ea6\uff0c inline \u51fd\u6570\u7531\u4e8e\u5b9e\u9645\u4e0a\u4e0d\u5b58\u5728\u51fd\u6570\u4f53\uff0c\u6240\u4ee5\u96be\u4ee5\u8c03\u8bd5\uff08\u65e0\u6cd5\u6253\u65ad\u70b9\u7b49\uff09\u3002 inline \u51fd\u6570\u901a\u5e38\u4e00\u5b9a\u88ab\u7f6e\u4e8e\u5934\u6587\u4ef6\u5185\u3002\u56e0\u4e3a\u5927\u591a\u6570\u5efa\u7f6e\u73af\u5883(build environments)\u5728\u7f16\u8bd1\u8fc7\u7a0b\u4e2d\u8fdb\u884c inlining \u884c\u4e3a\u3002\u6240\u4ee5\u7f16\u8bd1\u5668\u9700\u8981\u77e5\u9053\u5b83\u957f\u4ec0\u4e48\u6837\u5b50\u3002 inline \u662f\u5bf9\u7f16\u8bd1\u5668\u7684\u4e00\u4e2a\u7533\u8bf7\uff0c\u6709\u9690\u5f0f\u548c\u663e\u793a\u4e24\u79cd\u65b9\u5f0f\uff1a \u9690\u5f0f\uff1a\u5c06\u51fd\u6570\u5b9a\u4e49\u4e8e class \u4f53\u5185\uff08\u800c\u975e\u5728 class \u5185\u58f0\u660e\u5728 class \u5916\u5b9a\u4e49\uff09\u3002 \u663e\u5f0f\uff1a\u5728\u51fd\u6570\u58f0\u660e\u5f0f\u524d\u52a0 inline \u3002 \u4f46\u8be5\u51fd\u6570\u5b9e\u9645\u4e0a\u4f1a\u4e0d\u4f1a\u88ab\u7f16\u8bd1\u4e3a\u4e00\u4e2a inline \u51fd\u6570\u5b9e\u9645\u4e0a\u53d6\u51b3\u4e8e\u7f16\u8bd1\u5668\u3002\u7f16\u8bd1\u5668\u4f1a\u62d2\u7edd inlining \u6cf0\u56fd\u590d\u6742\u7684\u51fd\u6570\uff08\u5982\u5e26\u6709\u5faa\u73af\u6216\u9012\u5f52\uff09\u3002\u800c\u6240\u6709 virtual \u51fd\u6570\u7684 inline \u7533\u8bf7\u90fd\u4f1a\u88ab\u62d2\u7edd\uff08\u56e0\u4e3a virtual \u51fd\u6570\u7684\u8c03\u7528\u662f\u5728\u8fd0\u884c\u671f\u95f4\u51b3\u5b9a\u7684\uff09\u3002 \u82e5\u7a0b\u5e8f\u8981\u53d6\u67d0\u4e2a inline \u51fd\u6570\u7684\u6307\u9488\uff0c\u5219\u7f16\u8bd1\u5668\u4f1a\u4e3a\u8fd9\u4e2a\u51fd\u6570\u751f\u6210\u4e00\u4efd outline \u7684\u672c\u4f53\u3002\u800c\u5728\u8c03\u7528\u5b83\u7684\u51fd\u6570\u4f53\u5185\u8fdb\u4e0d\u8fdb\u884c inlining \u53d6\u51b3\u4e8e\u7f16\u8bd1\u5668\u3002 \u6784\u9020\u548c\u6790\u6784\u51fd\u6570\u4e0d\u662f\u597d\u7684 inlining \u5bf9\u8c61\u3002\u56e0\u4e3a\u5f88\u96be\u786e\u5b9a\u7f16\u8bd1\u5668\u4f1a\u4e3a\u8fd9\u4e24\u4e2a\u51fd\u6570\u586b\u5145\u4ec0\u4e48\u5185\u5bb9\u3002\u800c\u4e14\u591a\u7ee7\u627f\u7684 inline \u51fd\u6570\u4e00\u5b9a\u4f1a\u9020\u6210\u5bf9\u8c61\u7801\u7684\u81a8\u80c0\u3002","title":"\u7f3a\u70b9"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#31","text":"\u4ee5\u201c\u58f0\u660e\u7684\u4f9d\u5b58\u6027\u201d\u4ee3\u66ff\u201c\u5b9a\u4e49\u7684\u4f9d\u5b58\u6027\u201d\uff1a\u73b0\u5b9e\u4e2d\u8ba9\u5934\u6587\u4ef6\u5c3d\u53ef\u80fd\u81ea\u6211\u6ee1\u8db3\uff0c\u5426\u5219\u8ba9\u5b83\u4e0e\u5176\u4ed6\u6587\u4ef6\u5185\u7684\u58f0\u660e\u5f0f\uff08\u800c\u975e\u5b9a\u4e49\u5f0f\uff09\u76f8\u4f9d\u3002\u8fd9\u4e2a\u7b56\u7565\u5305\u542b\u4ee5\u4e0b\u5185\u5bb9\uff1a \u5982\u679c\u4f7f\u7528 object references \u6216 object pointers \u53ef\u4ee5\u5b8c\u6210\u4efb\u52a1\uff0c\u5c31\u4e0d\u8981\u4f7f\u7528 objects\u3002 \u6211\u4eec\u53ef\u4ee5\u53ea\u9760\u4e00\u4e2a\u7c7b\u578b\u58f0\u660e\u5f0f\u5c31\u5b9a\u4e49\u51fa\u6307\u5411\u8be5\u7c7b\u578b\u7684 references \u548c pointers\u3002\u5982\u679c\u5b9a\u4e49\u67d0\u7c7b\u578b\u7684 objects\uff0c \u5c31\u9700\u8981\u7528\u5230\u8be5\u7c7b\u578b\u7684\u5b9a\u4e49\u5f0f\u3002 \u5982 pimpl idiom \u8bbe\u8ba1\u6a21\u5f0f\u3002\u5c06\u63a5\u53e3\u7c7b\u9700\u8981\u7684\u6210\u5458\u53d8\u91cf\u5c01\u88c5\u5230\u4e00\u4e2a\u5b9e\u73b0\u7c7b(ClassImpl)\u5185\uff0c\u518d\u8ba9\u63a5\u53e3\u7c7b\u5185\u53ea\u542b\u4e00\u4e2a\u6307\u5411\u8be5\u5b9e\u73b0\u7c7b\u7684\u6307\u9488\u6210\u5458\u3002\u8fd9\u6837\u5c31\u5b9e\u73b0\u4e86\u201c\u63a5\u53e3\u4e0e\u5b9e\u73b0\u5206\u79bb\u201d\u3002 \u53e6\u4e00\u79cd\u65b9\u5f0f\u662f\u5728\u5934\u6587\u4ef6\u4e2d\u4ee5 interface class \u4ee3\u66ff class \u7684\u5177\u4f53\u5b9e\u73b0\u3002 \u5982\u679c\u53ef\u4ee5\u7684\u8bdd\uff0c\u5c3d\u91cf\u4ee5 class \u58f0\u660e\u5f0f\u66ff\u6362 class \u5b9a\u4e49\u5f0f\u3002 \u4e3a\u58f0\u660e\u5f0f\u548c\u5b9a\u4e49\u5f0f\u63d0\u4f9b\u4e0d\u540c\u7684\u5934\u6587\u4ef6\u3002 \u4e3a\u58f0\u660e\u5f0f\u63d0\u4f9b\u5355\u72ec\u7684\u5934\u6587\u4ef6\u800c\u975e\u5728\u4e0d\u540c\u5b9e\u73b0\u6587\u4ef6\u4e2d\u524d\u7f6e\u58f0\u660e\u82e5\u5e72\u51fd\u6570\u3002\u53ea\u542b\u5934\u6587\u4ef6\u7684\u6587\u4ef6\u540d\u5efa\u8bae\u4e3a\"<\u5e93\u540d>fwd.h\"\u3002\u8fd9\u79cd\u547d\u540d\u65b9\u5f0f\u6765\u6e90\u4e8e\u6807\u51c6\u5e93\u7684\"<iosfwd>\"\uff0c\u5b83\u5185\u542b iostream \u5404\u7ec4\u4ef6\u7684\u58f0\u660e\u5f0f\u3002 \u5b9a\u4e49\u5f0f\u5934\u6587\u4ef6\u4e00\u65b9\u9762\u4e3a\u5ba2\u6237\u5b9a\u4e49\u63a5\u53e3\uff0c\u53e6\u4e00\u65b9\u9762\u7528\u4e8e\u94fe\u63a5\u6e90\u6587\u4ef6\u3002 \u67d0\u4e9b\u5efa\u7f6e\u73af\u5883(build environments)\u5141\u8bb8\u5c06 template \u5b9a\u4e49\u5f0f\u653e\u5728\u201c\u975e\u5934\u6587\u4ef6\u201d\u5185\u3002\u8fd9\u6837\u5c31\u53ef\u4ee5\u5c06\u201c\u53ea\u542b\u58f0\u660e\u5f0f\u201d\u7684\u5934\u6587\u4ef6\u63d0\u4f9b\u7ed9 templates\u3002","title":"\u6761\u6b3e31\uff1a\u5c06\u6587\u4ef6\u95f4\u7684\u7f16\u8bd1\u4f9d\u5b58\u5173\u7cfb\u964d\u81f3\u6700\u4f4e"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#32publicis-a","text":"\u516c\u5f00\u7ee7\u627f(public inheritance)\u610f\u5473\u7740\u201c\u662f\u4e00\u79cd(is a)\u201c\u7684\u5173\u7cfb\u3002\u82e5 Derived class D \u516c\u5f00\u7ee7\u627f\u4e86 Base class B\uff0c\u8fd9\u610f\u5473\u7740\u6bcf\u4e00\u4e2a\u7c7b\u578b D \u7684\u5bf9\u8c61\u540c\u65f6\u4e5f\u662f\u4e00\u4e2a\u7c7b\u578b B \u7684\u5bf9\u8c61\u3002\u53cd\u4e4b\u5219\u4e0d\u7136\u3002 \u5728\u8fdb\u884c\u62bd\u8c61\u65f6\u4e00\u5b9a\u8981\u8bbe\u8ba1\u597d\u4e0d\u540c\u57fa\u7c7b\u7684\u5f02\u540c\u3002\u5982\uff1a\u4f01\u9e45\u662f\u9e1f\uff0c\u4f01\u9e45\u4e0d\u4f1a\u98de\u3002\u90a3\u4e48\u82e5\u4f01\u9e45\u7c7b(Penguin)\u7ee7\u627f\u7684\u9e1f\u7c7b(Bird)\u4e0d\u5e94\u8be5\u6709\u98de\u884c\u7684\u63a5\u53e3\u3002\u5982\u679c\u9700\u8981\u5f3a\u8c03\u662f\u5426\u53ef\u4ee5\u98de\u884c\uff0c\u5e94\u5f53\u518d\u8bbe\u7f6e\u4e24\u4e2a\u4e2d\u95f4\u7c7b\uff1a\u4f1a\u98de\u7684\u9e1f \u548c \u4e0d\u4f1a\u98de\u7684\u9e1f\u7ee7\u627f\u81ea\u9e1f\u7c7b\u3002\u5e76\u8ba9\u201d\u71d5\u5b50\u201c\u548c\u201d\u4f01\u9e45\u201c\u5206\u522b\u7ee7\u627f\u81ea\u4e2d\u95f4\u7c7b\u3002","title":"\u6761\u6b3e32\uff1a\u786e\u5b9a\u4f60\u7684public\u7ee7\u627f\u5851\u6a21\u51fais-a\u5173\u7cfb"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#33","text":"\u5185\u5c42\u4f5c\u7528\u57df\u7684\u540d\u79f0\u4f1a\u906e\u853d\u5916\u56f4\u4f5c\u7528\u57df\u7684\u540d\u79f0\u3002 \u7f16\u8bd1\u5668\u770b\u5230\u540d\u79f0\u540e\uff0c\u5fc5\u987b\u4f30\u7b97\u5b83\u6307\u6d89(refer to)\u4ec0\u4e48\u4e1c\u897f\u3002\u7f16\u8bd1\u5668\u4f1a\u7531\u5185\u5230\u5916\u4f9d\u6b21\u67e5\u627e\u6bcf\u5c42\u4f5c\u7528\u57df\uff0c\u76f4\u5230\u627e\u5230\u8be5\u540d\u79f0\u4e3a\u6b62\u3002 Derived Class \u6210\u5458\u7684\u4f5c\u7528\u57df\u5728 Base Class \u4f5c\u7528\u57df\u4e4b\u5185\u3002 \u63a5\u4e0b\u6765\uff0c\u8ba9\u6211\u4eec\u8003\u8651\u4ee5\u4e0b\u60c5\u51b5: class Base { public : virtual void m1 () = 0 ; virtual void m1 ( int ); }; class Derived : public Base { public : virtual void m1 () override ; }; int main (){ Derived D ; D . m1 ( 3 ); //error: no matching function for call to \u2018Derived::m1(int) } \u8fd9\u662f\u56e0\u4e3a Derived class \u5bf9\u51fd\u6570 m1() \u7684\u91cd\u8f7d\u8986\u76d6\u4e86 Base class \u7684\u51fd\u6570\u540d\u3002\u800c\u7f16\u8bd1\u5668\u5728 Derived class scope \u5185\u627e\u4e0d\u5230\u5339\u914d\u7684\u51fd\u6570\u3002\u8fd9\u79cd\u60c5\u51b5\u6709\u4e24\u79cd\u89e3\u51b3\u65b9\u6848\uff1a 1. \u4f7f\u5916\u90e8\u4f5c\u7528\u57df\u540d\u79f0\u5bf9\u5185\u90e8\u4f5c\u7528\u57df\u53ef\u89c1 class Derived : public Base { public : using Base :: m1 ; virtual void m1 () override ; }; \u4f7f\u7528\u8f6c\u4ea4\u51fd\u6570(forwarding function) class Derived : public Base { public : virtual void m1 () override ; virtual void m1 ( int x ) override { Base :: m1 ( x ); } };","title":"\u6761\u6b3e33\uff1a\u907f\u514d\u906e\u63a9\u7ee7\u627f\u800c\u6765\u7684\u540d\u79f0"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#34","text":"\u516c\u5f00\u7ee7\u627f\u603b\u662f\u4f1a\u7ee7\u627f\u6210\u5458\u63a5\u53e3\u3002 \u58f0\u660e\u4e00\u4e2a pure virtual \u51fd\u6570\u7684\u76ee\u7684\u662f\u4e3a\u4e86\u8ba9 derived classes \u53ea\u7ee7\u627f\u51fd\u6570\u63a5\u53e3\u3002 \u58f0\u660e\u7b80\u6734\u7684 impure virtual \u51fd\u6570\u7684\u76ee\u7684\uff0c\u662f\u8ba9 derived classes \u7ee7\u627f\u8be5\u51fd\u6570\u7684\u63a5\u53e3\u548c\u7f3a\u7701\u5b9e\u73b0\u3002 \u4e3a\u4e86\u907f\u514d\u7f3a\u7701\u884c\u4e3a\u9020\u6210\u4e0d\u53ef\u9884\u77e5\u7684\u7ed3\u679c\uff0c\u53ef\u4ee5\u9009\u62e9\u5c06\u63a5\u53e3\u5b9a\u4e49\u4e3a pure virtual function\u3002\u5e76\u5c06\u7f3a\u7701\u5b9e\u73b0\u653e\u5728\u4e00\u4e2a protected \u4f5c\u7528\u57df\u5185\u3002\u6d3e\u751f\u7c7b\u9700\u8981\u8c03\u7528\u7f3a\u7701\u884c\u4e3a\uff0c\u5c31\u5fc5\u987b\u663e\u793a\u5730\u8c03\u7528\u7f3a\u7701\u5b9e\u73b0\u3002 \u5141\u8bb8\uff08\u5728\u7c7b\u5916\uff09\u5b9e\u73b0 pure virtual function\u3002\u4f46\u9700\u8981\u663e\u793a\u5730\u8c03\u7528\u8be5\u51fd\u6570\u3002\u53ef\u4ee5\u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\u8ba9\u6d3e\u751f\u7c7b\u663e\u793a\u5730\u8c03\u7528\u8be5\u51fd\u6570\u3002\u4f46\u8fd9\u79cd\u505a\u6cd5\u5c01\u88c5\u6027\u4e0d\u5982\u4e0a\u4e00\u79cd\uff08\u7f3a\u7701\u5b9e\u73b0\u516c\u5f00\u7ed9\u6d3e\u751f\u7c7b\u7684\u5ba2\u6237\u4e86\uff09\u3002 class Base { public : virtual void doSth () = 0 ; }; void Base::doSth (){ /* details */ } class Derived : public Base { virtual void doSth (){ Base :: doSth (); // explicit calling function // inlining calling function } } \u58f0\u660e non-virtual \u51fd\u6570\u7684\u76ee\u7684\u662f\u4e3a\u4e86\u4ee4 derived classes \u7ee7\u627f\u51fd\u6570\u7684\u63a5\u53e3\u53ca\u4e00\u4efd\u5f3a\u5236\u6027\u5b9e\u73b0\u3002","title":"\u6761\u6b3e34\uff1a\u533a\u5206\u63a5\u53e3\u7ee7\u627f\u548c\u5b9e\u73b0\u7ee7\u627f"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#35virtual","text":"","title":"\u6761\u6b3e35\uff1a\u8003\u8651virtual\u51fd\u6570\u4ee5\u5916\u7684\u5176\u4ed6\u9009\u62e9"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#non-virtual-interfacenvi-template-method","text":"NVI\uff1a\u4ee4\u5ba2\u6237\u901a\u8fc7 public non-virtual \u6210\u5458\u51fd\u6570\u95f4\u63a5\u8c03\u7528 private virtual \u51fd\u6570\u3002\u5b83\u662f Template Method \u8bbe\u8ba1\u6a21\u5f0f\u7684\u4e00\u4e2a\u72ec\u7279\u8868\u73b0\u5f62\u5f0f\u3002 \u8fd9\u79cd\u6d41\u6d3e\u4e3b\u5f20 virtual \u51fd\u6570\u5e94\u8be5\u51e0\u4e4e\u603b\u662f private\u3002\u4ed6\u4eec\u5efa\u8bae\uff0c\u8f83\u597d\u7684\u8bbe\u8ba1\u662f Base class \u4fdd\u7559\u4e00\u4efd non-virtual \u7684\u63a5\u53e3\uff0c \u5e76\u8c03\u7528\u5728 private/protected \u4f5c\u7528\u57df\u5185\u5b9e\u73b0\u7684 virtual \u51fd\u6570\u3002 class Base { public : void doSth (){ /* Do some pre-work */ realDoSth (); // Do the real work /* do some post-work */ } private : virtual void realDoSth (); }; NVI \u624b\u6cd5\u7684\u4e00\u4e2a\u4f18\u70b9\u662f\uff0c\u5b83\u5f3a\u5236\u505a\u4e86 pre-work \u548c post-work\uff08\u5982\u52a0\u9501\u3001\u8bb0\u5f55\u65e5\u5fd7\u7b49\uff09\u3002Derived class \u53ea\u9700\u8981\u6ce8\u610f\u5b9e\u73b0\u90a3\u4e9b\u771f\u6b63\u9700\u8981\u6539\u53d8\u7684\u4e8b\u60c5\u5373\u53ef\u3002","title":"\u7531 Non-Virtual Interface(NVI) \u624b\u6cd5\u5b9e\u73b0 Template Method \u6a21\u5f0f"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#function-pointers-strategy","text":"\u7531\u4e00\u4e2a\u6307\u5411\u51fd\u6570\u7684\u6307\u9488\u5b8c\u6210\u4e0d\u540c\u5bf9\u8c61\u7684\u64cd\u4f5c\u3002","title":"\u85c9\u7531 Function Pointers \u5b9e\u73b0 Strategy \u6a21\u5f0f"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#stdfunction-strategy","text":"std :: function < int ( const ClassType & ) > \u4e0a\u8ff0\u7c7b\u63a5\u53d7\u5e76\u4fdd\u5b58\u4e00\u5207\u6ee1\u8db3\u201c\u63a5\u6536\u4e00\u4e2a ClassType \u5f15\u7528\u5e76\u8fd4\u56de\u4e00\u4e2a int \u503c\u201d\u7684\u53ef\u8c03\u7528\u7269(callable entity)\u3002\u5305\u62ec\u51fd\u6570\u6307\u9488\u3001\u51fd\u6570\u5bf9\u8c61\u6216\u6210\u5458\u51fd\u6570\u6307\u9488\u3002","title":"\u85c9\u7531 std::function \u7c7b\u5b8c\u6210 Strategy \u6a21\u5f0f"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#36non-virtual","text":"non-virtual \u51fd\u6570\u662f\u9759\u6001\u7684\u3002\u6545\u800c\u65e0\u6cd5\u5e94\u7528\u51fd\u6570\u7684\u591a\u6001\u6027\u3002 non-virtual \u51fd\u6570\u4e00\u822c\u4e0d\u88ab\u8bbe\u7f6e\u4e3a\u53ef\u91cd\u8f7d\u7684\uff08\u5426\u5219\u5c31\u7528 virtual \u4e86\uff09","title":"\u6761\u6b3e36\uff1a\u7edd\u4e0d\u91cd\u65b0\u5b9a\u4e49\u7ee7\u627f\u800c\u6765\u7684non-virtual\u51fd\u6570"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#37","text":"virtual \u51fd\u6570\u662f\u52a8\u6001\u7ed1\u5b9a(dynamically bound)\uff0c\u800c\u7f3a\u7701\u53c2\u6570\u503c\u662f\u9759\u6001\u7ed1\u5b9a(statically bound)\u3002 class Base { public : enum Color { BLUE , GREEN , RED }; virtual void draw ( Color c = GREEN ){ cout << c << endl ; } }; class Derived : public Base { public : virtual void draw ( Color c = RED ){ cout << c << endl ; } }; int main (){ Base * pb = new Derived (); Derived * pd = new Derived (); pb -> draw (); pd -> draw (); } \u6267\u884c\u7ed3\u679c\u4e3a\uff1a 1 2 \u82e5\u60f3\u8ba9\u7c7b\u7684\u6240\u6709\u7ee7\u627f\u51fd\u6570\u90fd\u83b7\u5f97\u76f8\u540c\u7684\u7f3a\u7701\u503c\uff0c\u4e0d\u5e94\u5f53\u8ba9\u6bcf\u4e2a\u7ee7\u627f\u7c7b\u548c\u7ee7\u627f\u51fd\u6570\u90fd\u7ed9\u4e88\u540c\u6837\u7684\u9ed8\u8ba4\u53c2\u6570\u3002\u8fd9\u6837\u4e00\u65b9\u9762\u4f1a\u9020\u6210\u4ee3\u7801\u91cd\u590d\uff0c\u53e6\u4e00\u65b9\u9762\u82e5\u57fa\u7c7b\u9ed8\u8ba4\u53c2\u6570\u6709\u66f4\u6539\uff0c\u6bcf\u4e2a\u7ee7\u627f\u7c7b\u90fd\u8981\u76f8\u5e94\u5730\u6539\u53d8\u3002\u8fd9\u6837\u5f88\u5bb9\u6613\uff08\u7531\u4e8e\u758f\u5ffd\uff09\u9020\u6210\u4e0a\u9762\u6240\u793a\u7684\u95ee\u9898\u3002 \u8fd9\u79cd\u60c5\u51b5\u4e0b\u5e94\u5f53\u53c2\u8003 NVI \u8bbe\u8ba1\u6a21\u5f0f\u3002\u5c06\u9ed8\u8ba4\u503c\u5b9a\u4e49\u5728 non-virtual \u51fd\u6570\u5185\uff0c\u5e76\u5728 private virtual \u51fd\u6570\u5185\u6267\u884c\u771f\u6b63\u7684\u5de5\u4f5c\u3002","title":"\u6761\u6b3e37\uff1a\u7edd\u4e0d\u91cd\u65b0\u5b9a\u4e49\u7ee7\u627f\u800c\u6765\u7684\u7f3a\u7701\u53c2\u6570\u503c"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#38has-a","text":"\u5f53\u67d0\u79cd\u7c7b\u578b\u7684\u5bf9\u8c61\u5185\u542b\u5b83\u79cd\u7c7b\u578b\u7684\u5bf9\u8c61\uff0c\u4fbf\u6784\u6210\u4e86\u590d\u5408(composition)\u5173\u7cfb\u3002\u8fd9\u662f\u4e00\u79cd \"has a\" \u6216 \"is implemented in terms of\"\uff08\u6839\u636e\u67d0\u7269\u5b9e\u73b0\u51fa\uff09 \u7684\u5173\u7cfb\u3002 \"has a\"\u548c\"is implemented in terms of\"\u7684\u533a\u522b\uff1a - \"has a\"\uff1a\u8be5\u7c7b\u542b\u6709\u7684\u5bf9\u8c61/\u4fe1\u606f\u3002\u5982\u7528\u6237\u7c7b\u5305\u542b Uid \u3001 name string \u7b49\u3002 - \"is implemented in terms of\"\uff1a\u8be5\u7c7b\u5b9e\u73b0\u7684\u5e95\u5c42\u7ed3\u6784\u3002\u5982\u4e00\u4e2a Stack \u7c7b\u5305\u542b\u4e86\u4e00\u4e2a private \u7684 std::vector \u3002","title":"\u6761\u6b3e38\uff1a\u901a\u8fc7\u590d\u5408\u5851\u6a21\u51fahas-a\u6216\u201c\u6839\u636e\u67d0\u7269\u5b9e\u73b0\u51fa\u201d"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#39private","text":"private \u7ee7\u627f\u610f\u5473\u7740 implemented-in-terms-of\u3002 private \u7ee7\u627f\u610f\u5473\u7740\u53ea\u6709\u5b9e\u73b0\u90e8\u5206\u88ab\u7ee7\u627f\uff0c\u63a5\u53e3\u90e8\u5206\u88ab\u7565\u53bb\u3002\u5b83\u5728\u8f6f\u4ef6\u8bbe\u8ba1\u65b9\u9762\u65e0\u610f\u4e49\uff0c\u4ec5\u5728\u8f6f\u4ef6\u5b9e\u73b0\u5c42\u9762\u6709\u610f\u4e49\u3002 C++\u6807\u51c6\u4e0d\u5141\u8bb8\u7a7a\u7c7b\u5b58\u5728\uff0c\u6240\u4ee5\u7f16\u8bd1\u5668\uff08\u4e00\u822c\uff09\u4f1a\u4e3a\u7a7a\u7c7b\u7684\u5bf9\u8c61\u63d2\u5165\u4e00\u4e2a\u7a7a char \u5143\u7d20\u3002\u6545\u800c class Empty () {}; class Derived { private : int a ; Empty e ; } int main (){ Derived d ; int a ; cout << sizeof ( d ) == sizeof ( a ) << endl ; } \u8f93\u51fa\u4e3a 0 \u3002 \u800c\u5c06 Empty \u7c7b private \u7ee7\u627f\u540e\uff0c\u7f16\u8bd1\u5668\u4f1a\u5f00\u542f EBO(empty base optimization\uff1b\u7a7a\u767d\u57fa\u7c7b\u6700\u5c0f\u5316) \u4f18\u5316\uff0c\u4f7f Derived \u5bf9\u8c61\u4e2d\u7684 Empty \u5bf9\u8c61\u4e0d\u5360\u7a7a\u95f4\u3002 \u5f53\u4e24\u4e2a\u4e0d\u542b \"is a\" \u5173\u7cfb\u7684 classes\uff0c\u5176\u4e2d\u4e00\u4e2a\u9700\u8981\u8bbf\u95ee\u53e6\u4e00\u4e2a\u7c7b\u7684 protected \u6210\u5458\uff0c\u6216\u662f\u91cd\u5b9a\u4e49\u53e6\u4e00\u4e2a\u7c7b\u7684\u4e00\u6216\u591a\u4e2a virtual \u51fd\u6570\u3002\u6b64\u65f6\u5e94\u8003\u8651 private \u7ee7\u627f\u3002","title":"\u6761\u6b3e39\uff1a\u660e\u667a\u800c\u5ba1\u614e\u5730\u4f7f\u7528private\u7ee7\u627f"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#virtual","text":"class Base { public : virtual void print (); }; class Derived { public : void test (){ bd . print (); } private : class BaseDerived : public Base { public : virtual void print (){ // details } }; BaseDerived bd ; };","title":"\u4e00\u79cd\u590d\u5408\u4ee3\u66ff\u7ee7\u627f\u5b9e\u73b0\u91cd\u5b9a\u4e49virtual\u51fd\u6570\u7684\u65b9\u6cd5"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#40multiple-inheritance-mi","text":"\u591a\u91cd\u7ee7\u627f\u5373\u4e00\u4e2a\u6d3e\u751f\u7c7b\u7ee7\u627f\u4e86\u591a\u4e2a\u57fa\u7c7b\u3002 graph BT a[Derived Class] --> b[Base Class 1] a --> c[Base Class 2] \u4f7f\u7528\u591a\u91cd\u7ee7\u627f\u524d\u9700\u8981\u8003\u8651\u4ee5\u4e0b\u95ee\u9898\uff1a","title":"\u6761\u6b3e40\uff1a\u660e\u667a\u800c\u5ba1\u614e\u5730\u4f7f\u7528\u591a\u91cd\u7ee7\u627f(Multiple Inheritance, MI)"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#_13","text":"class Base1 { public : void doSth (); }; class Base2 { private : void doSth (); }; class Derived : public Base1 , public Base2 { /*...*/ }; int main (){ Derived d ; d . doSth (); } C++ \u7f16\u8bd1\u5668\u5148\u89e3\u6790(resolving)\u6700\u4f73\u5339\u914d\u7684\u51fd\u6570\uff0c\u518d\u5224\u65ad\u8be5\u51fd\u6570\u7684\u53ef\u53d6\u7528\u6027\u3002\u56e0\u4e3a\u4e24\u4e2a\u51fd\u6570\u90fd\u662f public \u7ee7\u627f\uff0c\u6240\u4ee5\u4e24\u51fd\u6570\u7684\u4f18\u5148\u7ea7\u662f\u76f8\u540c\u7684\u3002\u7f16\u8bd1\u5668\u4f1a\u5728\u8fd9\u4e00\u6b65\u505c\u6b62\u5de5\u4f5c\uff08\u800c\u4e0d\u53bb\u89e3\u6790\u4e8c\u8005\u7684\u53ef\u53d6\u7528\u6027\uff09\u3002\u9664\u975e\u663e\u793a\u5730\u6307\u660e\u8981\u8c03\u7528\u7684\u51fd\u6570 d.Base1::doSth();","title":"\u6b67\u4e49"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#_14","text":"graph BT a[Derived class] --> b[Middle Class 1] a --> c[Middle Class 2] b --> d[Base Class] c --> d \u8003\u8651 Derived Class \u5185 Base Class \u5bf9\u8c61\u7684\u6570\u76ee\u3002\u7f3a\u7701\u60c5\u51b5\u4e0b\u662f\u4e24\u4e2a\u3002\u60f3\u8981\u72ec\u7acb\u5730\u7ee7\u627f Base Class \u5e94\u5f53\u4f7f\u7528 virtual \u7ee7\u627f\u3002 class Base { /*...*/ }; class Middle1 : virtual public Base { /*...*/ }; class Middle2 : virtual public Base { /*...*/ }; class Derived : public Middle1 , public Middle2 { /*...*/ }; \u4e00\u822c\u6765\u8bf4\uff0c public \u7ee7\u627f\u90fd\u5e94\u8be5\u662f virtual \u7684\u3002\u7136\u800c\uff0c\u8fd9\u79cd virtual \u7ee7\u627f\u4f1a\u5e26\u6765\u989d\u5916\u7684\u5f00\u9500\uff08\u7a7a\u95f4\u3001\u8bbf\u95ee\u901f\u5ea6\u7b49\uff09\u3002 virtual \u7ee7\u627f\u8fd8\u9700\u8981\u8003\u8651\u201d\u521d\u59cb\u5316\u201c\u89c4\u5219\u3002 virtual base class \u7684\u521d\u59cb\u5316\u8d23\u4efb\u662f\u7531 most derived class \u627f\u62c5\u7684\u3002\u8fd9\u610f\u5473\u7740\uff1a 1. classes \u82e5\u6d3e\u751f\u81ea virtual base classes \u800c\u9700\u8981\u521d\u59cb\u5316\uff0c\u5c31\u5fc5\u987b\u627e\u5230\u5b83\u7684 virtual bases\uff0c\u65e0\u8bba\u8ddd\u79bb\u591a\u8fdc\u3002 2. \u5f53\u4e00\u4e2a\u65b0\u7684 derived class \u52a0\u5165\u7ee7\u627f\u4f53\u7cfb\u4e2d\uff0c\u5b83\u5fc5\u987b\u627f\u62c5\u5176 virtual bases \u7684\u521d\u59cb\u5316\u8d23\u4efb\u3002 \u4e24\u70b9\u5fe0\u544a\uff1a 1. \u975e\u5fc5\u8981\u4e0d\u7528 virtual \u7ee7\u627f\u3002 2. \u5982\u679c\u5fc5\u987b\u4f7f\u7528 virtual bases\uff0c \u5c3d\u91cf\u4e0d\u8981\u5728\u91cc\u9762\u653e\u6570\u636e\u3002\u4ee5\u907f\u514d\u5e26\u6765\u521d\u59cb\u5316\u6216\u8d4b\u503c\u5e26\u6765\u7684\u989d\u5916\u95ee\u9898\u3002","title":"\u83f1\u5f62\u7ee7\u627f"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#41","text":"\u9762\u5411\u5bf9\u8c61\u6a21\u5f0f\u603b\u4ee5\u663e\u5f0f\u63a5\u53e3(explicit interfaces)\u548c\u8fd0\u884c\u671f\u591a\u6001(runtime polymorphism)\u89e3\u51b3\u95ee\u9898\u3002 \u6a21\u677f\u7f16\u7a0b\u66f4\u4f9d\u8d56\u9690\u5f0f\u63a5\u53e3(implicit interfaces)\u548c\u7f16\u8bd1\u671f\u591a\u6001(compile-time polymorphism)\u3002 \u663e\u5f0f\u63a5\u53e3\uff1a\u901a\u5e38\u7531\u51fd\u6570\u7684\u7b7e\u540d\u5f0f\uff08\u4e5f\u5c31\u662f\u51fd\u6570\u540d\u79f0\u3001\u53c2\u6570\u7c7b\u578b\u3001\u8fd4\u56de\u7c7b\u578b\uff09\u6784\u6210\u3002 \u9690\u5f0f\u63a5\u53e3\uff1a\u7531\u6709\u6548\u8868\u8fbe\u5f0f(valid expression)\u7ec4\u6210\u3002","title":"\u6761\u6b3e41\uff1a\u4e86\u89e3\u9690\u5f0f\u63a5\u53e3\u548c\u7f16\u8bd1\u671f\u591a\u6001"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#42typename","text":"typename \u7684\u53cc\u91cd\u610f\u4e49\uff1a - \u4f5c\u4e3a\u6a21\u677f\u53c2\u6570\u7684\u7b7e\u540d\uff0c\u548c class \u6709\u7740\u76f8\u540c\u7684\u4f5c\u7528\u3002 - \u5728\u4ee3\u7801\u5757\u4e2d\uff0c\u7528\u4e8e\u663e\u793a\u5730\u58f0\u660e\u4e00\u4e2a\u5d4c\u5957\u4ece\u5c5e\u540d\u79f0(nested dependent name)\u3002 \u8003\u8651\u4ee5\u4e0b\u4ee3\u7801\uff1a template < typename T > void doSth ( const C & container ){ if ( container . size () > 2 ){ C :: const_iterator iter ( container . begin ()); ++ iter ; cout << * iter << endl ; } } \u4e0a\u8ff0\u4ee3\u7801\u5b9e\u9645\u4e0a\u4e0d\u88ab\u901a\u8fc7\u7f16\u8bd1\u3002\u56e0\u4e3a\u7f16\u8bd1\u5668\u4f1a\u9ed8\u8ba4\u5c06\u7c7b\u4f3c C::type \u8fd9\u6837\u7684\u5d4c\u5957\u4ece\u5c5e\u540d\u79f0\u89e3\u6790\u4e3a\u4e0d\u662f\u7c7b\u578b\uff08\u800c\u662f\u53d8\u91cf\u7b49\uff09\uff0c\u9664\u975e\u663e\u793a\u5730\u544a\u8bc9\u5b83\u3002\u56e0\u6b64\u9700\u8981\u5c06\u4e0a\u5f0f\u6539\u53d8\u4e3a\uff1a template < typename T > void doSth ( const C & container ){ // details typename C :: const_iterator iter ( container . begin ()); // details } typename \u7528\u4e8e\u663e\u793a\u5730\u58f0\u660e\u4e00\u4e2a\u5d4c\u5957\u4ece\u5c5e\u540d\u79f0(nested dependent name)\u3002\u7136\u800c\uff0c typename \u4e0d\u5e94\u51fa\u73b0\u5728 base classes list \u6216 member initialization list \u5185\u3002 \u5728 typedef \u7c7b\u578b\u540d\u65f6\uff0c\u9700\u8981\u663e\u793a\u5730\u58f0\u660e typename \uff0c\u4f8b\u5982 template < typename IterT > void workWithIterator ( IterT iter ){ typedef typename std :: iterator_traits < IterT >:: value_type value_type ; // details }","title":"\u6761\u6b3e42\uff1a\u4e86\u89e3typename\u7684\u53cc\u91cd\u610f\u4e49"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#43","text":"\u6a21\u677f\u7ee7\u627f\u65f6\u65e0\u6cd5\u9690\u5f0f\u5730\u4f7f\u7528\u57fa\u7c7b\u6210\u5458\u65b9\u6cd5\u3002\u56e0\u4e3a\u7f16\u8bd1\u5668\u65e0\u6cd5\u6392\u9664\u57fa\u7c7b\u6a21\u677f\u7684\u67d0\u4e2a\u7279\u5316\u7248\u672c\u4e0d\u63d0\u4f9b\u548c\u4e00\u822c\u6027 template \u4e0d\u540c\u7684\u63a5\u53e3\u7684\u53ef\u80fd\u6027\u3002\u56e0\u6b64\u5b83\u5f80\u5f80\u62d2\u7edd\u5728 Templatized base classes\uff08\u6a21\u677f\u5316\u57fa\u7c7b\uff09\u5185\u5bfb\u627e\u7ee7\u627f\u800c\u6765\u7684\u540d\u79f0\u3002 \u6709\u4e09\u79cd\u65b9\u6cd5\u89e3\u51b3\u8fd9\u79cd\u95ee\u9898\uff1a \u4f7f\u7528 this \u6307\u9488\u8c03\u7528\u57fa\u7c7b\u6210\u5458\u51fd\u6570\u3002 \u4f7f\u7528 using \u8bed\u53e5\u63d0\u9192\u7f16\u8bd1\u5668\u5728\u57fa\u7c7b\u5185\u5bfb\u627e\u65b9\u6cd5\u3002 \u4f7f\u7528\u57fa\u7c7b\u4f5c\u7528\u57df\u663e\u5f0f\u5730\u8c03\u7528\u57fa\u7c7b\u6210\u5458\u51fd\u6570\u3002\u5982 Base::func() \u3002\u4e0d\u63a8\u8350\uff0c\u56e0\u4e3a\u8fd9\u4f1a\u9020\u6210\u67d0\u4e9b virtual \u51fd\u6570\u65e0\u6cd5 work\u3002","title":"\u6761\u6b3e43\uff1a\u5b66\u4e60\u5904\u7406\u6a21\u677f\u5316\u57fa\u7c7b\u5185\u7684\u540d\u79f0"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#44templates","text":"\u4f7f\u7528 templates \u53ef\u80fd\u4f1a\u9020\u6210\u4ee3\u7801\u81a8\u80c0(code bloat)\uff1a\u76ee\u6807\u7801(object code)\u5e26\u7740\u91cd\u590d\uff08\u6216\u51e0\u4e4e\u91cd\u590d\uff09\u7684\u4ee3\u7801\u3001\u6570\u636e\u3002 \u9632\u6b62\u4ee3\u7801\u81a8\u80c0\u7684\u5de5\u5177\uff1a\u5171\u6027\u4e0e\u53d8\u6027\u5206\u6790(commonality and variability analysis)\u3002 \u4e0d\u4ec5\u975e\u7c7b\u578b\u6a21\u677f\u53c2\u6570(non-type template parameters)\u4f1a\u5e26\u6765\u81a8\u80c0\uff0c\u7c7b\u578b\u6a21\u677f\u53c2\u6570(type parameters)\u4e5f\u4f1a\u5e26\u6765\u81a8\u80c0\u2014\u2014\u5982\u5728\u67d0\u4e9b\u673a\u5668\u4e0a\uff0c int \u4e0e long \u5e95\u5c42\u5b9e\u73b0\u76f8\u540c\u3002\u67d0\u4e9b\u94fe\u63a5\u5668(linkers)\u4f1a\u5408\u5e76\u5b8c\u5168\u76f8\u540c\u7684\u5b9e\u73b0\u7801\uff0c\u4f46\u6709\u4e9b\u4e0d\u4f1a\u3002\u53e6\u4e00\u65b9\u9762\uff0c\u6307\u9488\u7684\u4e8c\u8fdb\u5236\u5e95\u5c42\u5b9e\u73b0\u662f\u76f8\u540c\u7684\uff0c\u4f46 templates \u4f1a\u4e3a\u6bcf\u4e2a\u6307\u9488\u8d4b\u4e88\u7279\u5316\u7248\u672c\u3002\u8fd9\u610f\u5473\u7740\u5f53\u4f60\u5b9e\u73b0\u67d0\u4e9b\u6210\u5458\u51fd\u6570\u4e14\u5b83\u4eec\u64cd\u4f5c\u5f3a\u7c7b\u578b\u6307\u9488(strongly typed pointers)\uff0c\u4f60\u5e94\u5f53\u8ba9\u5b83\u4eec\u8c03\u7528\u53e6\u4e00\u4e2a\u65e0\u7c7b\u578b\u6307\u9488(untyped pointers\uff0c\u5373 void * ) \u6765\u5b8c\u6210\u5b9e\u9645\u5de5\u4f5c\u3002","title":"\u6761\u6b3e44\uff1a\u5c06\u4e0e\u53c2\u6570\u65e0\u5173\u7684\u4ee3\u7801\u62bd\u79bbtemplates"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#45","text":"\u5bf9\u4e8e\u4e00\u4e2a\u8d44\u6e90\u7ba1\u7406\u7c7b SmartPtr<T> \u6765\u8bf4\uff0c\u5b83\u65e0\u6cd5\u652f\u6301\u6307\u9488\u5e94\u6709\u7684 covariance\u3002\u8fd9\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u901a\u8fc7\u6210\u5458\u51fd\u6570\u6a21\u677f\u6765\u5b9a\u4e49\u5176\u517c\u5bb9\u7c7b\u578b\u3002\u4ee5 std::shared_ptr<T> \u4e3a\u4f8b\uff0c\u5176\u6210\u5458\u51fd\u6570\u6a21\u677f\u5b9a\u4e49\u5982\u4e0b\uff1a template < class T > class shared_ptr { public : shared_ptr ( shared_ptr const & r ); //explicitly define its self-copy constructor template < class Y > shared_ptr ( shared_ptr < Y > const & r ) //generalized copy constructor : heldPtr ( r . get ()) { /*...*/ } template < class Y > explicit shared_ptr ( Y * p ); template < class Y > explicit shared_ptr ( weak_ptr < Y > const & r ); template < class Y > explicit shared_ptr ( unique_ptr < Y > & r ); template < class Y > shared_ptr & operator = ( shared_ptr < Y > const & r ); template < class Y > shared_ptr & operator = ( unique_ptr < Y > & r ); /*...*/ const T * get () const ; private : T * heldPtr ; /*...*/ } \u4e0a\u9762\u4ee3\u7801\u6709\u51e0\u4e2a\u6ce8\u610f\u70b9\uff1a - \u6a21\u677fcopy constructor \u65e0\u6cd5\u7279\u5316 self-copy constructor\u3002\u56e0\u6b64\u5982\u679c\u6709\u9700\u8981\u4ecd\u9700\u81ea\u884c\u5b9a\u4e49\u3002 - shared_ptr \u53ea\u6709 generalized copy constructor\uff0c\u8fd9\u610f\u5473\u7740\u53ea\u6709 shared_ptr \u7c7b\u578b\u9690\u5f0f\u8f6c\u6362\u4e3a\u53e6\u4e00\u4e2a shared_ptr \u662f\u5141\u8bb8\u7684\u3002\u5176\u5b83\u7c7b\u578b\uff08\u8f6c shared_ptr \uff09\u5219\u5fc5\u987b\u663e\u793a\u8f6c\u6362\u3002 - \u6210\u5458\u51fd\u6570\u901a\u8fc7 get() member function \u548c member initialized list \u6765\u5b9e\u9645\u6267\u884c\u6307\u9488\u7684 covariance\u3002\u8fd9\u6837\uff0c\u6307\u9488 covariance \u7684\u5408\u6cd5\u6027\u5c31\u7531\u7f16\u8bd1\u5668\u4fdd\u8bc1\u3002 - unique_ptr \u5e76\u975e const reference\u3002\u56e0\u4e3a\u5bf9 unique_ptr \u6267\u884c\u8f6c\u6362\u6216\u8d4b\u503c\uff0c\u5b83\u7684\u503c\u5b9e\u9645\u4e0a\u88ab\u6539\u53d8\u4e86\u3002","title":"\u6761\u6b3e45\uff1a\u8fd0\u7528\u6210\u5458\u51fd\u6570\u6a21\u677f\u63a5\u53d7\u6240\u6709\u517c\u5bb9\u7c7b\u578b"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#46","text":"\u8003\u8651\u6761\u6b3e24\u4e2d\u7684\u51fd\u6570\uff0c\u73b0\u5728\u8ba9\u6211\u4eec\u5c06\u5176\u53d8\u4e3a\u6a21\u677f\u3002 template < typename T > class Rational { public : Rational ( const T & numerator = 0 , const T & denominator = 1 ); const T numerator () const ; const T & denominator () const ; /*...*/ }; template < typename T > const Rational < T > operator * ( const Rational < T > & lhs , const Rational < T > & rhs ){ /*...*/ } \u7136\u800c\uff0c\u5f53\u6211\u4eec\u6267\u884c Rational < int > num = Rational < int > oneHalf ( 1 , 2 ) * 2 ; \u7f16\u8bd1\u5668\u4f1a\u62a5\u9519\u201c no match for \u2018operator*\u2019 (operand types are \u2018Rational<int>\u2019 and \u2018int\u2019) \u201d\u3002\u8fd9\u662f\u56e0\u4e3a\u7f16\u8bd1\u5668\u5728\u5b9e\u4f8b\u5316\u6a21\u677f\u65f6\u53ea\u4f1a\u5bfb\u627e\u4e00\u5c42 typename \u800c\u975e\u5d4c\u5957\u5730\u5bfb\u627e\u9690\u5f0f\u8f6c\u6362\u5173\u7cfb\u3002\u56e0\u6b64\uff0c\u7f16\u8bd1\u5668\u65e0\u6cd5\u627e\u5230\u540c\u65f6\u6ee1\u8db3 Rational<int> \u548c int \u4e24\u4e2a\u53c2\u6570\u7684\u51fd\u6570\u3002\u82e5\u6211\u4eec\u663e\u793a\u5730\uff0c\u5728\u6784\u9020\u51fa Rational \u7684\u4e00\u4efd\u5b9e\u4f8b\u65f6\u5c31\u58f0\u660e\u5bf9\u5e94\u7684\u51fd\u6570\u3002\u6bd4\u5982\u5c06\u4e4b\u58f0\u660e\u4e3a friend \u51fd\u6570\uff1a template < typename T > class Rational { friend const Rational operator * ( const Rational & lhs , const Rational & rhs ); public : Rational ( const T & numerator = 0 , const T & denominator = 1 ); const T numerator () const ; const T & denominator () const ; /*...*/ }; \u4e0a\u9762\u8fd9\u4e2a\u4ee3\u7801\u73b0\u5728\u53ef\u4ee5\u6210\u529f\u901a\u8fc7\u7f16\u8bd1\u4e86\u3002\u7136\u800c\uff0c\u5b83\u4ecd\u4f1a\u5728\u94fe\u63a5\u5668\u4e0a\u62a5\u9519\" undefined reference to `operator*(Rational<int> const&, Rational<int> const&)' \"\u3002\u56e0\u4e3a\u6211\u4eec\u4e0a\u9762\u53ea\u662f\u201c\u58f0\u660e\u201d\u4e86\u5b83\uff0c\u800c\u975e\u663e\u793a\u5730\u5b9a\u4e49\u4e86\u5b83\u3002\u65e2\u7136\u6211\u4eec\u58f0\u660e\u4e86\u5b83\uff0c\u5c31\u8981\u62c5\u8d1f\u5b9a\u4e49\u5b83\u7684\u8d23\u4efb\u3002\u6700\u7b80\u5355\u7684\u65b9\u6cd5\u662f\u5c06 operator* \u51fd\u6570\u5408\u5e76\u81f3 Rational \u672c\u4f53\u5185\u3002 template < typename T > class Rational { friend const Rational operator * ( const Rational & lhs , const Rational & rhs ){ return Rational < T > ( lhs . numerator () * rhs . numerator (), lhs . denominator () * rhs . denominator ()); } public : Rational ( const T & numerator = 0 , const T & denominator = 1 ); const T numerator () const ; const T & denominator () const ; /*...*/ }; \u8fd9\u91cc\u5c06\u51fd\u6570\u58f0\u660e\u4e3a friend \u662f\u6211\u4eec\u5728\u5bf9\u8c61\u5185\u58f0\u660e\u51fd\u6570\u7684\u552f\u4e00\u65b9\u5f0f\u3002\u540c\u65f6\uff0c\u5728\u5bf9\u8c61\u7ed3\u6784\u4f53\u5185\u5b9a\u4e49\u7684\u51fd\u6570\u90fd\u662f inline \u7684\u3002\u5bf9\u67d0\u4e9b\u5f88\u590d\u6742\u7684\u51fd\u6570\u800c\u8a00\uff0c\u5b9a\u4e49\u4e3a inline \u4f1a\u964d\u4f4e\u5176\u6267\u884c\u6548\u7387\u3002\u867d\u7136\u7f16\u8bd1\u5668\u4f1a\u81ea\u884c\u51b3\u5b9a\u662f\u5426\u63a5\u53d7 inline \u7533\u8bf7\u3002\u4f46\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4e0b\u9762\u7684\u65b9\u5f0f\u663e\u793a\u5730\u8ba9\u5176\u4e0d\u662f\u4e00\u4e2a inline \u51fd\u6570\u2014\u2014\u5373\u5c06\u771f\u6b63\u7684\u64cd\u4f5c\u653e\u5728\u53e6\u4e00\u4e2a\u6a21\u677f\u51fd\u6570\u5185\uff0c\u5e76\u5728 friend \u51fd\u6570\u5185\u8c03\u7528\u8fd9\u4e2a\u51fd\u6570\uff1a template < typename T > class Rational { friend const Rational operator * ( const Rational & lhs , const Rational & rhs ){ return doMultiple ( lhs , rhs ); } /*...*/ }; template < typename T > const Rational < T > doMultiple ( const Rational & lhs , const Rational & rhs ){ return Rational < T > ( lhs . numerator * rhs . numerator , lhs . denominator * rhs . denominator ); } \u8fd9\u91cc\uff0c\u8d1f\u8d23\u63a8\u65ad T \u7684\u7c7b\u578b\u662f\u7531 friend \u51fd\u6570\u6765\u5b9e\u73b0\u7684\u3002\u63a5\u7740\uff0c\u5b83\u7528\u8fd9\u4e2a\u7c7b\u578b\u5b9e\u4f8b\u5316\u5e76\u8c03\u7528\u7c7b\u5916\u58f0\u660e\u7684\u51fd\u6570\u3002","title":"\u6761\u6b3e46\uff1a\u9700\u8981\u7c7b\u578b\u8f6c\u6362\u65f6\u8bf7\u4e3a\u6a21\u677f\u5b9a\u4e49\u975e\u6210\u5458\u51fd\u6570"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#47traits-classes","text":"\u8fd9\u4e00\u7ae0\u5efa\u8bae\u7ed3\u5408\u4e66\u672c\u51fa\u793a\u7684\u4f8b\u5b50\u7406\u89e3\u3002 type traits\uff1a\u7c7b\u578b\u8403\u53d6\u3002\u7528\u4e8e\u786e\u5b9a\u6570\u636e\u7c7b\u578b\u3002 \u5982\u4f55\u8bbe\u8ba1\u5e76\u5b9e\u73b0 traits class\uff1a - \u786e\u8ba4\u82e5\u5e72\u4f60\u5b66\u4e60\u6211\u5c06\u6765\u53ef\u53d6\u5f97\u7684\u7c7b\u578b\u76f8\u5173\u4fe1\u606f - \u4e3a\u8be5\u4fe1\u606f\u9009\u62e9\u4e00\u4e2a\u540d\u79f0\uff08\u4f8b\u5982 iterator_category \uff09 - \u63d0\u4f9b\u4e00\u4e2a template \u548c\u4e00\u7ec4\u7279\u5316\u7248\u672c\uff0c\u5185\u542b\u4f60\u5e0c\u671b\u652f\u6301\u7684\u7c7b\u578b\u76f8\u5173\u4fe1\u606f\u3002 - \u5efa\u7acb\u4e00\u7ec4\u91cd\u8f7d\u51fd\u6570\u6216\u51fd\u6570\u6a21\u677f\uff0c\u5f7c\u6b64\u95f4\u7684\u5dee\u5f02\u53ea\u5728\u4e8e\u5404\u81ea\u7684 traits \u53c2\u6570\u3002\u4ee4\u6bcf\u4e2a\u51fd\u6570\u5b9e\u73b0\u7801\u4e0e\u5176\u63a5\u53d7\u7684 traits \u4fe1\u606f\u76f8\u543b\u5408\u3002 - \u5efa\u7acb\u4e00\u4e2a\u63a7\u5236\u51fd\u6570\u6216\u51fd\u6570\u6a21\u677f\uff0c\u5b83\u8c03\u7528\u4e0a\u8ff0\u90a3\u4e9b\u91cd\u8f7d\u51fd\u6570\u5e76\u4f20\u9012 traits class \u6240\u63d0\u4f9b\u7684\u4fe1\u606f\u3002","title":"\u6761\u6b3e47\uff1a\u8bf7\u4f7f\u7528traits Classes\u8868\u73b0\u7c7b\u578b\u4fe1\u606f"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#48template","text":"Template Metaprogramming(TMP, \u6a21\u677f\u5143\u7f16\u7a0b)\u662f\u7f16\u5199 Template-based C++ \u7a0b\u5e8f\u5e76\u6267\u884c\u4e8e\u7f16\u8bd1\u671f\u7684\u8fc7\u7a0b\u3002\u662f\u4ee5 C++ \u5199\u6210\u3001\u6267\u884c\u4e8e C++ \u7f16\u8bd1\u5668\u5185\u7684\u7a0b\u5e8f\u3002\u4e00\u65e6 TMP \u7a0b\u5e8f\u7ed3\u675f\u6267\u884c\uff0c\u5176\u8f93\u51fa\uff0c\u4e5f\u5c31\u662f\u4ece templates \u91cc\u5177\u73b0\u51fa\u6765\u7684\u82e5\u5e72 C++ \u6e90\u7801\uff0c\u4fbf\u4f1a\u4e00\u5982\u5f80\u5e38\u5730\u88ab\u7f16\u8bd1\u3002 TMP\u7684\u4f5c\u7528\u5982\u4e0b\uff1a 1. \u5b83\u8ba9\u67d0\u4e9b\u4e8b\u60c5\u66f4\u52a0\u5bb9\u6613\u3002 2. \u5b83\u5c06\u5f88\u591a\u8fd0\u884c\u671f\u5de5\u4f5c\u8f6c\u79fb\u5230\u7f16\u8bd1\u671f\u3002\u8fd9\u5c06\u5bfc\u81f4\u4e0b\u9762\u7684\u7ed3\u679c\uff1a 1. \u67d0\u4e9b\u9519\u8bef\u539f\u672c\u5728\u8fd0\u884c\u671f\u624d\u80fd\u68c0\u6d4b\u5230\uff0c\u73b0\u5728\u5728\u7f16\u8bd1\u671f\u5c31\u80fd\u627e\u5230\u3002 2. \u4f7f\u7528 TMP \u7684 C++ \u7a0b\u5e8f\u53ef\u80fd\u5728\u6bcf\u4e00\u65b9\u9762\u90fd\u66f4\u9ad8\u6548\uff1a\u8f83\u5c0f\u7684\u53ef\u6267\u884c\u6587\u4ef6\u3001\u8f83\u77ed\u7684\u8fd0\u884c\u671f\u3001\u8f83\u5c11\u7684\u5185\u5b58\u9700\u6c42\u3002 3. \u7f16\u8bd1\u65f6\u95f4\u5927\u5927\u52a0\u957f\u3002 TMP \u5df2\u88ab\u8bc1\u5b9e\u662f\u56fe\u7075\u5b8c\u5907\u7684\u3002\u53ef\u4ee5\u4f7f\u7528 TMP \u58f0\u660e\u53d8\u91cf\u3001\u6267\u884c\u5faa\u73af\u3001\u7f16\u5199\u53ca\u8c03\u7528\u51fd\u6570\u2026\u2026\u4f46\u8fd9\u4e9b\u6784\u4ef6\u548c \u201d\u6b63\u5e38\u7684\u201c C++ \u5bf9\u5e94\u7269\u6709\u6240\u4e0d\u540c\u3002\u4f8b\u5982 TMP \u6ca1\u6709\u771f\u6b63\u7684\u5faa\u73af\u6784\u4ef6\uff0c\u6240\u4ee5\u5faa\u73af\u6548\u679c\u85c9\u7531\u9012\u5f52(recursion)\u5b8c\u6210\u3002 \u4e14 TMP \u7684\u9012\u5f52\u5e76\u4e0d\u57fa\u4e8e\u9012\u5f52\u51fd\u6570\u7684\u8c03\u7528\uff0c\u800c\u662f\u57fa\u4e8e\u9012\u5f52\u6a21\u677f\u7684\u5177\u73b0\u5316(recursive template instantiation)\u3002\u5982\u4e0b\u9762\u8fd9\u4e2a\u8ba1\u7b97\u9636\u4e58\u7684 TMP \u51fd\u6570 template < unsigned n > struct Factorial { enum { value = n * Factional < n -1 >:: value }; }; template <> struct Factorial < 0 > { enum { value = 1 }; }; int main (){ std :: cout << Factorial < 5 >:: value ; // print 120 std :: cout << Factorial < 10 >:: value ; // print 3628800 } \u9700\u8981\u6ce8\u610f\uff0c\u4e0a\u9762\u7684\u9636\u4e58\u503c\u5b9e\u9645\u4e0a\u5728\u7f16\u8bd1\u671f\u5c31\u88ab\u8ba1\u7b97\u51fa\u6765\u5e76\u88ab\u7279\u5316\u6210 struct object \u4e86\u3002\u56e0\u800c\u6211\u4eec\u5728\u8fd0\u884c\u671f\u5c31\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u7ed3\u679c\u3002 TMP \u5e94\u7528\u573a\u666f\uff1a - \u65e9\u671f\u9519\u8bef\u68c0\u6d4b\uff0c\u4f8b\u5982\u786e\u5b9a\u5ea6\u91cf\u5355\u4f4d\u662f\u5426\u6b63\u786e\u3002 - \u4f18\u5316\u77e9\u9635\u8fd0\u7b97\u3002 - \u53ef\u4ee5\u751f\u6210\u5ba2\u6237\u5b9a\u5236\u8bbe\u8ba1\u6a21\u5f0f(custom design pattern)\u5b9e\u73b0\u54c1\u3002","title":"\u6761\u6b3e48\uff1a\u8ba4\u8bc6template\u5143\u7f16\u7a0b"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#49new-handler","text":"\u5f53 operator new \u629b\u51fa\u4e00\u4e2a\u5f02\u5e38\u4ee5\u53cd\u6620\u4e00\u4e2a\u672a\u83b7\u5f97\u6ee1\u8db3\u7684\u5185\u5b58\u9700\u6c42\u4e4b\u524d\uff0c\u5b83\u4f1a\u4e0d\u65ad\u8c03\u7528\u4e00\u4e2a\u6240\u8c13\u7684 new_handler \u51fd\u6570\uff0c\u7528\u6765\u8fdb\u884c\u9519\u8bef\u5904\u7406\uff08\u7ed3\u675f\u8fdb\u7a0b\u6216\u91ca\u653e\u8d44\u6e90\uff09\uff0c\u76f4\u5230\u627e\u5230\u8db3\u591f\u7684\u5185\u5b58\u6216\u7ed3\u675f\u8be5\u8fdb\u7a0b\u3002 \u5ba2\u6237\u9700\u8981\u8c03\u7528\u4e00\u4e2a\u58f0\u660e\u4e8e\u6807\u51c6\u5e93 <new> \u7684\u5e93\u51fd\u6570 set_new_handler \u6765\u5b9a\u4e49\u8fd9\u4e2a\u9519\u8bef\u5904\u7406\u51fd\u6570\u3002 set_new_handler \u51fd\u6570\u58f0\u660e\u5982\u4e0b\uff1a namespace std { typedef void ( * new_handler )(); new_handler set_new_handler ( new_handler p ) throw (); } \u5176\u4e2d new_handler \u662f\u4e2a typedef \uff0c\u5b9a\u4e49\u51fa\u4e00\u4e2a\u6307\u9488\u6307\u5411\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u65e0\u9700\u53c2\u6570\u4e5f\u4e0d\u53cd\u56de\u4efb\u4f55\u4e1c\u897f\u3002 set_new_handler \u5219\u662f\u201c\u83b7\u5f97\u4e00\u4e2a new_handler \u5e76\u8fd4\u56de\u4e00\u4e2a new_handler \u201d\u7684\u51fd\u6570\u3002\u58f0\u660e\u5f0f\u672b\u7aef\u7684 throw() \u662f\u4e00\u4efd\u5f02\u5e38\u660e\u7ec6\uff0c\u8868\u660e\u8be5\u51fd\u6570\u4e0d\u4f1a\u629b\u51fa\u5f02\u5e38\u3002 \u4e00\u4e2a\u4f8b\u5b50\u5982\u4e0b\u6240\u793a\uff1a void outOfMem (){ std :: cerr << \"Unable to satisfy request for memory \\n \" ; std :: abort ; } int main (){ std :: set_new_handler ( outOfMem ); int * Test = new int [ 100000000L ]; } \u4e00\u4e2a\u8bbe\u8ba1\u826f\u597d\u7684 new_handler \u51fd\u6570\u9700\u8981\u505a\u5230\u4ee5\u4e0b\u4e8b\u60c5\uff1a - \u8ba9\u66f4\u591a\u5185\u5b58\u53ef\u88ab\u4f7f\u7528\u3002 \u5b9e\u73b0\u8be5\u65b9\u6cd5\u7684\u4e00\u4e2a\u9014\u5f84\u662f\uff0c\u7a0b\u5e8f\u4e00\u5f00\u59cb\u5c31\u7533\u8bf7\u4e00\u5927\u5757\u5185\u5b58\uff0c\u5728 new_handler \u51fd\u6570\u7b2c\u4e00\u6b21\u88ab\u8c03\u7528\u65f6\u5c06\u5b83\u4eec\u91ca\u8fd8\u7ed9\u7a0b\u5e8f\u4f7f\u7528\u3002 - \u5b89\u88c5\u53e6\u4e00\u4e2a new_handler \u3002 \u82e5\u5f53\u4e0b new_handler \u51fd\u6570\u65e0\u6cd5\u83b7\u53d6\u66f4\u591a\u5185\u5b58\uff0c\u5219\u8ba9\u5b83\u5b89\u88c5\u53e6\u4e00\u4e2a new_handler \u51fd\u6570\u3002\u4e0b\u6b21\u5f53 operator new \u8c03\u7528 new_handler \u65f6\uff0c\u5c06\u4f1a\u8c03\u7528\u6700\u65b0\u7684\u90a3\u4e2a\u3002\u505a\u6cd5\u4e4b\u4e00\u662f\u4ee4 new_handler \u51fd\u6570\u4fee\u6539\u4f1a\u5f71\u54cd\u5176\u884c\u4e3a\u7684 static \u3001 namespace \u6216 global \u6570\u636e\u3002 - \u5378\u9664 new_handler \u3002 \u5373\u5c06 nullptr \u4f20\u7ed9 set_new_handler \u51fd\u6570\u3002\u4e00\u65e6 operator new \u83b7\u5f97 nullptr \uff0c\u5b83\u5c06\u8f93\u51fa\u62a5\u9519\u4fe1\u606f\u3002 - \u4e0d\u8fd4\u56de\u3002 \u901a\u5e38\u8c03\u7528 abort \u6216 exist\u3002","title":"\u6761\u6b3e49\uff1a\u4e86\u89e3new-handler\u7684\u884c\u4e3a"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#50newdelete","text":"\u66ff\u6362 operator new \u548c operator delete \u7684\u7406\u7531\uff1a - \u5ba2\u5236\u5316\u6765\u68c0\u6d4b\u8fd0\u7528\u4e0a\u7684\u9519\u8bef\u3002 - \u4e3a\u4e86\u5f3a\u5316\u6548\u80fd\u3002\u6839\u636e\u751f\u4ea7\u7ebf\u8fdb\u884c\u6700\u4f18\u64cd\u4f5c\u3002 - \u6536\u96c6\u4f7f\u7528\u4e0a\u7684\u7edf\u8ba1\u6570\u636e\u3002 - \u4e3a\u4e86\u964d\u4f4e\u7f3a\u7701\u5185\u5b58\u7ba1\u7406\u5668\u5e26\u6765\u7684\u7a7a\u95f4\u989d\u5916\u5f00\u9500\u3002 - \u4e3a\u4e86\u5f25\u8865\u7f3a\u7701\u5206\u914d\u5668\u4e2d\u7684\u975e\u6700\u4f73\u9f50\u4f4d(suboptimal alignment)\u3002 - \u4e3a\u4e86\u5c06\u76f8\u5173\u5bf9\u8c61\u6210\u7c07\u96c6\u4e2d\u3002 - \u4e3a\u4e86\u83b7\u5f97\u975e\u4f20\u7edf\u884c\u4e3a\u3002","title":"\u6761\u6b3e50\uff1a\u4e86\u89e3new\u548cdelete\u7684\u5408\u7406\u66ff\u6362\u65f6\u673a"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#51newdelete","text":"C++\u6807\u51c6\u8981\u6c42\uff0c\u5373\u4f7f\u662f\u7533\u8bf7\u4e00\u4e2a\u7a7a\u5185\u5b58\uff0c\u4e5f\u8981\u8fd4\u56de\u5730\u5740\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u4e00\u822c\u4f1a\u9009\u62e9\u8fd4\u56de\u4e00\u4e2a\u5927\u5c0f\u4e3a1\u7684\u5185\u5b58\u5730\u5740\u3002 operator new \u5185\u542b\u4e00\u4e2a\u65e0\u7a77\u5faa\u73af\uff0c\u5728\u5176\u4e2d\u5c1d\u8bd5\u5206\u914d\u5185\u5b58\u3002\u82e5\u5b83\u65e0\u6cd5\u6ee1\u8db3\u5185\u5b58\u9700\u6c42\uff0c\u5e94\u5f53\u8c03\u7528 new-handler \u3002 operator new \u5f80\u5f80\u4f1a\u9762\u4e34\u7ee7\u627f\u95ee\u9898\uff0c\u4e14\u88ab\u7ee7\u627f\u7684\u5b9e\u73b0\u65b9\u5f0f\u5f80\u5f80\u4e0d\u662f\u6700\u4f18\u8bbe\u8ba1\u3002\u56e0\u6b64\uff0c\u81ea\u5b9a\u4e49\u7684 operator new \u5e94\u5f53\u5904\u7406\u201c\u4e0d\u540c\u4e8e\u6b63\u786e\u5927\u5c0f\u7684\u5185\u5b58\u7533\u8bf7\u201d\u3002\u4e00\u822c\u7684\u5904\u7406\u65b9\u5f0f\u662f\u4ee4\u6807\u51c6\u7684 operator new \u5904\u7406\u5b83\u4eec\u3002 operator delete \u5e94\u5f53\u4fdd\u8bc1\u5bf9 nullptr \u4e0d\u505a\u4efb\u4f55\u4e8b\uff08\u56e0\u4e3aC++\u6807\u51c6\u4fdd\u8bc1 delete nullptr \u4e0d\u4f1a\u62a5\u9519\uff09\u3002","title":"\u6761\u6b3e51\uff1a\u7f16\u5199new\u548cdelete\u65f6\u9700\u56fa\u5b88\u5e38\u89c4"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#52placement-newplacement-delete","text":"placement new \u662f\u6307\u9664\u4e86\u5fc5\u987b\u7684 size_t \u53c2\u6570\u5916\u8fd8\u6709\u5176\u5b83\u989d\u5916\u53c2\u6570\u7684 operator new \u91cd\u8f7d\u3002\u4f8b\u5982\uff1a class Widget { public : static void * operator new ( std :: size_t size , std :: ostream & logStream ) throw ( std :: alloc ); /*...*/ } int main (){ Widget * pw = new ( std :: cerr ) Widget ; } \u7136\u800c\uff0c\u82e5\u6211\u4eec\u6210\u529f\u4e3a Widget \u5206\u914d\u5185\u5b58\uff0c\u5374\u5728\u6784\u9020\u65f6\u671f\u51fa\u9519\uff0c\u7f16\u8bd1\u5668\u5c31\u4f1a\u5bfb\u627e\u5bf9\u5e94\u7248\u672c\u7684 delete \u6765\u91ca\u653e\u8be5\u5185\u5b58\u3002\u5426\u5219\u5c31\u4f1a\uff08\u4ec0\u4e48\u90fd\u4e0d\u5e72\uff09\u9020\u6210\u5185\u5b58\u6cc4\u6f0f\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u5fc5\u987b\u5728\u58f0\u660e placement new \u7684\u540c\u65f6\u58f0\u660e placement delete\u3002\u4e0d\u8fc7\uff0c\u5728\u6211\u4eec\u83b7\u5f97 Widget \u6307\u9488\u6210\u529f\u540edelete\u5b83\uff0c\u7f16\u8bd1\u5668\u8c03\u7528\u7684\u4ecd\u7136\u662f\u65e0\u989d\u5916\u53c2\u6570\u7684 operator delete \u3002 \u5176\u6b21\uff0c\u6210\u5458\u51fd\u6570\u7684\u540d\u79f0\u4f1a\u63a9\u76d6\u5176\u5916\u56f4\u4f5c\u7528\u57df\uff08global scope\u3001base class\u2018 scope\u7b49\uff09\uff0c\u6240\u4ee5\u6211\u4eec\u5e94\u5f53\u4f7f\u7528using\u58f0\u660e\u5f0f\u53d6\u5f97\u6807\u51c6\u5f62\u5f0f\u3002\u4e00\u4e2a\u7b80\u5355\u7684\u65b9\u6cd5\u662f\uff0c\u5efa\u7acb\u4e00\u4e2a base class\uff0c\u62e5\u6709\u6240\u6709\u6b63\u5e38\u5f62\u5f0f\u7684 new \u548c delete\uff1a class StandardNewDeleteForms { public : // normal forms static void * operator new ( std :: size_ t size ) throw ( std :: bad_alloc ) { return :: operator new ( size ); } static void operator delete ( void * pMemory ) throw () { :: operator delete ( pMemory ); } // placement forms static void * operator new ( std :: size_ t size , void * ptr ) throw () { return :: operator new ( size , ptr ); } static void operator delete ( void * pMemory , void * ptr ) throw () { :: operator delete ( pMemory , ptr ); } // nothrow forms static void * operator new ( std :: size_ t size , const std :: nothrow_t & nt ) throw () { return :: operator new ( size , nt ); } static void operator delete ( void * pMemory , const std :: nothrow_t & ) throw () { :: operator delete ( pMemory ); } } class Widget : public StandardNewDeleteForms { public : // three base forms is visible and callable now using StandardNewDeleteForms :: operator new ; using StandardNewDeleteForms :: operator delete ; // personal form static void * operator new ( std :: size_t size , std :: ostream & logStream ) throw ( std :: bad_alloc ); static void operator delete ( std :: size_t size , std :: ostream & logStream ) throw (); }","title":"\u6761\u6b3e52\uff1a\u5199\u4e86placement New\u4e5f\u8981\u5199placement Delete"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#53","text":"\u52aa\u529b\u5728\u6700\u9ad8\u7ea7\u522b\u4e0b\u4e89\u53d6\u65e0\u8b66\u544a\u3002 \u5728\u786e\u5b9a\u5ffd\u7565\u67d0\u8b66\u544a\u65f6\uff0c\u786e\u4fdd\u81ea\u5df1\u4e86\u89e3\u8be5\u8b66\u544a\u7684\u771f\u5b9e\u610f\u4e49\u548c\u610f\u56fe\u3002","title":"\u6761\u6b3e53\uff1a\u4e0d\u8981\u8f7b\u5ffd\u7f16\u8bd1\u5668\u7684\u8b66\u544a"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#54tr1","text":"\u843d\u540e\u65f6\u4ee3\uff0c\u4e0d\u4e88\u8d58\u8ff0\u3002","title":"\u6761\u6b3e54\uff1a\u8ba9\u81ea\u5df1\u719f\u6089\u5305\u62ecTR1\u5728\u5185\u7684\u6807\u51c6\u7a0b\u5e8f\u5e93"},{"location":"Programming%20Language/C%2B%2B/Effective_C%2B%2B/#55boost","text":"Boost\u5e93\u7279\u70b9\uff1a 1. \u4e0eC++\u6807\u51c6\u59d4\u5458\u4f1a\u6709\u6df1\u539a\u8054\u7cfb\u548c\u5f71\u54cd\u529b\u3002\u662f\u4e4b\u540eC++\u6807\u51c6\u5e93\u7684\u201d\u5907\u9009\u5e93\u201c\u3002 2. \u5165 Boost \u5e93\u7684\u8fc7\u7a0b\u662f\u4e25\u683c\u7684\u516c\u5f00\u540c\u884c\u4e92\u5ba1(public peer review)\u3002","title":"\u6761\u6b3e55\uff1a\u8ba9\u81ea\u5df1\u719f\u6089Boost"}]}